<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ClipMark - Mark the Moments That Matter</title>

    <!-- Favicons and Apple Touch Icons -->
    <link rel="icon" type="image/svg+xml" href="logos/clipmark-favicon.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="167x167" href="apple-touch-icon-167x167.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ClipMark">
    <meta name="theme-color" content="#0f172a">

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { font-family: 'Inter', sans-serif; }
        .scrollbar-thin::-webkit-scrollbar { width: 6px; }
        .scrollbar-thin::-webkit-scrollbar-track { background: #1f2937; }
        .scrollbar-thin::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
        .scrollbar-thin::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Utility functions
        const formatTime = (seconds) => {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        };

        const formatPublishDate = (dateStr) => {
            if (!dateStr) return null;
            try {
                // Handle various date formats (YYYY-MM-DD, YYYYMMDD, etc.)
                const cleaned = dateStr.replace(/[^\d-]/g, '');
                let date;
                if (cleaned.length === 8 && !cleaned.includes('-')) {
                    // YYYYMMDD format
                    date = new Date(cleaned.slice(0,4), cleaned.slice(4,6) - 1, cleaned.slice(6,8));
                } else {
                    date = new Date(dateStr);
                }
                if (isNaN(date.getTime())) return null;
                return date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
            } catch (e) {
                return null;
            }
        };

        const parseTime = (timeStr) => {
            const parts = timeStr.split(':').map(Number);
            if (parts.length === 2) return parts[0] * 60 + parts[1];
            if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
            return 0;
        };

        // Legacy function for backward compatibility
        const extractVideoId = (url) => {
            const parsed = parseVideoUrl(url);
            return parsed && parsed.sourceType === 'youtube' ? parsed.sourceId : null;
        };

        // Parse video URL to extract source type, ID, and URL
        // Supports: YouTube, Vimeo, Loom, Wistia, and direct video URLs
        const parseVideoUrl = (url) => {
            if (!url || typeof url !== 'string') return null;

            const trimmedUrl = url.trim();

            // YouTube patterns
            const youtubePatterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/live\/)([^&\n?#]+)/,
                /^([a-zA-Z0-9_-]{11})$/ // Just the video ID
            ];
            for (const pattern of youtubePatterns) {
                const match = trimmedUrl.match(pattern);
                if (match) {
                    return {
                        sourceType: 'youtube',
                        sourceId: match[1],
                        sourceUrl: `https://www.youtube.com/watch?v=${match[1]}`
                    };
                }
            }

            // Vimeo patterns
            const vimeoPatterns = [
                /(?:vimeo\.com\/)(\d+)/,
                /(?:player\.vimeo\.com\/video\/)(\d+)/
            ];
            for (const pattern of vimeoPatterns) {
                const match = trimmedUrl.match(pattern);
                if (match) {
                    return {
                        sourceType: 'vimeo',
                        sourceId: match[1],
                        sourceUrl: `https://vimeo.com/${match[1]}`
                    };
                }
            }

            // Loom patterns
            const loomPatterns = [
                /(?:loom\.com\/share\/)([a-zA-Z0-9]+)/,
                /(?:loom\.com\/embed\/)([a-zA-Z0-9]+)/
            ];
            for (const pattern of loomPatterns) {
                const match = trimmedUrl.match(pattern);
                if (match) {
                    return {
                        sourceType: 'loom',
                        sourceId: match[1],
                        sourceUrl: `https://www.loom.com/share/${match[1]}`
                    };
                }
            }

            // Wistia patterns
            const wistiaPatterns = [
                /(?:wistia\.com\/medias\/)([a-zA-Z0-9]+)/,
                /(?:fast\.wistia\.net\/embed\/iframe\/)([a-zA-Z0-9]+)/,
                /(?:wistia\.net\/embed\/iframe\/)([a-zA-Z0-9]+)/
            ];
            for (const pattern of wistiaPatterns) {
                const match = trimmedUrl.match(pattern);
                if (match) {
                    return {
                        sourceType: 'wistia',
                        sourceId: match[1],
                        sourceUrl: `https://fast.wistia.net/embed/iframe/${match[1]}`
                    };
                }
            }

            // Google Drive patterns
            const googleDrivePatterns = [
                /drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]+)/,
                /drive\.google\.com\/open\?id=([a-zA-Z0-9_-]+)/
            ];
            for (const pattern of googleDrivePatterns) {
                const match = trimmedUrl.match(pattern);
                if (match) {
                    return {
                        sourceType: 'googledrive',
                        sourceId: match[1],
                        sourceUrl: `https://drive.google.com/file/d/${match[1]}/view`
                    };
                }
            }

            // Direct video URLs (mp4, webm, ogg, m3u8)
            const directVideoPattern = /\.(mp4|webm|ogg|m3u8)(\?|#|$)/i;
            if (directVideoPattern.test(trimmedUrl)) {
                // Use URL hash as ID for direct videos
                const hash = trimmedUrl.split('').reduce((a, b) => {
                    a = ((a << 5) - a) + b.charCodeAt(0);
                    return a & a;
                }, 0).toString(36);
                return {
                    sourceType: 'direct',
                    sourceId: `direct_${Math.abs(parseInt(hash, 36)).toString(36)}`,
                    sourceUrl: trimmedUrl
                };
            }

            return null;
        };

        // Get display name for source type
        const getSourceDisplayName = (sourceType) => {
            const names = {
                youtube: 'YouTube',
                vimeo: 'Vimeo',
                loom: 'Loom',
                wistia: 'Wistia',
                googledrive: 'Google Drive',
                direct: 'Video'
            };
            return names[sourceType] || 'Video';
        };

        // Get source color for badges
        const getSourceColor = (sourceType) => {
            const colors = {
                youtube: 'bg-red-500',
                vimeo: 'bg-blue-500',
                loom: 'bg-purple-500',
                wistia: 'bg-cyan-500',
                googledrive: 'bg-green-600',
                direct: 'bg-gray-500'
            };
            return colors[sourceType] || 'bg-gray-500';
        };

        // Migrate legacy video data to new format
        const migrateVideoData = (video) => {
            // If already migrated, return as-is
            if (video.sourceType && video.sourceId) {
                return video;
            }

            // Migrate from old videoId format (YouTube-only)
            return {
                ...video,
                sourceType: 'youtube',
                sourceId: video.videoId || video.sourceId,
                sourceUrl: video.videoId ? `https://www.youtube.com/watch?v=${video.videoId}` : video.sourceUrl,
                // Keep videoId for backward compatibility
                videoId: video.videoId
            };
        };

        // Migrate array of videos
        const migrateVideosArray = (videos) => {
            if (!Array.isArray(videos)) return [];
            return videos.map(migrateVideoData);
        };

        const generateId = () => Math.random().toString(36).substr(2, 9);

        // Storage Utility Functions
        const isStorageAvailable = (type) => {
            try {
                const storage = window[type];
                const testKey = '__storage_test__';
                storage.setItem(testKey, 'test');
                storage.removeItem(testKey);
                return true;
            } catch (e) {
                console.warn(`⚠️ ${type} not available:`, e.message);
                return false;
            }
        };

        const saveToStorage = (key, value, storage = localStorage) => {
            try {
                storage.setItem(key, JSON.stringify(value));
                return true;
            } catch (e) {
                console.error(`❌ Failed to save to storage (${key}):`, e.message);
                return false;
            }
        };

        const loadFromStorage = (key, storage = localStorage) => {
            try {
                const item = storage.getItem(key);
                return item ? JSON.parse(item) : null;
            } catch (e) {
                console.error(`❌ Failed to load from storage (${key}):`, e.message);
                return null;
            }
        };

        // Icons
        const Icons = {
            Search: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
            ),
            Plus: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                </svg>
            ),
            Bookmark: () => (
                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z" />
                </svg>
            ),
            Folder: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                </svg>
            ),
            Tag: () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />
                </svg>
            ),
            Play: () => (
                <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M8 5v14l11-7z" />
                </svg>
            ),
            Trash: () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
            ),
            Download: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                </svg>
            ),
            Upload: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                </svg>
            ),
            Clock: () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            ),
            Edit: () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                </svg>
            ),
            Grid: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
                </svg>
            ),
            X: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
            ),
            Sparkles: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />
                </svg>
            ),
            Settings: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
            ),
            Calendar: () => (
                <svg className="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                    <line x1="16" y1="2" x2="16" y2="6"/>
                    <line x1="8" y1="2" x2="8" y2="6"/>
                    <line x1="3" y1="10" x2="21" y2="10"/>
                </svg>
            ),
            Refresh: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
            ),
            Share: () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
                </svg>
            ),
            Users: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z" />
                </svg>
            ),
            List: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 10h16M4 14h16M4 18h16" />
                </svg>
            ),
            Eye: () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                </svg>
            ),
            // Video source icons
            YouTube: () => (
                <svg className="w-4 h-4" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                </svg>
            ),
            Vimeo: () => (
                <svg className="w-4 h-4" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M23.977 6.416c-.105 2.338-1.739 5.543-4.894 9.609-3.268 4.247-6.026 6.37-8.29 6.37-1.409 0-2.578-1.294-3.553-3.881L5.322 11.4C4.603 8.816 3.834 7.522 3.01 7.522c-.179 0-.806.378-1.881 1.132L0 7.197c1.185-1.044 2.351-2.084 3.501-3.128C5.08 2.701 6.266 1.984 7.055 1.91c1.867-.18 3.016 1.1 3.447 3.838.465 2.953.789 4.789.971 5.507.539 2.45 1.131 3.674 1.776 3.674.502 0 1.256-.796 2.265-2.385 1.004-1.589 1.54-2.797 1.612-3.628.144-1.371-.395-2.061-1.614-2.061-.574 0-1.167.121-1.777.391 1.186-3.868 3.434-5.757 6.762-5.637 2.473.06 3.628 1.664 3.493 4.797l-.013.01z"/>
                </svg>
            ),
            Loom: () => (
                <svg className="w-4 h-4" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm0 18.75a6.75 6.75 0 1 1 0-13.5 6.75 6.75 0 0 1 0 13.5z"/>
                    <circle cx="12" cy="12" r="3"/>
                </svg>
            ),
            Wistia: () => (
                <svg className="w-4 h-4" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M23.29 5.81c-.14-.2-.45-.32-.92-.24-1.27.21-3.37 1.42-5.11 2.88-.69.58-1.35 1.19-1.91 1.82l-.44.5c-.12-.35-.29-.65-.52-.89-.38-.4-.87-.62-1.42-.62-.27 0-.55.05-.83.16-.53.2-.95.56-1.2 1.03-.28.52-.35 1.14-.2 1.74.13.54.44 1.01.88 1.35-1.55 2.45-2.91 4.63-3.55 5.56-.27.38-.42.62-.63.81l-.08.07c-.21.17-.51.36-.87.56-.79.45-1.63.74-2.04.68-.27-.04-.45-.17-.57-.42-.15-.3-.17-.71-.07-1.19.44-2.09 3.39-8.49 6.61-14.35.29-.53.22-.92-.2-1.16-.41-.24-.89-.06-1.26.47C6.18 8.27 2.79 15.52 2.35 17.6c-.18.85-.12 1.58.18 2.17.31.61.82.99 1.52 1.1.84.13 1.93-.15 3.04-.74.49-.26.91-.53 1.26-.82.25-.21.42-.39.6-.62.73-1.03 2.17-3.36 3.84-6 .02 0 .04.01.06.01.7 0 1.36-.27 1.87-.78.52-.52.8-1.2.8-1.93 0-.2-.02-.4-.07-.59l.59-.66c.53-.6 1.14-1.16 1.76-1.68 1.45-1.21 3.17-2.2 4.02-2.34.29-.05.47.01.52.08.08.11.03.36-.16.72-.82 1.52-2.8 4.89-5.1 8.26-.3.44-.24.84.17 1.09.4.25.88.12 1.21-.35 2.37-3.48 4.42-6.96 5.29-8.58.5-.93.57-1.72.04-2.48z"/>
                </svg>
            ),
            GoogleDrive: () => (
                <svg className="w-4 h-4" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M4.433 22.396l4-6.93H24l-4 6.93H4.433zm3.566-6.93L0 3.396h8L16 15.466H8zm8-12.07h8l-8 13.86-4-6.93 4-6.93z"/>
                </svg>
            ),
            VideoFile: () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                </svg>
            ),
            Transcript: () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
            ),
            FileText: () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
            ),
            AlertCircle: () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="10" strokeWidth={2} />
                    <line x1="12" y1="8" x2="12" y2="12" strokeWidth={2} strokeLinecap="round" />
                    <line x1="12" y1="16" x2="12.01" y2="16" strokeWidth={2} strokeLinecap="round" />
                </svg>
            ),
            Info: () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="10" strokeWidth={2} />
                    <line x1="12" y1="16" x2="12" y2="12" strokeWidth={2} strokeLinecap="round" />
                    <line x1="12" y1="8" x2="12.01" y2="8" strokeWidth={2} strokeLinecap="round" />
                </svg>
            )
        };

        // Video Source Badge Component
        const VideoSourceBadge = ({ sourceType, className = '' }) => {
            const iconMap = {
                youtube: Icons.YouTube,
                vimeo: Icons.Vimeo,
                loom: Icons.Loom,
                wistia: Icons.Wistia,
                googledrive: Icons.GoogleDrive,
                direct: Icons.VideoFile
            };
            const Icon = iconMap[sourceType] || Icons.VideoFile;
            const color = getSourceColor(sourceType);
            const name = getSourceDisplayName(sourceType);

            return (
                <span className={`inline-flex items-center gap-1 px-2 py-0.5 rounded text-xs font-medium text-white ${color} ${className}`}>
                    <Icon />
                    <span>{name}</span>
                </span>
            );
        };

        // Tip-finding keywords and phrases (legacy - kept for fallback)
        const TIP_PATTERNS = [
            // Direct tip mentions
            /(?:here'?s?\s+(?:a\s+)?(?:pro\s+)?tip|tip\s*(?:number|#)?\s*\d*|quick\s+tip|hot\s+tip|bonus\s+tip)/i,
            // Important callouts
            /(?:important(?:ly)?|key\s+point|remember\s+(?:this|that)|don'?t\s+forget|keep\s+in\s+mind|note\s+that|pay\s+attention)/i,
            // Advice phrases
            /(?:you\s+should|make\s+sure|always\s+(?:remember|make)|never\s+(?:forget|do)|the\s+(?:trick|secret|key)\s+is)/i,
            // Best practices
            /(?:best\s+practice|pro\s+tip|life\s+hack|game\s+changer|this\s+is\s+(?:huge|important|critical))/i,
            // Mistakes to avoid
            /(?:(?:common\s+)?mistake|avoid\s+(?:this|doing)|don'?t\s+(?:make\s+)?this\s+(?:mistake|error))/i,
            // Recommendations
            /(?:i\s+(?:highly\s+)?recommend|my\s+(?:top\s+)?recommendation|what\s+(?:i\s+)?suggest)/i
        ];

        // Gemini AI API for transcript analysis (via server proxy)
        const analyzeTranscriptWithGemini = async (transcript, serverUrl, authToken) => {
            const fullText = transcript.map(t => `[${formatTime(t.start)}] ${t.text}`).join('\n');

            const prompt = `You are analyzing a YouTube video transcript to extract key tips, insights, and actionable advice.

Transcript:
${fullText}

Instructions:
1. Identify the most valuable tips, insights, key points, and actionable advice from this transcript
2. For each tip found, provide the exact timestamp where it appears (use the timestamps from the transcript)
3. Summarize each tip concisely but include enough context to be useful
4. Focus on practical, actionable information
5. Ignore filler content, introductions, and promotional material

Return your response as a JSON array with this exact format:
[
  {"timestamp": 45.5, "tip": "Brief description of the tip or insight"},
  {"timestamp": 120.0, "tip": "Another tip description"}
]

Only return the JSON array, no other text. If no meaningful tips are found, return an empty array [].`;

            const response = await fetch(`${serverUrl}/api/gemini`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${authToken}`
                },
                body: JSON.stringify({ prompt, maxTokens: 2048, temperature: 0.3 })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `API error: ${response.status}`);
            }

            const data = await response.json();
            const responseText = data.text || '';

            // Extract JSON from response (handle markdown code blocks)
            let jsonStr = responseText;
            const jsonMatch = responseText.match(/```(?:json)?\s*([\s\S]*?)```/);
            if (jsonMatch) {
                jsonStr = jsonMatch[1];
            }

            // Clean and parse JSON
            jsonStr = jsonStr.trim();
            if (!jsonStr.startsWith('[')) {
                const arrayStart = jsonStr.indexOf('[');
                const arrayEnd = jsonStr.lastIndexOf(']');
                if (arrayStart !== -1 && arrayEnd !== -1) {
                    jsonStr = jsonStr.substring(arrayStart, arrayEnd + 1);
                }
            }

            const tips = JSON.parse(jsonStr);
            return tips;
        };

        // AI function to summarize a note with transcript context (via server proxy)
        const summarizeNoteWithContext = async (contextText, originalNote, serverUrl, authToken) => {
            const prompt = `You are helping to enhance and clarify notes taken while watching a video. Given the transcript context and the original note, create a clear, bullet-point summary that captures the complete thought.

Transcript context (words surrounding the note timestamp):
"${contextText}"

Original note:
"${originalNote}"

Instructions:
1. Understand what topic or idea the note is referring to based on the transcript context
2. Create a concise bullet-point summary (1-3 bullets) that captures the complete thought
3. Each bullet should start with "- " and be on its own line
4. If the context is unclear or could have multiple interpretations, flag this as ambiguous
5. If ambiguous, provide 2-3 alternative interpretations as separate summaries

Return your response as a JSON object with this exact format:
{
  "summary": "- First bullet point\\n- Second bullet point",
  "isAmbiguous": false,
  "alternatives": null
}

OR if ambiguous:
{
  "summary": "- Most likely interpretation bullet",
  "isAmbiguous": true,
  "alternatives": ["- Alternative interpretation 1", "- Alternative interpretation 2"]
}

Only return the JSON object, no other text.`;

            const response = await fetch(`${serverUrl}/api/gemini`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${authToken}`
                },
                body: JSON.stringify({ prompt, maxTokens: 1024, temperature: 0.3 })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `API error: ${response.status}`);
            }

            const data = await response.json();
            const responseText = data.text || '';

            // Extract JSON from response (handle markdown code blocks)
            let jsonStr = responseText;
            const jsonMatch = responseText.match(/```(?:json)?\s*([\s\S]*?)```/);
            if (jsonMatch) {
                jsonStr = jsonMatch[1];
            }

            // Clean and parse JSON
            jsonStr = jsonStr.trim();
            if (!jsonStr.startsWith('{')) {
                const objStart = jsonStr.indexOf('{');
                const objEnd = jsonStr.lastIndexOf('}');
                if (objStart !== -1 && objEnd !== -1) {
                    jsonStr = jsonStr.substring(objStart, objEnd + 1);
                }
            }

            const result = JSON.parse(jsonStr);
            return {
                summary: result.summary || originalNote,
                isAmbiguous: result.isAmbiguous || false,
                alternatives: result.alternatives || null
            };
        };

        // Function to fetch YouTube transcript using local proxy server
        const fetchTranscript = async (videoId) => {
            // Auto-detect server: use same host as page, or localhost if on file://
            const SERVER_HOST = window.location.protocol === 'file:'
                ? 'localhost'
                : window.location.hostname;
            // Use same origin when served via nginx (port 80), otherwise use port 3456
            const LOCAL_SERVER = (window.location.port === '' || window.location.port === '80')
                ? window.location.origin
                : `http://${SERVER_HOST}:3456`;

            // Method 1: Try local transcript server (most reliable - no CORS issues)
            const tryLocalServer = async () => {
                try {
                    console.log('Trying local transcript server...');
                    const response = await fetch(`${LOCAL_SERVER}/transcript?v=${videoId}`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.transcript && data.transcript.length > 0) {
                            return data.transcript;
                        }
                        if (data.error) {
                            console.log('Local server error:', data.error);
                        }
                    }
                } catch (e) {
                    console.log('Local server not available:', e.message);
                }
                return null;
            };

            // Method 2: Direct YouTube timedtext API (fallback, may work for some videos)
            const tryDirectTimedText = async () => {
                try {
                    console.log('Trying direct YouTube timedtext...');
                    const langs = ['en', 'en-US', 'en-GB', 'a.en'];
                    for (const lang of langs) {
                        const url = `https://www.youtube.com/api/timedtext?v=${videoId}&lang=${lang}&fmt=srv3`;
                        const response = await fetch(url);
                        if (response.ok) {
                            const text = await response.text();
                            if (text && text.includes('<p')) {
                                const parser = new DOMParser();
                                const xmlDoc = parser.parseFromString(text, 'text/xml');
                                const textElements = xmlDoc.getElementsByTagName('p');

                                if (textElements.length > 0) {
                                    const transcript = [];
                                    for (let el of textElements) {
                                        const start = parseFloat(el.getAttribute('t') || '0') / 1000;
                                        const duration = parseFloat(el.getAttribute('d') || '0') / 1000;
                                        transcript.push({
                                            start,
                                            duration,
                                            text: el.textContent
                                                ?.replace(/&#39;/g, "'")
                                                .replace(/&quot;/g, '"')
                                                .replace(/&amp;/g, '&')
                                                .trim() || ''
                                        });
                                    }
                                    if (transcript.length > 0) {
                                        return transcript.filter(t => t.text);
                                    }
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.log('Direct timedtext failed:', e.message);
                }
                return null;
            };

            try {
                // Try local server first (requires running transcript-server.js)
                let transcript = await tryLocalServer();
                if (transcript && transcript.length > 0) {
                    console.log(`Got ${transcript.length} transcript segments via local server`);
                    return transcript;
                }

                // Fallback to direct API (usually blocked by CORS)
                transcript = await tryDirectTimedText();
                if (transcript && transcript.length > 0) {
                    console.log(`Got ${transcript.length} transcript segments via direct timedtext`);
                    return transcript;
                }

                console.log('All transcript fetch methods failed');
                console.log('Make sure the transcript server is running: node transcript-server.js');
                return null;
            } catch (error) {
                console.error('Transcript fetch error:', error);
                return null;
            }
        };

        // Function to find tips in transcript
        const findTipsInTranscript = (transcript) => {
            const tips = [];
            const windowSize = 3; // Look at groups of 3 segments for context

            for (let i = 0; i < transcript.length; i++) {
                // Build context from surrounding segments
                const contextSegments = transcript.slice(
                    Math.max(0, i - 1),
                    Math.min(transcript.length, i + windowSize)
                );
                const contextText = contextSegments.map(s => s.text).join(' ');

                // Check if any tip pattern matches
                for (const pattern of TIP_PATTERNS) {
                    if (pattern.test(contextText)) {
                        // Get the full tip content (current segment + next few)
                        const tipSegments = transcript.slice(i, Math.min(transcript.length, i + 3));
                        const tipText = tipSegments.map(s => s.text).join(' ').trim();

                        // Avoid duplicates (within 10 seconds)
                        const isDuplicate = tips.some(t =>
                            Math.abs(t.timestamp - transcript[i].start) < 10
                        );

                        if (!isDuplicate && tipText.length > 10) {
                            tips.push({
                                timestamp: transcript[i].start,
                                text: tipText,
                                matchedPattern: pattern.source
                            });
                        }
                        break;
                    }
                }
            }

            return tips;
        };

        // YouTube Player Component
        const YouTubePlayer = ({ videoId, onTimeUpdate, playerRef, onWatchTime }) => {
            const [playerId] = useState(() => `yt-player-${generateId()}`);
            const [isReady, setIsReady] = useState(false);
            const [playerError, setPlayerError] = useState(null);

            useEffect(() => {
                if (!videoId) return;

                let isMounted = true;
                setPlayerError(null);

                // Clean up existing player
                const cleanupPlayer = () => {
                    if (playerRef.current) {
                        try {
                            if (playerRef.current._timeInterval) {
                                clearInterval(playerRef.current._timeInterval);
                            }
                            playerRef.current.destroy();
                        } catch (e) {
                            console.log('Player cleanup error:', e);
                        }
                        playerRef.current = null;
                    }
                };

                // Load YouTube IFrame API
                const loadYouTubeAPI = () => {
                    return new Promise((resolve) => {
                        if (window.YT && window.YT.Player) {
                            resolve();
                            return;
                        }

                        // Check if script is already loading
                        if (document.querySelector('script[src*="youtube.com/iframe_api"]')) {
                            const checkReady = setInterval(() => {
                                if (window.YT && window.YT.Player) {
                                    clearInterval(checkReady);
                                    resolve();
                                }
                            }, 100);
                            return;
                        }

                        const tag = document.createElement('script');
                        tag.src = 'https://www.youtube.com/iframe_api';
                        const firstScriptTag = document.getElementsByTagName('script')[0];
                        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

                        window.onYouTubeIframeAPIReady = () => {
                            resolve();
                        };
                    });
                };

                const initPlayer = async () => {
                    await loadYouTubeAPI();

                    if (!isMounted) return;

                    // Wait for DOM element to be ready
                    const container = document.getElementById(playerId);
                    if (!container) {
                        console.error('Player container not found');
                        return;
                    }

                    cleanupPlayer();

                    try {
                        playerRef.current = new window.YT.Player(playerId, {
                            height: '100%',
                            width: '100%',
                            videoId: videoId,
                            playerVars: {
                                autoplay: 0,
                                modestbranding: 1,
                                rel: 0,
                                enablejsapi: 1,
                                fs: 1,
                                cc_load_policy: 1,  // Enable captions by default
                                cc_lang_pref: 'en'  // Prefer English captions
                            },
                            events: {
                                onReady: () => {
                                    if (isMounted) setIsReady(true);
                                },
                                onError: (event) => {
                                    console.error('YouTube Player Error:', event.data);
                                    if (isMounted) {
                                        setPlayerError(`Video error (code: ${event.data})`);
                                    }
                                },
                                onStateChange: (event) => {
                                    if (!isMounted) return;
                                    if (event.data === window.YT.PlayerState.PLAYING) {
                                        // Clear existing interval
                                        if (playerRef.current._timeInterval) {
                                            clearInterval(playerRef.current._timeInterval);
                                        }
                                        // Track watch time start
                                        playerRef.current._watchTimeStart = Date.now();
                                        // Time update interval
                                        const interval = setInterval(() => {
                                            if (playerRef.current && playerRef.current.getCurrentTime) {
                                                try {
                                                    onTimeUpdate(playerRef.current.getCurrentTime());
                                                } catch (e) {}
                                            }
                                        }, 1000);
                                        playerRef.current._timeInterval = interval;
                                    } else {
                                        // Video stopped/paused
                                        if (playerRef.current && playerRef.current._timeInterval) {
                                            clearInterval(playerRef.current._timeInterval);
                                        }
                                        // Calculate and report watch time
                                        if (playerRef.current?._watchTimeStart && onWatchTime) {
                                            const watchedSeconds = Math.round((Date.now() - playerRef.current._watchTimeStart) / 1000);
                                            if (watchedSeconds > 0) {
                                                onWatchTime(videoId, watchedSeconds);
                                            }
                                            playerRef.current._watchTimeStart = null;
                                        }
                                    }
                                }
                            }
                        });
                    } catch (e) {
                        console.error('Player initialization error:', e);
                        if (isMounted) {
                            setPlayerError('Failed to initialize player');
                        }
                    }
                };

                // Small delay to ensure DOM is ready
                const timer = setTimeout(initPlayer, 100);

                return () => {
                    isMounted = false;
                    clearTimeout(timer);
                    cleanupPlayer();
                };
            }, [videoId, playerId]);

            if (!videoId) {
                return (
                    <div className="w-full h-full bg-gray-800 rounded-lg flex items-center justify-center">
                        <div className="text-center text-gray-400">
                            <Icons.Bookmark />
                            <p className="mt-2">Select a video or add a new bookmark</p>
                        </div>
                    </div>
                );
            }

            if (playerError) {
                return (
                    <div className="w-full h-full bg-gray-800 rounded-lg flex flex-col items-center justify-center">
                        <div className="text-center text-gray-400">
                            <p className="text-emerald-400 mb-2">{playerError}</p>
                            <a
                                href={`https://www.youtube.com/watch?v=${videoId}`}
                                target="_blank"
                                rel="noopener noreferrer"
                                className="text-emerald-500 hover:text-emerald-400 underline"
                            >
                                Watch on YouTube
                            </a>
                        </div>
                    </div>
                );
            }

            return <div id={playerId} className="w-full h-full rounded-lg overflow-hidden" />;
        };

        // Vimeo Player Adapter
        const VimeoPlayerAdapter = ({ sourceId, onTimeUpdate, playerRef, onWatchTime }) => {
            const [playerId] = useState(() => `vimeo-player-${generateId()}`);
            const [isReady, setIsReady] = useState(false);
            const [playerError, setPlayerError] = useState(null);

            useEffect(() => {
                if (!sourceId) return;

                let isMounted = true;
                let player = null;
                setPlayerError(null);

                // Load Vimeo Player SDK
                const loadVimeoSDK = () => {
                    return new Promise((resolve, reject) => {
                        if (window.Vimeo && window.Vimeo.Player) {
                            resolve();
                            return;
                        }

                        if (document.querySelector('script[src*="player.vimeo.com/api/player.js"]')) {
                            const checkReady = setInterval(() => {
                                if (window.Vimeo && window.Vimeo.Player) {
                                    clearInterval(checkReady);
                                    resolve();
                                }
                            }, 100);
                            return;
                        }

                        const script = document.createElement('script');
                        script.src = 'https://player.vimeo.com/api/player.js';
                        script.onload = () => resolve();
                        script.onerror = () => reject(new Error('Failed to load Vimeo SDK'));
                        document.head.appendChild(script);
                    });
                };

                const initPlayer = async () => {
                    try {
                        await loadVimeoSDK();

                        if (!isMounted) return;

                        const container = document.getElementById(playerId);
                        if (!container) {
                            console.error('Vimeo player container not found');
                            return;
                        }

                        player = new window.Vimeo.Player(playerId, {
                            id: sourceId,
                            width: '100%',
                            responsive: true
                        });

                        // Create a wrapper object with consistent API
                        playerRef.current = {
                            getCurrentTime: async () => {
                                try {
                                    return await player.getCurrentTime();
                                } catch (e) {
                                    return 0;
                                }
                            },
                            seekTo: (seconds) => {
                                player.setCurrentTime(seconds).catch(e => console.warn('Vimeo seek error:', e));
                            },
                            destroy: () => {
                                if (playerRef.current?._timeInterval) {
                                    clearInterval(playerRef.current._timeInterval);
                                }
                                player.destroy();
                            },
                            _player: player,
                            _watchTimeStart: null,
                            _timeInterval: null
                        };

                        player.on('loaded', () => {
                            if (isMounted) setIsReady(true);
                        });

                        player.on('error', (error) => {
                            console.error('Vimeo Player Error:', error);
                            if (isMounted) setPlayerError(error.message || 'Video playback error');
                        });

                        player.on('play', () => {
                            if (playerRef.current._timeInterval) {
                                clearInterval(playerRef.current._timeInterval);
                            }
                            playerRef.current._watchTimeStart = Date.now();
                            const interval = setInterval(async () => {
                                try {
                                    const time = await player.getCurrentTime();
                                    onTimeUpdate(time);
                                } catch (e) {}
                            }, 1000);
                            playerRef.current._timeInterval = interval;
                        });

                        player.on('pause', () => {
                            if (playerRef.current?._timeInterval) {
                                clearInterval(playerRef.current._timeInterval);
                            }
                            if (playerRef.current?._watchTimeStart && onWatchTime) {
                                const watchedSeconds = Math.round((Date.now() - playerRef.current._watchTimeStart) / 1000);
                                if (watchedSeconds > 0) {
                                    onWatchTime(sourceId, watchedSeconds);
                                }
                                playerRef.current._watchTimeStart = null;
                            }
                        });

                    } catch (e) {
                        console.error('Vimeo player initialization error:', e);
                        if (isMounted) setPlayerError('Failed to load Vimeo player');
                    }
                };

                const timer = setTimeout(initPlayer, 100);

                return () => {
                    isMounted = false;
                    clearTimeout(timer);
                    if (playerRef.current) {
                        try {
                            playerRef.current.destroy();
                        } catch (e) {}
                        playerRef.current = null;
                    }
                };
            }, [sourceId, playerId]);

            if (!sourceId) {
                return (
                    <div className="w-full h-full bg-gray-800 rounded-lg flex items-center justify-center">
                        <div className="text-center text-gray-400">
                            <Icons.Bookmark />
                            <p className="mt-2">Select a video or add a new bookmark</p>
                        </div>
                    </div>
                );
            }

            if (playerError) {
                return (
                    <div className="w-full h-full bg-gray-800 rounded-lg flex flex-col items-center justify-center">
                        <div className="text-center text-gray-400">
                            <p className="text-red-400 mb-2">{playerError}</p>
                            <a
                                href={`https://vimeo.com/${sourceId}`}
                                target="_blank"
                                rel="noopener noreferrer"
                                className="text-blue-500 hover:text-blue-400 underline"
                            >
                                Watch on Vimeo
                            </a>
                        </div>
                    </div>
                );
            }

            return <div id={playerId} className="w-full h-full rounded-lg overflow-hidden" />;
        };

        // HTML5 Video Player Adapter (for direct video URLs)
        const HTML5PlayerAdapter = ({ sourceUrl, onTimeUpdate, playerRef, onWatchTime }) => {
            const videoRef = useRef(null);
            const [playerError, setPlayerError] = useState(null);

            useEffect(() => {
                if (!sourceUrl || !videoRef.current) return;

                const video = videoRef.current;
                let timeInterval = null;
                let watchTimeStart = null;

                // Create wrapper with consistent API
                playerRef.current = {
                    getCurrentTime: () => video.currentTime,
                    seekTo: (seconds) => {
                        video.currentTime = seconds;
                    },
                    destroy: () => {
                        if (timeInterval) clearInterval(timeInterval);
                        video.pause();
                        video.src = '';
                    },
                    _video: video,
                    _watchTimeStart: null,
                    _timeInterval: null
                };

                const handlePlay = () => {
                    if (timeInterval) clearInterval(timeInterval);
                    watchTimeStart = Date.now();
                    playerRef.current._watchTimeStart = watchTimeStart;
                    timeInterval = setInterval(() => {
                        onTimeUpdate(video.currentTime);
                    }, 1000);
                    playerRef.current._timeInterval = timeInterval;
                };

                const handlePause = () => {
                    if (timeInterval) {
                        clearInterval(timeInterval);
                        timeInterval = null;
                    }
                    if (watchTimeStart && onWatchTime) {
                        const watchedSeconds = Math.round((Date.now() - watchTimeStart) / 1000);
                        if (watchedSeconds > 0) {
                            onWatchTime(sourceUrl, watchedSeconds);
                        }
                        watchTimeStart = null;
                        playerRef.current._watchTimeStart = null;
                    }
                };

                const handleError = () => {
                    setPlayerError('Failed to load video. The video may be unavailable or the URL may have expired.');
                };

                video.addEventListener('play', handlePlay);
                video.addEventListener('pause', handlePause);
                video.addEventListener('ended', handlePause);
                video.addEventListener('error', handleError);

                return () => {
                    if (timeInterval) clearInterval(timeInterval);
                    video.removeEventListener('play', handlePlay);
                    video.removeEventListener('pause', handlePause);
                    video.removeEventListener('ended', handlePause);
                    video.removeEventListener('error', handleError);
                };
            }, [sourceUrl]);

            if (!sourceUrl) {
                return (
                    <div className="w-full h-full bg-gray-800 rounded-lg flex items-center justify-center">
                        <div className="text-center text-gray-400">
                            <Icons.Bookmark />
                            <p className="mt-2">Select a video or add a new bookmark</p>
                        </div>
                    </div>
                );
            }

            if (playerError) {
                return (
                    <div className="w-full h-full bg-gray-800 rounded-lg flex flex-col items-center justify-center">
                        <div className="text-center text-gray-400">
                            <p className="text-red-400 mb-2">{playerError}</p>
                            <a
                                href={sourceUrl}
                                target="_blank"
                                rel="noopener noreferrer"
                                className="text-emerald-500 hover:text-emerald-400 underline"
                            >
                                Open video directly
                            </a>
                        </div>
                    </div>
                );
            }

            return (
                <video
                    ref={videoRef}
                    src={sourceUrl}
                    controls
                    className="w-full h-full rounded-lg bg-black"
                    playsInline
                >
                    Your browser does not support the video tag.
                </video>
            );
        };

        // Wistia Player Adapter
        const WistiaPlayerAdapter = ({ sourceId, onTimeUpdate, playerRef, onWatchTime }) => {
            const [playerId] = useState(() => `wistia-player-${generateId()}`);
            const [isReady, setIsReady] = useState(false);
            const [playerError, setPlayerError] = useState(null);

            useEffect(() => {
                if (!sourceId) return;

                let isMounted = true;
                setPlayerError(null);

                // Load Wistia SDK
                const loadWistiaSDK = () => {
                    return new Promise((resolve) => {
                        // Check if already loaded
                        if (window.Wistia) {
                            resolve();
                            return;
                        }

                        // Setup the queue
                        window._wq = window._wq || [];

                        // Check if script is already loading
                        if (document.querySelector('script[src*="fast.wistia.com"]')) {
                            // Wait for it to load
                            const checkReady = setInterval(() => {
                                if (window.Wistia) {
                                    clearInterval(checkReady);
                                    resolve();
                                }
                            }, 100);
                            return;
                        }

                        const script = document.createElement('script');
                        script.src = 'https://fast.wistia.com/assets/external/E-v1.js';
                        script.async = true;
                        script.onload = () => {
                            const checkReady = setInterval(() => {
                                if (window.Wistia) {
                                    clearInterval(checkReady);
                                    resolve();
                                }
                            }, 100);
                        };
                        document.head.appendChild(script);
                    });
                };

                const initPlayer = async () => {
                    try {
                        await loadWistiaSDK();

                        if (!isMounted) return;

                        // Use Wistia's queue system
                        window._wq.push({
                            id: sourceId,
                            onReady: (video) => {
                                if (!isMounted) return;

                                playerRef.current = {
                                    getCurrentTime: () => video.time(),
                                    seekTo: (seconds) => video.time(seconds),
                                    destroy: () => {
                                        if (playerRef.current?._timeInterval) {
                                            clearInterval(playerRef.current._timeInterval);
                                        }
                                        video.remove();
                                    },
                                    _video: video,
                                    _watchTimeStart: null,
                                    _timeInterval: null
                                };

                                setIsReady(true);

                                video.bind('play', () => {
                                    if (playerRef.current._timeInterval) {
                                        clearInterval(playerRef.current._timeInterval);
                                    }
                                    playerRef.current._watchTimeStart = Date.now();
                                    const interval = setInterval(() => {
                                        onTimeUpdate(video.time());
                                    }, 1000);
                                    playerRef.current._timeInterval = interval;
                                });

                                video.bind('pause', () => {
                                    if (playerRef.current?._timeInterval) {
                                        clearInterval(playerRef.current._timeInterval);
                                    }
                                    if (playerRef.current?._watchTimeStart && onWatchTime) {
                                        const watchedSeconds = Math.round((Date.now() - playerRef.current._watchTimeStart) / 1000);
                                        if (watchedSeconds > 0) {
                                            onWatchTime(sourceId, watchedSeconds);
                                        }
                                        playerRef.current._watchTimeStart = null;
                                    }
                                });
                            }
                        });

                    } catch (e) {
                        console.error('Wistia player initialization error:', e);
                        if (isMounted) setPlayerError('Failed to load Wistia player');
                    }
                };

                const timer = setTimeout(initPlayer, 100);

                return () => {
                    isMounted = false;
                    clearTimeout(timer);
                    if (playerRef.current) {
                        try {
                            playerRef.current.destroy();
                        } catch (e) {}
                        playerRef.current = null;
                    }
                };
            }, [sourceId, playerId]);

            if (!sourceId) {
                return (
                    <div className="w-full h-full bg-gray-800 rounded-lg flex items-center justify-center">
                        <div className="text-center text-gray-400">
                            <Icons.Bookmark />
                            <p className="mt-2">Select a video or add a new bookmark</p>
                        </div>
                    </div>
                );
            }

            if (playerError) {
                return (
                    <div className="w-full h-full bg-gray-800 rounded-lg flex flex-col items-center justify-center">
                        <div className="text-center text-gray-400">
                            <p className="text-red-400 mb-2">{playerError}</p>
                            <a
                                href={`https://fast.wistia.net/embed/iframe/${sourceId}`}
                                target="_blank"
                                rel="noopener noreferrer"
                                className="text-cyan-500 hover:text-cyan-400 underline"
                            >
                                Watch on Wistia
                            </a>
                        </div>
                    </div>
                );
            }

            return (
                <div className="w-full h-full rounded-lg overflow-hidden">
                    <div
                        className={`wistia_embed wistia_async_${sourceId} videoFoam=true`}
                        style={{ height: '100%', width: '100%' }}
                    />
                </div>
            );
        };

        // Loom Player Adapter (limited API - no programmatic seeking)
        const LoomPlayerAdapter = ({ sourceId, onTimeUpdate, playerRef, onWatchTime }) => {
            const [showWarning, setShowWarning] = useState(true);
            const iframeRef = useRef(null);

            useEffect(() => {
                if (!sourceId) return;

                // Loom doesn't have a public player API
                // We can only embed and watch, no programmatic control
                playerRef.current = {
                    getCurrentTime: () => {
                        console.warn('Loom player does not support getCurrentTime');
                        return 0;
                    },
                    seekTo: (seconds) => {
                        console.warn('Loom player does not support programmatic seeking');
                    },
                    destroy: () => {
                        // No cleanup needed for iframe
                    },
                    _isLoom: true,
                    _limited: true
                };

                return () => {
                    playerRef.current = null;
                };
            }, [sourceId]);

            if (!sourceId) {
                return (
                    <div className="w-full h-full bg-gray-800 rounded-lg flex items-center justify-center">
                        <div className="text-center text-gray-400">
                            <Icons.Bookmark />
                            <p className="mt-2">Select a video or add a new bookmark</p>
                        </div>
                    </div>
                );
            }

            return (
                <div className="w-full h-full relative rounded-lg overflow-hidden">
                    {showWarning && (
                        <div className="absolute top-2 left-2 right-2 z-10 bg-yellow-500/90 text-yellow-900 px-3 py-2 rounded-lg text-sm flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <Icons.AlertCircle />
                                <span>Loom videos have limited controls - timestamp seeking is not available</span>
                            </div>
                            <button
                                onClick={() => setShowWarning(false)}
                                className="hover:text-yellow-700"
                            >
                                <Icons.X />
                            </button>
                        </div>
                    )}
                    <iframe
                        ref={iframeRef}
                        src={`https://www.loom.com/embed/${sourceId}`}
                        frameBorder="0"
                        allowFullScreen
                        className="w-full h-full"
                        allow="autoplay; fullscreen"
                    />
                </div>
            );
        };

        // Google Drive Player Adapter (iframe-based, limited controls like Loom)
        const GoogleDrivePlayerAdapter = ({ sourceId, onTimeUpdate, playerRef, onWatchTime }) => {
            const [showWarning, setShowWarning] = useState(true);
            const iframeRef = useRef(null);

            useEffect(() => {
                if (!sourceId) return;

                // Google Drive doesn't have a player API
                // We can only embed and watch, no programmatic control
                playerRef.current = {
                    getCurrentTime: () => {
                        console.warn('Google Drive player does not support getCurrentTime');
                        return 0;
                    },
                    seekTo: (seconds) => {
                        console.warn('Google Drive player does not support programmatic seeking');
                    },
                    destroy: () => {
                        // No cleanup needed for iframe
                    },
                    _isGoogleDrive: true,
                    _limited: true
                };

                return () => {
                    playerRef.current = null;
                };
            }, [sourceId]);

            if (!sourceId) {
                return (
                    <div className="w-full h-full bg-gray-800 rounded-lg flex items-center justify-center">
                        <div className="text-center text-gray-400">
                            <Icons.Bookmark />
                            <p className="mt-2">Select a video or add a new bookmark</p>
                        </div>
                    </div>
                );
            }

            return (
                <div className="w-full h-full relative rounded-lg overflow-hidden">
                    {showWarning && (
                        <div className="absolute top-2 left-2 right-2 z-10 bg-yellow-500/90 text-yellow-900 px-3 py-2 rounded-lg text-sm flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <Icons.AlertCircle />
                                <span>Google Drive videos have limited controls - timestamp seeking is not available</span>
                            </div>
                            <button
                                onClick={() => setShowWarning(false)}
                                className="hover:text-yellow-700"
                            >
                                <Icons.X />
                            </button>
                        </div>
                    )}
                    <iframe
                        ref={iframeRef}
                        src={`https://drive.google.com/file/d/${sourceId}/preview`}
                        frameBorder="0"
                        allowFullScreen
                        className="w-full h-full"
                        allow="autoplay; fullscreen"
                    />
                </div>
            );
        };

        // Unified Video Player Wrapper
        const VideoPlayer = ({ video, onTimeUpdate, playerRef, onWatchTime }) => {
            if (!video) {
                return (
                    <div className="w-full h-full bg-gray-800 rounded-lg flex items-center justify-center">
                        <div className="text-center text-gray-400">
                            <Icons.Bookmark />
                            <p className="mt-2">Select a video or add a new bookmark</p>
                        </div>
                    </div>
                );
            }

            const sourceType = video.sourceType || 'youtube';
            const sourceId = video.sourceId || video.videoId;
            const sourceUrl = video.sourceUrl;

            switch (sourceType) {
                case 'youtube':
                    return (
                        <YouTubePlayer
                            videoId={sourceId}
                            onTimeUpdate={onTimeUpdate}
                            playerRef={playerRef}
                            onWatchTime={onWatchTime}
                        />
                    );
                case 'vimeo':
                    return (
                        <VimeoPlayerAdapter
                            sourceId={sourceId}
                            onTimeUpdate={onTimeUpdate}
                            playerRef={playerRef}
                            onWatchTime={onWatchTime}
                        />
                    );
                case 'wistia':
                    return (
                        <WistiaPlayerAdapter
                            sourceId={sourceId}
                            onTimeUpdate={onTimeUpdate}
                            playerRef={playerRef}
                            onWatchTime={onWatchTime}
                        />
                    );
                case 'loom':
                    return (
                        <LoomPlayerAdapter
                            sourceId={sourceId}
                            onTimeUpdate={onTimeUpdate}
                            playerRef={playerRef}
                            onWatchTime={onWatchTime}
                        />
                    );
                case 'googledrive':
                    return (
                        <GoogleDrivePlayerAdapter
                            sourceId={sourceId}
                            onTimeUpdate={onTimeUpdate}
                            playerRef={playerRef}
                            onWatchTime={onWatchTime}
                        />
                    );
                case 'direct':
                    return (
                        <HTML5PlayerAdapter
                            sourceUrl={sourceUrl}
                            onTimeUpdate={onTimeUpdate}
                            playerRef={playerRef}
                            onWatchTime={onWatchTime}
                        />
                    );
                default:
                    return (
                        <div className="w-full h-full bg-gray-800 rounded-lg flex items-center justify-center">
                            <div className="text-center text-gray-400">
                                <Icons.AlertCircle />
                                <p className="mt-2">Unknown video source: {sourceType}</p>
                            </div>
                        </div>
                    );
            }
        };

        // Note Item Component
        const NoteItem = ({ note, onSeek, onDelete, onEdit, searchTerm }) => {
            const [isEditing, setIsEditing] = useState(false);
            const [editText, setEditText] = useState(note.text);
            const [showOriginal, setShowOriginal] = useState(false);

            const handleSave = () => {
                onEdit(note.id, editText);
                setIsEditing(false);
            };

            // Highlight search term in text
            const highlightText = (text, term) => {
                if (!term) return text;
                const regex = new RegExp(`(${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                const parts = text.split(regex);
                return parts.map((part, i) =>
                    regex.test(part) ? <mark key={i} className="bg-yellow-500 text-gray-900 px-0.5 rounded">{part}</mark> : part
                );
            };

            // Format note text to properly render bullet points
            const formatNoteText = (text, term) => {
                // Check if text contains bullet points (lines starting with "- ")
                const lines = text.split('\n');
                const hasBullets = lines.some(line => line.trim().startsWith('- '));

                if (hasBullets) {
                    return (
                        <ul className="list-none space-y-1">
                            {lines.map((line, idx) => {
                                const trimmedLine = line.trim();
                                if (trimmedLine.startsWith('- ')) {
                                    const bulletContent = trimmedLine.substring(2);
                                    return (
                                        <li key={idx} className="flex items-start gap-2">
                                            <span className="text-emerald-400 mt-0.5">•</span>
                                            <span>{highlightText(bulletContent, term)}</span>
                                        </li>
                                    );
                                } else if (trimmedLine) {
                                    return <li key={idx}>{highlightText(trimmedLine, term)}</li>;
                                }
                                return null;
                            }).filter(Boolean)}
                        </ul>
                    );
                }

                return highlightText(text, term);
            };

            return (
                <div className={`bg-gray-800 rounded-lg p-3 mb-2 hover:bg-gray-750 transition-colors ${searchTerm ? 'ring-1 ring-yellow-500/30' : ''}`}>
                    <div className="flex items-start justify-between gap-2">
                        <div className="flex items-center gap-2">
                            <button
                                onClick={() => onSeek(note.timestamp)}
                                className="flex items-center gap-1 text-emerald-400 hover:text-emerald-300 text-sm font-medium shrink-0"
                            >
                                <Icons.Play />
                                {formatTime(note.timestamp)}
                            </button>
                            {note.enhanced && (
                                <button
                                    onClick={() => setShowOriginal(!showOriginal)}
                                    className={`text-xs px-2 py-0.5 rounded-full transition-colors ${
                                        showOriginal
                                            ? 'bg-purple-500 text-white'
                                            : 'bg-purple-500/20 text-purple-400 hover:bg-purple-500/30'
                                    }`}
                                    title={showOriginal ? 'Show enhanced note' : 'Show original note'}
                                >
                                    {showOriginal ? 'Original' : 'Enhanced'}
                                </button>
                            )}
                            {note.author && (
                                <span
                                    className="text-xs px-2 py-0.5 rounded-full bg-gray-600 text-gray-300"
                                    title={`Added by ${note.authorFull || note.author}`}
                                >
                                    {note.author}
                                </span>
                            )}
                        </div>
                        <div className="flex gap-1">
                            <button
                                onClick={() => setIsEditing(true)}
                                className="p-1 hover:bg-gray-700 rounded text-gray-400 hover:text-gray-200"
                                title="Edit note"
                            >
                                <Icons.Edit />
                            </button>
                            <button
                                onClick={() => onDelete(note.id)}
                                className="p-1 hover:bg-gray-700 rounded text-gray-400 hover:text-emerald-400"
                                title="Delete note"
                            >
                                <Icons.Trash />
                            </button>
                        </div>
                    </div>
                    {isEditing ? (
                        <div className="mt-2">
                            <textarea
                                value={editText}
                                onChange={(e) => setEditText(e.target.value)}
                                className="w-full bg-gray-700 rounded p-2 text-sm text-gray-100 resize-none"
                                rows={3}
                                autoFocus
                            />
                            <div className="flex gap-2 mt-2">
                                <button
                                    onClick={handleSave}
                                    className="px-3 py-1 bg-emerald-500 hover:bg-emerald-600 rounded text-sm"
                                >
                                    Save
                                </button>
                                <button
                                    onClick={() => {
                                        setIsEditing(false);
                                        setEditText(note.text);
                                    }}
                                    className="px-3 py-1 bg-gray-600 hover:bg-gray-500 rounded text-sm"
                                >
                                    Cancel
                                </button>
                            </div>
                        </div>
                    ) : (
                        <div className="mt-2 text-sm text-gray-300">
                            {showOriginal && note.originalText ? (
                                <div>
                                    <div className="text-xs text-purple-400 mb-1">Original note:</div>
                                    <div className="bg-gray-700/50 p-2 rounded">{formatNoteText(note.originalText, searchTerm)}</div>
                                </div>
                            ) : (
                                formatNoteText(note.text, searchTerm)
                            )}
                        </div>
                    )}
                </div>
            );
        };

        // Get video thumbnail URL based on source type
        const getVideoThumbnail = (video) => {
            // Use stored thumbnail if available
            if (video.thumbnail) {
                return video.thumbnail;
            }

            const sourceType = video.sourceType || 'youtube';
            const sourceId = video.sourceId || video.videoId;

            switch (sourceType) {
                case 'youtube':
                    return `https://img.youtube.com/vi/${sourceId}/mqdefault.jpg`;
                case 'vimeo':
                    // Vimeo thumbnails require API call, use placeholder if not stored
                    return video.thumbnail || `https://vumbnail.com/${sourceId}.jpg`;
                case 'loom':
                    return `https://cdn.loom.com/sessions/thumbnails/${sourceId}-with-play.jpg`;
                case 'googledrive':
                    // Google Drive doesn't provide public thumbnails
                    return video.thumbnail || '';
                case 'wistia':
                    // Wistia thumbnails require API call, use placeholder if not stored
                    return video.thumbnail || '';
                case 'direct':
                    // No thumbnail for direct videos
                    return '';
                default:
                    return '';
            }
        };

        // Fallback thumbnail component for when no thumbnail is available
        const VideoThumbnailFallback = ({ sourceType, className = '' }) => (
            <div className={`bg-gray-700 flex items-center justify-center ${className}`}>
                <div className="text-gray-500 text-center">
                    {sourceType === 'direct' ? <Icons.VideoFile /> : <Icons.Play />}
                    <div className="text-xs mt-1">{getSourceDisplayName(sourceType || 'video')}</div>
                </div>
            </div>
        );

        // Video Card Component
        const VideoCard = ({ video, isActive, onClick, onDelete, onEdit, onShare, onFetchPublishDate, isFetchingDate, isShared }) => {
            const thumbnailUrl = getVideoThumbnail(video);
            const sourceType = video.sourceType || 'youtube';

            return (
            <div
                onClick={onClick}
                className={`cursor-pointer rounded-lg overflow-hidden transition-all ${
                    isActive ? 'ring-2 ring-emerald-500' : 'hover:ring-2 hover:ring-gray-600'
                }`}
            >
                <div className="relative group">
                    {thumbnailUrl ? (
                        <img
                            src={thumbnailUrl}
                            alt={video.title}
                            className="w-full aspect-video object-cover"
                            onError={(e) => {
                                e.target.style.display = 'none';
                                e.target.nextSibling?.classList.remove('hidden');
                            }}
                        />
                    ) : null}
                    {!thumbnailUrl && (
                        <VideoThumbnailFallback sourceType={sourceType} className="w-full aspect-video" />
                    )}
                    {thumbnailUrl && (
                        <div className="hidden w-full aspect-video">
                            <VideoThumbnailFallback sourceType={sourceType} className="w-full h-full" />
                        </div>
                    )}
                    {/* Source badge for non-YouTube videos */}
                    {sourceType !== 'youtube' && (
                        <div className="absolute top-2 left-2">
                            <VideoSourceBadge sourceType={sourceType} />
                        </div>
                    )}
                    <div className="absolute bottom-2 left-2 bg-black/80 px-2 py-0.5 rounded text-xs flex items-center gap-1">
                        <Icons.Eye />
                        <span>{video.viewCount || 0}</span>
                    </div>
                    <div className="absolute bottom-2 right-2 bg-black/80 px-2 py-0.5 rounded text-xs">
                        {video.notes?.length || 0} notes
                    </div>
                    {/* Action buttons */}
                    <div className="absolute top-2 right-2 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                        {onShare && !isShared && (
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onShare(video);
                                }}
                                className="bg-blue-500 hover:bg-blue-600 p-2 rounded-lg"
                                title="Share video"
                            >
                                <Icons.Share />
                            </button>
                        )}
                        {onEdit && (
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onEdit(video.id);
                                }}
                                className="bg-emerald-500 hover:bg-emerald-600 p-2 rounded-lg"
                                title="Edit video"
                            >
                                <Icons.Edit />
                            </button>
                        )}
                    </div>
                    {/* Shared badge */}
                    {isShared && (
                        <div className={`absolute ${sourceType !== 'youtube' ? 'top-10' : 'top-2'} left-2 bg-blue-500/90 px-2 py-0.5 rounded text-xs flex items-center gap-1`}>
                            <Icons.Users />
                            <span>Shared</span>
                        </div>
                    )}
                </div>
                <div className="p-3 bg-gray-800">
                    <h3 className="font-medium text-sm line-clamp-2">{video.title}</h3>
                    <div className="flex flex-wrap gap-1 mt-2">
                        {video.tags?.slice(0, 3).map(tag => (
                            <span key={tag} className="text-xs bg-gray-700 px-2 py-0.5 rounded-full text-gray-300">
                                {tag}
                            </span>
                        ))}
                    </div>
                    <div className="mt-2 text-xs">
                        {video.publishDate ? (
                            <div className="flex items-center gap-1 text-gray-400">
                                <Icons.Calendar />
                                <span>{formatPublishDate(video.publishDate)}</span>
                            </div>
                        ) : null}
                        {(!video.publishDate || !video.description) && (video.sourceType === 'youtube' || (!video.sourceType && video.videoId)) && (
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onFetchPublishDate(video.id, video.videoId);
                                }}
                                disabled={isFetchingDate}
                                className="flex items-center gap-1 text-blue-400 hover:text-blue-300 disabled:opacity-50"
                            >
                                <Icons.Calendar />
                                <span>{isFetchingDate ? 'Fetching...' : 'Get Details'}</span>
                            </button>
                        )}
                    </div>
                </div>
            </div>
        );
        };

        // Video List Item Component for list view
        const VideoListItem = ({ video, isActive, onClick, onDelete, onEdit, onShare, onFetchPublishDate, isFetchingDate, isShared }) => {
            const thumbnailUrl = getVideoThumbnail(video);
            const sourceType = video.sourceType || 'youtube';

            return (
            <div
                onClick={onClick}
                className={`cursor-pointer rounded-lg overflow-hidden transition-all bg-gray-800 hover:bg-gray-750 ${
                    isActive ? 'ring-2 ring-emerald-500' : 'hover:ring-1 hover:ring-gray-600'
                }`}
            >
                <div className="flex items-center gap-4 p-3">
                    {/* Thumbnail */}
                    <div className="relative shrink-0 w-40">
                        {thumbnailUrl ? (
                            <img
                                src={thumbnailUrl}
                                alt={video.title}
                                className="w-full aspect-video object-cover rounded"
                                onError={(e) => {
                                    e.target.style.display = 'none';
                                    e.target.nextSibling?.classList.remove('hidden');
                                }}
                            />
                        ) : null}
                        {!thumbnailUrl && (
                            <VideoThumbnailFallback sourceType={sourceType} className="w-full aspect-video rounded" />
                        )}
                        {thumbnailUrl && (
                            <div className="hidden w-full aspect-video">
                                <VideoThumbnailFallback sourceType={sourceType} className="w-full h-full rounded" />
                            </div>
                        )}
                        {/* Source badge for non-YouTube videos */}
                        {sourceType !== 'youtube' && (
                            <div className="absolute top-1 left-1">
                                <VideoSourceBadge sourceType={sourceType} className="text-[10px] px-1" />
                            </div>
                        )}
                        {isShared && (
                            <div className={`absolute ${sourceType !== 'youtube' ? 'top-7' : 'top-1'} left-1 bg-blue-500/90 px-1.5 py-0.5 rounded text-xs flex items-center gap-1`}>
                                <Icons.Users />
                            </div>
                        )}
                    </div>
                    {/* Content */}
                    <div className="flex-1 min-w-0">
                        <h3 className="font-medium text-sm line-clamp-2">{video.title}</h3>
                        <div className="flex flex-wrap gap-1 mt-1">
                            {video.tags?.slice(0, 3).map(tag => (
                                <span key={tag} className="text-xs bg-gray-700 px-2 py-0.5 rounded-full text-gray-300">
                                    {tag}
                                </span>
                            ))}
                        </div>
                        <div className="flex items-center gap-4 mt-2 text-xs text-gray-400">
                            {sourceType !== 'youtube' && (
                                <span className="text-gray-500">{getSourceDisplayName(sourceType)}</span>
                            )}
                            {video.publishDate && (
                                <div className="flex items-center gap-1">
                                    <Icons.Calendar />
                                    <span>{formatPublishDate(video.publishDate)}</span>
                                </div>
                            )}
                            {(!video.publishDate || !video.description) && (sourceType === 'youtube' || (!video.sourceType && video.videoId)) && (
                                <button
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        onFetchPublishDate(video.id, video.videoId);
                                    }}
                                    disabled={isFetchingDate}
                                    className="flex items-center gap-1 text-blue-400 hover:text-blue-300 disabled:opacity-50"
                                >
                                    <Icons.Calendar />
                                    <span>{isFetchingDate ? 'Fetching...' : 'Get Details'}</span>
                                </button>
                            )}
                            <div className="flex items-center gap-1">
                                <Icons.Eye />
                                <span>{video.viewCount || 0} views</span>
                            </div>
                            <div className="flex items-center gap-1">
                                <span>{video.notes?.length || 0} notes</span>
                            </div>
                        </div>
                    </div>
                    {/* Actions */}
                    <div className="flex items-center gap-2 shrink-0">
                        {onShare && !isShared && (
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onShare(video);
                                }}
                                className="bg-blue-500 hover:bg-blue-600 p-2 rounded-lg"
                                title="Share video"
                            >
                                <Icons.Share />
                            </button>
                        )}
                        {onEdit && (
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onEdit(video.id);
                                }}
                                className="bg-emerald-500 hover:bg-emerald-600 p-2 rounded-lg"
                                title="Edit video"
                            >
                                <Icons.Edit />
                            </button>
                        )}
                    </div>
                </div>
            </div>
        );
        };

        // Auto-tagging keywords map
        const TAG_KEYWORDS = {
            'tutorial': ['tutorial', 'how to', 'learn', 'guide', 'step by step', 'beginner', 'course', 'lesson'],
            'coding': ['code', 'coding', 'programming', 'developer', 'software', 'engineer'],
            'javascript': ['javascript', 'js', 'node', 'react', 'vue', 'angular', 'typescript'],
            'python': ['python', 'django', 'flask', 'pandas', 'numpy'],
            'web development': ['web dev', 'frontend', 'backend', 'fullstack', 'html', 'css'],
            'gaming': ['game', 'gaming', 'playthrough', 'walkthrough', 'gameplay', 'lets play'],
            'music': ['music', 'song', 'album', 'concert', 'live performance', 'cover', 'remix'],
            'podcast': ['podcast', 'interview', 'conversation', 'talk', 'discussion'],
            'review': ['review', 'unboxing', 'first look', 'hands on', 'comparison'],
            'vlog': ['vlog', 'day in the life', 'daily', 'routine'],
            'education': ['explained', 'education', 'documentary', 'history', 'science', 'physics', 'math'],
            'fitness': ['workout', 'fitness', 'exercise', 'gym', 'yoga', 'training'],
            'cooking': ['recipe', 'cooking', 'food', 'chef', 'kitchen', 'baking'],
            'tech': ['tech', 'technology', 'gadget', 'iphone', 'android', 'apple', 'google'],
            'ai': ['ai', 'artificial intelligence', 'machine learning', 'chatgpt', 'openai', 'llm', 'neural'],
            'design': ['design', 'figma', 'ui', 'ux', 'graphic', 'photoshop', 'illustrator'],
            'business': ['business', 'startup', 'entrepreneur', 'marketing', 'finance', 'investing'],
            'motivation': ['motivation', 'inspiration', 'success', 'mindset', 'productivity']
        };

        // Category keywords for auto-categorization
        const CATEGORY_KEYWORDS = {
            'Technology': ['tech', 'coding', 'programming', 'software', 'developer', 'javascript', 'python', 'react', 'ai', 'machine learning'],
            'Education': ['tutorial', 'learn', 'course', 'lesson', 'explained', 'education', 'how to', 'guide'],
            'Entertainment': ['gaming', 'music', 'vlog', 'comedy', 'entertainment', 'funny', 'movie', 'film'],
            'Lifestyle': ['fitness', 'cooking', 'recipe', 'vlog', 'routine', 'travel', 'fashion'],
            'Business': ['business', 'startup', 'marketing', 'finance', 'investing', 'entrepreneur'],
            'Creative': ['design', 'art', 'music', 'photography', 'video editing', 'creative']
        };

        // Function to extract tags from title
        const extractTagsFromTitle = (title) => {
            const titleLower = title.toLowerCase();
            const foundTags = new Set();

            for (const [tag, keywords] of Object.entries(TAG_KEYWORDS)) {
                for (const keyword of keywords) {
                    if (titleLower.includes(keyword.toLowerCase())) {
                        foundTags.add(tag);
                        break;
                    }
                }
            }

            return Array.from(foundTags).slice(0, 5); // Limit to 5 tags
        };

        // Function to suggest category based on title
        const suggestCategory = (title, categories) => {
            const titleLower = title.toLowerCase();
            let bestMatch = { id: '', score: 0 };

            for (const cat of categories) {
                const catNameLower = cat.name.toLowerCase();
                let score = 0;

                // Check if category name matches any category keywords
                for (const [catType, keywords] of Object.entries(CATEGORY_KEYWORDS)) {
                    if (catNameLower.includes(catType.toLowerCase()) || catType.toLowerCase().includes(catNameLower)) {
                        for (const keyword of keywords) {
                            if (titleLower.includes(keyword)) {
                                score += 1;
                            }
                        }
                    }
                }

                // Direct match with category name
                if (titleLower.includes(catNameLower)) {
                    score += 3;
                }

                if (score > bestMatch.score) {
                    bestMatch = { id: cat.id, score };
                }
            }

            return bestMatch.score > 0 ? bestMatch.id : '';
        };

        // Add Video Modal
        const AddVideoModal = ({ isOpen, onClose, onAdd, categories, onAddCategory }) => {
            const [url, setUrl] = useState('');
            const [title, setTitle] = useState('');
            const [selectedCategory, setSelectedCategory] = useState('');
            const [tags, setTags] = useState('');
            const [publishDate, setPublishDate] = useState('');
            const [error, setError] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [autoFetched, setAutoFetched] = useState(false);
            const [isCreatingNewCategory, setIsCreatingNewCategory] = useState(false);
            const [newCategoryName, setNewCategoryName] = useState('');
            const [categoryError, setCategoryError] = useState('');
            const [detectedSource, setDetectedSource] = useState(null); // { sourceType, sourceId, sourceUrl }
            const [thumbnail, setThumbnail] = useState(''); // For non-YouTube sources

            // Fetch video metadata based on source type
            const fetchVideoMetadata = async (parsedSource) => {
                if (!parsedSource) return;

                setIsLoading(true);
                setError('');

                try {
                    if (parsedSource.sourceType === 'youtube') {
                        // Use YouTube oEmbed API (no API key required)
                        const response = await fetch(
                            `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${parsedSource.sourceId}&format=json`
                        );

                        if (!response.ok) {
                            throw new Error('Could not fetch video info');
                        }

                        const data = await response.json();
                        const videoTitle = data.title || '';

                        setTitle(videoTitle);
                        setThumbnail(`https://img.youtube.com/vi/${parsedSource.sourceId}/mqdefault.jpg`);

                        // Auto-generate tags from title
                        const autoTags = extractTagsFromTitle(videoTitle);
                        setTags(autoTags.join(', '));

                        // Auto-suggest category
                        const suggestedCategory = suggestCategory(videoTitle, categories);
                        if (suggestedCategory) {
                            setSelectedCategory(suggestedCategory);
                        }

                        // Try to fetch publish date from noembed
                        try {
                            const noembedResponse = await fetch(
                                `https://noembed.com/embed?url=https://www.youtube.com/watch?v=${parsedSource.sourceId}`
                            );
                            const noembedData = await noembedResponse.json();
                            if (noembedData.upload_date) {
                                setPublishDate(noembedData.upload_date);
                            }
                        } catch (e) {
                            console.log('Could not fetch publish date');
                        }

                        setAutoFetched(true);
                    } else if (parsedSource.sourceType === 'vimeo') {
                        // Use Vimeo oEmbed API
                        const response = await fetch(
                            `https://vimeo.com/api/oembed.json?url=https://vimeo.com/${parsedSource.sourceId}`
                        );

                        if (response.ok) {
                            const data = await response.json();
                            setTitle(data.title || '');
                            setThumbnail(data.thumbnail_url || '');

                            const autoTags = extractTagsFromTitle(data.title || '');
                            setTags(autoTags.join(', '));

                            const suggestedCategory = suggestCategory(data.title || '', categories);
                            if (suggestedCategory) {
                                setSelectedCategory(suggestedCategory);
                            }

                            setAutoFetched(true);
                        }
                    } else if (parsedSource.sourceType === 'wistia') {
                        // Use Wistia oEmbed API
                        const response = await fetch(
                            `https://fast.wistia.com/oembed?url=https://fast.wistia.net/embed/iframe/${parsedSource.sourceId}`
                        );

                        if (response.ok) {
                            const data = await response.json();
                            setTitle(data.title || '');
                            setThumbnail(data.thumbnail_url || '');

                            const autoTags = extractTagsFromTitle(data.title || '');
                            setTags(autoTags.join(', '));

                            setAutoFetched(true);
                        }
                    } else if (parsedSource.sourceType === 'loom') {
                        // Loom doesn't have a public oEmbed API, set title from URL
                        setTitle(`Loom Video ${parsedSource.sourceId}`);
                        setThumbnail(`https://cdn.loom.com/sessions/thumbnails/${parsedSource.sourceId}-with-play.jpg`);
                    } else if (parsedSource.sourceType === 'direct') {
                        // For direct videos, extract filename from URL
                        const urlParts = parsedSource.sourceUrl.split('/');
                        const filename = urlParts[urlParts.length - 1].split('?')[0];
                        setTitle(filename || 'Direct Video');
                    }
                } catch (err) {
                    console.log('Could not auto-fetch metadata:', err);
                    // Don't show error - just leave fields empty for manual entry
                } finally {
                    setIsLoading(false);
                }
            };

            // Handle URL input change with debounce
            const handleUrlChange = (e) => {
                const newUrl = e.target.value;
                setUrl(newUrl);
                setError('');
                setAutoFetched(false);
                setThumbnail('');

                // Parse the URL to detect source type
                const parsed = parseVideoUrl(newUrl);
                setDetectedSource(parsed);

                // Fetch metadata if valid source detected
                if (parsed && newUrl.length > 10) {
                    fetchVideoMetadata(parsed);
                }
            };

            const handleSubmit = (e) => {
                e.preventDefault();

                // Use new parseVideoUrl for validation
                const parsed = parseVideoUrl(url);
                if (!parsed) {
                    setError('Invalid video URL. Supported: YouTube, Vimeo, Loom, Wistia, or direct video links (.mp4, .webm)');
                    return;
                }

                let categoryIdToUse = selectedCategory;

                // If creating a new category, validate and create it first
                if (isCreatingNewCategory) {
                    const trimmedName = newCategoryName.trim();
                    if (!trimmedName) {
                        setCategoryError('Category name cannot be empty');
                        return;
                    }

                    // Check for duplicate category names (case-insensitive)
                    if (categories.some(c => c.name.toLowerCase() === trimmedName.toLowerCase())) {
                        setCategoryError('A category with this name already exists');
                        return;
                    }

                    // Create new category
                    const newCategory = {
                        id: generateId(),
                        name: trimmedName
                    };
                    onAddCategory(newCategory);
                    categoryIdToUse = newCategory.id;
                }

                // Create video with new multi-source format
                onAdd({
                    id: generateId(),
                    sourceType: parsed.sourceType,
                    sourceId: parsed.sourceId,
                    sourceUrl: parsed.sourceUrl,
                    // Keep videoId for backward compatibility with YouTube
                    videoId: parsed.sourceType === 'youtube' ? parsed.sourceId : undefined,
                    title: title || `${getSourceDisplayName(parsed.sourceType)} Video`,
                    thumbnail: thumbnail || null,
                    category: categoryIdToUse,
                    tags: tags.split(',').map(t => t.trim()).filter(Boolean),
                    notes: [],
                    publishDate: publishDate || null,
                    createdAt: new Date().toISOString(),
                    viewCount: 0
                });
                setUrl('');
                setTitle('');
                setSelectedCategory('');
                setTags('');
                setPublishDate('');
                setError('');
                setAutoFetched(false);
                setIsCreatingNewCategory(false);
                setNewCategoryName('');
                setCategoryError('');
                setDetectedSource(null);
                setThumbnail('');
                onClose();
            };

            // Reset state when modal closes
            useEffect(() => {
                if (!isOpen) {
                    setUrl('');
                    setTitle('');
                    setSelectedCategory('');
                    setTags('');
                    setPublishDate('');
                    setError('');
                    setIsLoading(false);
                    setAutoFetched(false);
                    setIsCreatingNewCategory(false);
                    setNewCategoryName('');
                    setCategoryError('');
                    setDetectedSource(null);
                    setThumbnail('');
                }
            }, [isOpen]);

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-md p-6">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold">Add New Video</h2>
                            <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div>
                                <label className="block text-sm text-gray-400 mb-1">Video URL *</label>
                                <div className="relative">
                                    <input
                                        type="text"
                                        value={url}
                                        onChange={handleUrlChange}
                                        placeholder="YouTube, Vimeo, Loom, Wistia, or direct video URL"
                                        className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                        required
                                    />
                                    {isLoading && (
                                        <div className="absolute right-3 top-1/2 -translate-y-1/2">
                                            <svg className="animate-spin h-5 w-5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                            </svg>
                                        </div>
                                    )}
                                </div>
                                {/* Source detection badge */}
                                {detectedSource && !error && (
                                    <div className="flex items-center gap-2 mt-2">
                                        <VideoSourceBadge sourceType={detectedSource.sourceType} />
                                        {detectedSource.sourceType === 'loom' && (
                                            <span className="text-yellow-400 text-xs flex items-center gap-1">
                                                <Icons.AlertCircle />
                                                Limited playback control
                                            </span>
                                        )}
                                    </div>
                                )}
                                {error && <p className="text-red-400 text-sm mt-1">{error}</p>}
                                {autoFetched && !isLoading && (
                                    <p className="text-green-400 text-sm mt-1 flex items-center gap-1">
                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                                        </svg>
                                        Auto-filled from video
                                    </p>
                                )}
                            </div>
                            <div>
                                <label className="block text-sm text-gray-400 mb-1">
                                    Title {autoFetched && <span className="text-green-400 text-xs">(auto-filled)</span>}
                                </label>
                                <input
                                    type="text"
                                    value={title}
                                    onChange={(e) => setTitle(e.target.value)}
                                    placeholder="Video title (optional)"
                                    className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                />
                            </div>
                            <div>
                                <label className="block text-sm text-gray-400 mb-1">
                                    Category {selectedCategory && autoFetched && <span className="text-green-400 text-xs">(auto-suggested)</span>}
                                </label>
                                <div className="flex gap-2 mb-2">
                                    <button
                                        type="button"
                                        onClick={() => {
                                            setIsCreatingNewCategory(false);
                                            setNewCategoryName('');
                                            setCategoryError('');
                                        }}
                                        className={`flex-1 px-3 py-1 rounded-lg text-sm font-medium transition-colors ${
                                            !isCreatingNewCategory
                                                ? 'bg-emerald-500 text-white'
                                                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                        }`}
                                    >
                                        Select
                                    </button>
                                    <button
                                        type="button"
                                        onClick={() => {
                                            setIsCreatingNewCategory(true);
                                            setSelectedCategory('');
                                            setCategoryError('');
                                        }}
                                        className={`flex-1 px-3 py-1 rounded-lg text-sm font-medium transition-colors ${
                                            isCreatingNewCategory
                                                ? 'bg-emerald-500 text-white'
                                                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                        }`}
                                    >
                                        Create New
                                    </button>
                                </div>
                                {isCreatingNewCategory ? (
                                    <div>
                                        <input
                                            type="text"
                                            value={newCategoryName}
                                            onChange={(e) => {
                                                setNewCategoryName(e.target.value);
                                                setCategoryError('');
                                            }}
                                            placeholder="New category name"
                                            className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                        />
                                        {categoryError && <p className="text-emerald-400 text-sm mt-1">{categoryError}</p>}
                                    </div>
                                ) : (
                                    <select
                                        value={selectedCategory}
                                        onChange={(e) => setSelectedCategory(e.target.value)}
                                        className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                    >
                                        <option value="">No category</option>
                                        {categories.map(cat => (
                                            <option key={cat.id} value={cat.id}>{cat.name}</option>
                                        ))}
                                    </select>
                                )}
                            </div>
                            <div>
                                <label className="block text-sm text-gray-400 mb-1">
                                    Tags {tags && autoFetched && <span className="text-green-400 text-xs">(auto-generated)</span>}
                                </label>
                                <input
                                    type="text"
                                    value={tags}
                                    onChange={(e) => setTags(e.target.value)}
                                    placeholder="tutorial, react, coding (comma separated)"
                                    className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                />
                            </div>
                            <button
                                type="submit"
                                disabled={isLoading}
                                className="w-full bg-emerald-500 hover:bg-emerald-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-medium py-2 rounded-lg transition-colors"
                            >
                                {isLoading ? 'Loading...' : 'Add Video'}
                            </button>
                        </form>
                    </div>
                </div>
            );
        };

        // Edit Video Modal
        const EditVideoModal = ({ isOpen, onClose, video, onSave, categories, onAddCategory }) => {
            const [title, setTitle] = useState('');
            const [selectedCategory, setSelectedCategory] = useState('');
            const [tags, setTags] = useState('');
            const [error, setError] = useState('');
            const [isCreatingNewCategory, setIsCreatingNewCategory] = useState(false);
            const [newCategoryName, setNewCategoryName] = useState('');
            const [categoryError, setCategoryError] = useState('');

            // Initialize state when modal opens
            useEffect(() => {
                if (isOpen && video) {
                    setTitle(video.title || '');
                    setSelectedCategory(video.category || '');
                    setTags(video.tags?.join(', ') || '');
                    setError('');
                    setIsCreatingNewCategory(false);
                    setNewCategoryName('');
                    setCategoryError('');
                }
            }, [isOpen, video]);

            const handleSubmit = (e) => {
                e.preventDefault();
                if (!title.trim()) {
                    setError('Title cannot be empty');
                    return;
                }

                let categoryIdToUse = selectedCategory;

                // If creating a new category, validate and create it first
                if (isCreatingNewCategory) {
                    const trimmedName = newCategoryName.trim();
                    if (!trimmedName) {
                        setCategoryError('Category name cannot be empty');
                        return;
                    }

                    // Check for duplicate category names (case-insensitive)
                    if (categories.some(c => c.name.toLowerCase() === trimmedName.toLowerCase())) {
                        setCategoryError('A category with this name already exists');
                        return;
                    }

                    // Create new category
                    const newCategory = {
                        id: generateId(),
                        name: trimmedName
                    };
                    onAddCategory(newCategory);
                    categoryIdToUse = newCategory.id;
                }

                onSave({
                    title: title.trim(),
                    category: categoryIdToUse,
                    tags: tags.split(',').map(t => t.trim()).filter(Boolean)
                });
                onClose();
            };

            if (!isOpen || !video) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-md p-6">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold">Edit Video</h2>
                            <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div>
                                <label className="block text-sm text-gray-400 mb-1">Title *</label>
                                <input
                                    type="text"
                                    value={title}
                                    onChange={(e) => {
                                        setTitle(e.target.value);
                                        setError('');
                                    }}
                                    placeholder="Video title"
                                    className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                />
                                {error && <p className="text-emerald-400 text-sm mt-1">{error}</p>}
                            </div>
                            <div>
                                <label className="block text-sm text-gray-400 mb-1">Category</label>
                                <div className="flex gap-2 mb-2">
                                    <button
                                        type="button"
                                        onClick={() => {
                                            setIsCreatingNewCategory(false);
                                            setNewCategoryName('');
                                            setCategoryError('');
                                        }}
                                        className={`flex-1 px-3 py-1 rounded-lg text-sm font-medium transition-colors ${
                                            !isCreatingNewCategory
                                                ? 'bg-emerald-500 text-white'
                                                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                        }`}
                                    >
                                        Select
                                    </button>
                                    <button
                                        type="button"
                                        onClick={() => {
                                            setIsCreatingNewCategory(true);
                                            setSelectedCategory('');
                                            setCategoryError('');
                                        }}
                                        className={`flex-1 px-3 py-1 rounded-lg text-sm font-medium transition-colors ${
                                            isCreatingNewCategory
                                                ? 'bg-emerald-500 text-white'
                                                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                        }`}
                                    >
                                        Create New
                                    </button>
                                </div>
                                {isCreatingNewCategory ? (
                                    <div>
                                        <input
                                            type="text"
                                            value={newCategoryName}
                                            onChange={(e) => {
                                                setNewCategoryName(e.target.value);
                                                setCategoryError('');
                                            }}
                                            placeholder="New category name"
                                            className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                        />
                                        {categoryError && <p className="text-emerald-400 text-sm mt-1">{categoryError}</p>}
                                    </div>
                                ) : (
                                    <select
                                        value={selectedCategory}
                                        onChange={(e) => setSelectedCategory(e.target.value)}
                                        className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                    >
                                        <option value="">No category</option>
                                        {categories.map(cat => (
                                            <option key={cat.id} value={cat.id}>{cat.name}</option>
                                        ))}
                                    </select>
                                )}
                            </div>
                            <div>
                                <label className="block text-sm text-gray-400 mb-1">Tags</label>
                                <input
                                    type="text"
                                    value={tags}
                                    onChange={(e) => setTags(e.target.value)}
                                    placeholder="tutorial, react, coding (comma separated)"
                                    className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                />
                            </div>
                            <button
                                type="submit"
                                className="w-full bg-emerald-500 hover:bg-emerald-600 text-white font-medium py-2 rounded-lg transition-colors"
                            >
                                Save Changes
                            </button>
                        </form>
                    </div>
                </div>
            );
        };

        // Category Manager Modal
        const CategoryModal = ({ isOpen, onClose, categories, onAdd, onDelete, onEdit }) => {
            const [newCat, setNewCat] = useState('');
            const [editingId, setEditingId] = useState(null);
            const [editingName, setEditingName] = useState('');

            const handleAdd = (e) => {
                e.preventDefault();
                if (newCat.trim()) {
                    onAdd({ id: generateId(), name: newCat.trim() });
                    setNewCat('');
                }
            };

            const handleEditStart = (catId, catName) => {
                setEditingId(catId);
                setEditingName(catName);
            };

            const handleEditSave = () => {
                if (editingName.trim() && onEdit) {
                    onEdit(editingId, editingName.trim());
                    setEditingId(null);
                    setEditingName('');
                }
            };

            const handleEditCancel = () => {
                setEditingId(null);
                setEditingName('');
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-md p-6">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold">Manage Categories</h2>
                            <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>
                        <form onSubmit={handleAdd} className="flex gap-2 mb-4">
                            <input
                                type="text"
                                value={newCat}
                                onChange={(e) => setNewCat(e.target.value)}
                                placeholder="New category name"
                                className="flex-1 bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                            />
                            <button
                                type="submit"
                                className="px-4 py-2 bg-emerald-500 hover:bg-emerald-600 rounded-lg"
                            >
                                Add
                            </button>
                        </form>
                        <div className="space-y-2 max-h-60 overflow-y-auto">
                            {categories.map(cat => (
                                <div key={cat.id} className="flex items-center justify-between bg-gray-700 rounded-lg px-4 py-2">
                                    {editingId === cat.id ? (
                                        <div className="flex-1 flex gap-2 items-center">
                                            <input
                                                type="text"
                                                value={editingName}
                                                onChange={(e) => setEditingName(e.target.value)}
                                                autoFocus
                                                className="flex-1 bg-gray-600 rounded px-2 py-1 text-gray-100 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                            />
                                            <button
                                                onClick={handleEditSave}
                                                className="px-2 py-1 bg-green-600 hover:bg-green-700 rounded text-xs text-white"
                                            >
                                                Save
                                            </button>
                                            <button
                                                onClick={handleEditCancel}
                                                className="px-2 py-1 bg-gray-600 hover:bg-gray-500 rounded text-xs text-gray-300"
                                            >
                                                Cancel
                                            </button>
                                        </div>
                                    ) : (
                                        <>
                                            <span
                                                onClick={() => handleEditStart(cat.id, cat.name)}
                                                className="flex-1 cursor-pointer hover:text-emerald-400 transition-colors"
                                                title="Click to edit"
                                            >
                                                {cat.name}
                                            </span>
                                            <button
                                                onClick={() => onDelete(cat.id)}
                                                className="p-1 hover:bg-gray-600 rounded text-gray-400 hover:text-emerald-400"
                                            >
                                                <Icons.Trash />
                                            </button>
                                        </>
                                    )}
                                </div>
                            ))}
                            {categories.length === 0 && (
                                <p className="text-gray-400 text-center py-4">No categories yet</p>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // Settings Modal
        const SettingsModal = ({ isOpen, onClose, apiStatus, contextWordCount, onSaveContextWordCount, onOpenProfile, onExport, onImport }) => {
            const [contextWords, setContextWords] = useState(contextWordCount);

            useEffect(() => {
                setContextWords(contextWordCount);
            }, [contextWordCount, isOpen]);

            const handleSave = () => {
                onSaveContextWordCount(contextWords);
                onClose();
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-md p-6 max-h-[90vh] overflow-y-auto">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold">Settings</h2>
                            <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>
                        <div className="space-y-4">
                            {/* Edit Profile Button */}
                            <button
                                onClick={() => {
                                    onClose();
                                    onOpenProfile();
                                }}
                                className="w-full flex items-center gap-3 bg-gray-700/50 hover:bg-gray-700 rounded-lg px-4 py-3 transition-colors"
                            >
                                <svg className="w-5 h-5 text-emerald-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                                </svg>
                                <div className="text-left">
                                    <p className="text-gray-200 font-medium">Edit Profile</p>
                                    <p className="text-xs text-gray-500">Update your name, email, and interests</p>
                                </div>
                                <svg className="w-5 h-5 text-gray-500 ml-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                                </svg>
                            </button>

                            {/* API Status */}
                            <div>
                                <label className="block text-sm text-gray-400 mb-2">Server API Status</label>
                                <div className="space-y-2">
                                    <div className="flex items-center justify-between bg-gray-700/50 rounded-lg px-4 py-3">
                                        <div className="flex items-center gap-2">
                                            <span className="text-gray-300">Gemini AI</span>
                                            <span className="text-xs text-gray-500">(Note enhancement)</span>
                                        </div>
                                        {apiStatus.geminiConfigured ? (
                                            <span className="flex items-center gap-1 text-green-400 text-sm">
                                                <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                                                </svg>
                                                Configured
                                            </span>
                                        ) : (
                                            <span className="flex items-center gap-1 text-gray-500 text-sm">
                                                <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                                                </svg>
                                                Not configured
                                            </span>
                                        )}
                                    </div>
                                    <div className="flex items-center justify-between bg-gray-700/50 rounded-lg px-4 py-3">
                                        <div className="flex items-center gap-2">
                                            <span className="text-gray-300">YouTube Data</span>
                                            <span className="text-xs text-gray-500">(Publish dates)</span>
                                        </div>
                                        {apiStatus.youtubeConfigured ? (
                                            <span className="flex items-center gap-1 text-green-400 text-sm">
                                                <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                                                </svg>
                                                Configured
                                            </span>
                                        ) : (
                                            <span className="flex items-center gap-1 text-gray-500 text-sm">
                                                <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                                                </svg>
                                                Not configured
                                            </span>
                                        )}
                                    </div>
                                </div>
                            </div>

                            {/* Context Word Count Setting */}
                            <div>
                                <label className="block text-sm text-gray-400 mb-1">
                                    Transcript Context Word Count
                                </label>
                                <p className="text-xs text-gray-500 mb-2">
                                    Number of words before and after the timestamp when loading context
                                </p>
                                <input
                                    type="number"
                                    min="5"
                                    max="100"
                                    value={contextWords}
                                    onChange={(e) => setContextWords(parseInt(e.target.value, 10) || 10)}
                                    className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                />
                                <p className="text-xs text-gray-500 mt-1">
                                    Default: 10 words. Will load ±{contextWords} words around timestamp.
                                </p>
                            </div>

                            {/* Backup & Restore */}
                            <div>
                                <label className="block text-sm text-gray-400 mb-2">Backup & Restore</label>
                                <div className="flex gap-2">
                                    <button
                                        onClick={() => { onClose(); onExport(); }}
                                        className="flex-1 flex items-center justify-center gap-2 bg-gray-700/50 hover:bg-gray-700 rounded-lg px-4 py-3 transition-colors"
                                    >
                                        <Icons.Download />
                                        <span className="text-gray-200 font-medium">Export Backup</span>
                                    </button>
                                    <button
                                        onClick={() => { onClose(); onImport(); }}
                                        className="flex-1 flex items-center justify-center gap-2 bg-gray-700/50 hover:bg-gray-700 rounded-lg px-4 py-3 transition-colors"
                                    >
                                        <Icons.Upload />
                                        <span className="text-gray-200 font-medium">Import Backup</span>
                                    </button>
                                </div>
                            </div>

                            <div className="bg-gray-700/50 rounded-lg p-3 text-sm text-gray-400">
                                <p className="font-medium text-gray-300 mb-1">🔒 Privacy & Security</p>
                                <p>API keys are stored securely on the server. Your data is processed through server-side proxies to protect credentials.</p>
                            </div>
                            <button
                                onClick={handleSave}
                                className="w-full bg-emerald-500 hover:bg-emerald-600 text-white font-medium py-2 rounded-lg transition-colors"
                            >
                                Save Settings
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // YouTube interest categories for profile
        const YOUTUBE_CATEGORIES = [
            'Music',
            'Education',
            'Gaming',
            'Entertainment',
            'Science & Technology',
            'Howto & Style',
            'Sports',
            'News & Politics',
            'Comedy',
            'Film & Animation'
        ];

        // Profile Modal Component
        const ProfileModal = ({ isOpen, onClose, serverUrl, authToken, currentUser }) => {
            const [profile, setProfile] = useState({
                firstName: '',
                lastName: '',
                email: '',
                interests: []
            });
            const [customInterest, setCustomInterest] = useState('');
            const [isLoading, setIsLoading] = useState(true);
            const [isSaving, setIsSaving] = useState(false);
            const [error, setError] = useState('');
            const [success, setSuccess] = useState('');

            // Load profile data when modal opens
            useEffect(() => {
                if (isOpen && authToken) {
                    loadProfile();
                }
            }, [isOpen, authToken]);

            const loadProfile = async () => {
                setIsLoading(true);
                setError('');
                try {
                    const response = await fetch(`${serverUrl}/api/profile`, {
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        setProfile({
                            firstName: data.profile?.firstName || '',
                            lastName: data.profile?.lastName || '',
                            email: data.profile?.email || '',
                            interests: data.profile?.interests || []
                        });
                    } else {
                        const errorData = await response.json();
                        setError(errorData.error || 'Failed to load profile');
                    }
                } catch (e) {
                    setError('Could not connect to server');
                } finally {
                    setIsLoading(false);
                }
            };

            const handleSave = async () => {
                setIsSaving(true);
                setError('');
                setSuccess('');

                try {
                    const response = await fetch(`${serverUrl}/api/profile`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify({
                            firstName: profile.firstName || null,
                            lastName: profile.lastName || null,
                            email: profile.email || null,
                            interests: profile.interests
                        })
                    });

                    if (response.ok) {
                        setSuccess('Profile saved successfully!');
                        setTimeout(() => setSuccess(''), 3000);
                    } else {
                        const errorData = await response.json();
                        setError(errorData.error || 'Failed to save profile');
                    }
                } catch (e) {
                    setError('Could not connect to server');
                } finally {
                    setIsSaving(false);
                }
            };

            const toggleInterest = (interest) => {
                setProfile(prev => ({
                    ...prev,
                    interests: prev.interests.includes(interest)
                        ? prev.interests.filter(i => i !== interest)
                        : [...prev.interests, interest]
                }));
            };

            const addCustomInterest = () => {
                if (customInterest.trim() && !profile.interests.includes(customInterest.trim())) {
                    setProfile(prev => ({
                        ...prev,
                        interests: [...prev.interests, customInterest.trim()]
                    }));
                    setCustomInterest('');
                }
            };

            const removeInterest = (interest) => {
                setProfile(prev => ({
                    ...prev,
                    interests: prev.interests.filter(i => i !== interest)
                }));
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-md p-6 max-h-[90vh] overflow-y-auto">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold">Edit Profile</h2>
                            <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>

                        {isLoading ? (
                            <div className="flex items-center justify-center py-8">
                                <svg className="animate-spin h-8 w-8 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                            </div>
                        ) : (
                            <div className="space-y-4">
                                {/* Username (read-only) */}
                                <div>
                                    <label className="block text-sm text-gray-400 mb-1">Username</label>
                                    <div className="bg-gray-700/50 rounded-lg px-4 py-2 text-gray-300">
                                        {currentUser?.username}
                                    </div>
                                </div>

                                {/* First Name */}
                                <div>
                                    <label className="block text-sm text-gray-400 mb-1">First Name</label>
                                    <input
                                        type="text"
                                        value={profile.firstName}
                                        onChange={(e) => setProfile(prev => ({ ...prev, firstName: e.target.value }))}
                                        placeholder="Enter your first name"
                                        className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                    />
                                </div>

                                {/* Last Name */}
                                <div>
                                    <label className="block text-sm text-gray-400 mb-1">Last Name</label>
                                    <input
                                        type="text"
                                        value={profile.lastName}
                                        onChange={(e) => setProfile(prev => ({ ...prev, lastName: e.target.value }))}
                                        placeholder="Enter your last name"
                                        className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                    />
                                </div>

                                {/* Email */}
                                <div>
                                    <label className="block text-sm text-gray-400 mb-1">Email</label>
                                    <input
                                        type="email"
                                        value={profile.email}
                                        onChange={(e) => setProfile(prev => ({ ...prev, email: e.target.value }))}
                                        placeholder="Enter your email"
                                        className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                    />
                                </div>

                                {/* Interests */}
                                <div>
                                    <label className="block text-sm text-gray-400 mb-2">Interests</label>
                                    <div className="flex flex-wrap gap-2 mb-3">
                                        {YOUTUBE_CATEGORIES.map(category => (
                                            <button
                                                key={category}
                                                onClick={() => toggleInterest(category)}
                                                className={`px-3 py-1 rounded-full text-sm transition-colors ${
                                                    profile.interests.includes(category)
                                                        ? 'bg-emerald-500 text-white'
                                                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                                }`}
                                            >
                                                {category}
                                            </button>
                                        ))}
                                    </div>

                                    {/* Custom interests */}
                                    {profile.interests.filter(i => !YOUTUBE_CATEGORIES.includes(i)).length > 0 && (
                                        <div className="flex flex-wrap gap-2 mb-3">
                                            {profile.interests.filter(i => !YOUTUBE_CATEGORIES.includes(i)).map(interest => (
                                                <span
                                                    key={interest}
                                                    className="flex items-center gap-1 px-3 py-1 bg-purple-500/20 text-purple-300 rounded-full text-sm"
                                                >
                                                    {interest}
                                                    <button
                                                        onClick={() => removeInterest(interest)}
                                                        className="ml-1 hover:text-red-400"
                                                    >
                                                        <Icons.X />
                                                    </button>
                                                </span>
                                            ))}
                                        </div>
                                    )}

                                    {/* Add custom interest */}
                                    <div className="flex gap-2">
                                        <input
                                            type="text"
                                            value={customInterest}
                                            onChange={(e) => setCustomInterest(e.target.value)}
                                            onKeyDown={(e) => e.key === 'Enter' && addCustomInterest()}
                                            placeholder="Add custom interest..."
                                            className="flex-1 bg-gray-700 rounded-lg px-3 py-1.5 text-sm text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                        />
                                        <button
                                            onClick={addCustomInterest}
                                            disabled={!customInterest.trim()}
                                            className="px-3 py-1.5 bg-gray-600 hover:bg-gray-500 disabled:bg-gray-700 disabled:opacity-50 rounded-lg text-sm transition-colors"
                                        >
                                            Add
                                        </button>
                                    </div>
                                </div>

                                {/* Error/Success Messages */}
                                {error && (
                                    <div className="bg-red-500/20 text-red-400 px-4 py-2 rounded-lg text-sm">
                                        {error}
                                    </div>
                                )}
                                {success && (
                                    <div className="bg-green-500/20 text-green-400 px-4 py-2 rounded-lg text-sm">
                                        {success}
                                    </div>
                                )}

                                {/* Save Button */}
                                <button
                                    onClick={handleSave}
                                    disabled={isSaving}
                                    className="w-full bg-emerald-500 hover:bg-emerald-600 disabled:bg-emerald-700 disabled:cursor-not-allowed text-white font-medium py-2 rounded-lg transition-colors flex items-center justify-center gap-2"
                                >
                                    {isSaving ? (
                                        <>
                                            <svg className="animate-spin h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                            </svg>
                                            Saving...
                                        </>
                                    ) : (
                                        'Save Profile'
                                    )}
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Share Modal Component
        const ShareModal = ({ isOpen, onClose, video, serverUrl, authToken, onShareCreated }) => {
            const [shareType, setShareType] = useState('user'); // 'user' or 'email'
            const [searchQuery, setSearchQuery] = useState('');
            const [searchResults, setSearchResults] = useState([]);
            const [selectedUser, setSelectedUser] = useState(null);
            const [email, setEmail] = useState('');
            const [includeNotes, setIncludeNotes] = useState(true);
            const [isSearching, setIsSearching] = useState(false);
            const [isSharing, setIsSharing] = useState(false);
            const [error, setError] = useState('');
            const [success, setSuccess] = useState('');
            const searchTimeoutRef = useRef(null);

            // Reset state when modal opens
            useEffect(() => {
                if (isOpen) {
                    setShareType('user');
                    setSearchQuery('');
                    setSearchResults([]);
                    setSelectedUser(null);
                    setEmail('');
                    setIncludeNotes(true);
                    setError('');
                    setSuccess('');
                }
            }, [isOpen]);

            // Search users as they type
            useEffect(() => {
                if (shareType !== 'user' || searchQuery.length < 2) {
                    setSearchResults([]);
                    return;
                }

                // Debounce search
                if (searchTimeoutRef.current) {
                    clearTimeout(searchTimeoutRef.current);
                }

                searchTimeoutRef.current = setTimeout(async () => {
                    setIsSearching(true);
                    try {
                        const response = await fetch(
                            `${serverUrl}/api/users/search?q=${encodeURIComponent(searchQuery)}`,
                            { headers: { 'Authorization': `Bearer ${authToken}` } }
                        );
                        if (response.ok) {
                            const results = await response.json();
                            setSearchResults(results);
                        }
                    } catch (e) {
                        console.error('User search error:', e);
                    } finally {
                        setIsSearching(false);
                    }
                }, 300);

                return () => {
                    if (searchTimeoutRef.current) {
                        clearTimeout(searchTimeoutRef.current);
                    }
                };
            }, [searchQuery, shareType, serverUrl, authToken]);

            const handleShare = async () => {
                setError('');
                setSuccess('');

                if (shareType === 'user' && !selectedUser) {
                    setError('Please select a user to share with');
                    return;
                }

                if (shareType === 'email' && !email) {
                    setError('Please enter an email address');
                    return;
                }

                if (shareType === 'email' && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
                    setError('Please enter a valid email address');
                    return;
                }

                setIsSharing(true);

                try {
                    const response = await fetch(`${serverUrl}/api/shares`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify({
                            type: shareType,
                            targetUserId: shareType === 'user' ? selectedUser.userId : null,
                            targetEmail: shareType === 'email' ? email : null,
                            videoId: video.id,
                            youtubeVideoId: video.videoId,
                            videoTitle: video.title,
                            videoThumbnail: video.thumbnail || `https://img.youtube.com/vi/${video.videoId}/mqdefault.jpg`,
                            includeNotes,
                            notes: includeNotes ? video.notes : null
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        setSuccess(shareType === 'user'
                            ? `Video shared with ${selectedUser.username}!`
                            : `Share invitation sent to ${email}!`
                        );
                        if (onShareCreated) onShareCreated(data.share);
                        setTimeout(() => onClose(), 2000);
                    } else {
                        const errorData = await response.json();
                        setError(errorData.error || 'Failed to share');
                    }
                } catch (e) {
                    setError('Could not connect to server');
                } finally {
                    setIsSharing(false);
                }
            };

            if (!isOpen || !video) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-md p-6 max-h-[90vh] overflow-y-auto">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold">Share Video</h2>
                            <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>

                        {/* Video Preview */}
                        <div className="flex gap-3 bg-gray-700/50 rounded-lg p-3 mb-4">
                            <img
                                src={`https://img.youtube.com/vi/${video.videoId}/default.jpg`}
                                alt=""
                                className="w-20 h-14 rounded object-cover"
                            />
                            <div className="flex-1 min-w-0">
                                <p className="text-sm font-medium truncate">{video.title}</p>
                                <p className="text-xs text-gray-400">{video.notes?.length || 0} notes</p>
                            </div>
                        </div>

                        {/* Share Type Tabs */}
                        <div className="flex gap-2 mb-4">
                            <button
                                onClick={() => setShareType('user')}
                                className={`flex-1 py-2 rounded-lg text-sm font-medium transition-colors ${
                                    shareType === 'user'
                                        ? 'bg-emerald-500 text-white'
                                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                }`}
                            >
                                Share with User
                            </button>
                            <button
                                onClick={() => setShareType('email')}
                                className={`flex-1 py-2 rounded-lg text-sm font-medium transition-colors ${
                                    shareType === 'email'
                                        ? 'bg-emerald-500 text-white'
                                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                }`}
                            >
                                Share via Email
                            </button>
                        </div>

                        {/* User Search or Email Input */}
                        {shareType === 'user' ? (
                            <div className="mb-4">
                                <label className="block text-sm text-gray-400 mb-2">Search Users</label>
                                <input
                                    type="text"
                                    value={searchQuery}
                                    onChange={(e) => {
                                        setSearchQuery(e.target.value);
                                        setSelectedUser(null);
                                    }}
                                    placeholder="Type username to search..."
                                    className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                />

                                {/* Search Results */}
                                {searchQuery.length >= 2 && (
                                    <div className="mt-2 bg-gray-700/50 rounded-lg max-h-40 overflow-y-auto">
                                        {isSearching ? (
                                            <div className="p-3 text-center text-gray-400 text-sm">Searching...</div>
                                        ) : searchResults.length > 0 ? (
                                            searchResults.map(user => (
                                                <button
                                                    key={user.userId}
                                                    onClick={() => {
                                                        setSelectedUser(user);
                                                        setSearchQuery(user.username);
                                                    }}
                                                    className={`w-full text-left px-4 py-2 hover:bg-gray-600 transition-colors ${
                                                        selectedUser?.userId === user.userId ? 'bg-emerald-500/20' : ''
                                                    }`}
                                                >
                                                    <span className="text-sm">{user.username}</span>
                                                </button>
                                            ))
                                        ) : (
                                            <div className="p-3 text-center text-gray-400 text-sm">No users found</div>
                                        )}
                                    </div>
                                )}

                                {/* Selected User */}
                                {selectedUser && (
                                    <div className="mt-2 flex items-center gap-2 bg-emerald-500/20 text-emerald-400 rounded-lg px-3 py-2">
                                        <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                            <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                                        </svg>
                                        <span className="text-sm">Sharing with {selectedUser.username}</span>
                                    </div>
                                )}
                            </div>
                        ) : (
                            <div className="mb-4">
                                <label className="block text-sm text-gray-400 mb-2">Email Address</label>
                                <input
                                    type="email"
                                    value={email}
                                    onChange={(e) => setEmail(e.target.value)}
                                    placeholder="Enter email address..."
                                    className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                />
                                <p className="text-xs text-gray-500 mt-1">
                                    They'll receive an invitation to join ClipMark
                                </p>
                            </div>
                        )}

                        {/* Include Notes Option */}
                        <label className="flex items-center gap-3 cursor-pointer mb-4 bg-gray-700/50 rounded-lg px-4 py-3">
                            <input
                                type="checkbox"
                                checked={includeNotes}
                                onChange={(e) => setIncludeNotes(e.target.checked)}
                                className="w-4 h-4 rounded accent-emerald-500"
                            />
                            <div>
                                <p className="text-sm text-gray-200">Include notes</p>
                                <p className="text-xs text-gray-500">Share your notes as a snapshot</p>
                            </div>
                        </label>

                        {/* Error/Success Messages */}
                        {error && (
                            <div className="bg-red-500/20 text-red-400 px-4 py-2 rounded-lg text-sm mb-4">
                                {error}
                            </div>
                        )}
                        {success && (
                            <div className="bg-green-500/20 text-green-400 px-4 py-2 rounded-lg text-sm mb-4">
                                {success}
                            </div>
                        )}

                        {/* Share Button */}
                        <button
                            onClick={handleShare}
                            disabled={isSharing || (shareType === 'user' && !selectedUser) || (shareType === 'email' && !email)}
                            className="w-full bg-emerald-500 hover:bg-emerald-600 disabled:bg-gray-700 disabled:cursor-not-allowed text-white font-medium py-2 rounded-lg transition-colors flex items-center justify-center gap-2"
                        >
                            {isSharing ? (
                                <>
                                    <svg className="animate-spin h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    Sharing...
                                </>
                            ) : (
                                <>
                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
                                    </svg>
                                    Share Video
                                </>
                            )}
                        </button>
                    </div>
                </div>
            );
        };

        // Pending Shares Dropdown Component
        const PendingSharesDropdown = ({ serverUrl, authToken, onAcceptShare }) => {
            const [isOpen, setIsOpen] = useState(false);
            const [pendingShares, setPendingShares] = useState([]);
            const [isLoading, setIsLoading] = useState(false);
            const dropdownRef = useRef(null);

            // Load pending shares
            const loadPendingShares = async () => {
                if (!authToken) return;

                setIsLoading(true);
                try {
                    const response = await fetch(`${serverUrl}/api/shares/incoming`, {
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });
                    if (response.ok) {
                        const shares = await response.json();
                        setPendingShares(shares);
                    }
                } catch (e) {
                    console.error('Error loading pending shares:', e);
                } finally {
                    setIsLoading(false);
                }
            };

            // Load on mount and when dropdown opens
            useEffect(() => {
                if (authToken) {
                    loadPendingShares();
                }
            }, [authToken]);

            useEffect(() => {
                if (isOpen) {
                    loadPendingShares();
                }
            }, [isOpen]);

            // Close dropdown when clicking outside
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
                        setIsOpen(false);
                    }
                };

                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            const handleAccept = async (shareId) => {
                try {
                    const response = await fetch(`${serverUrl}/api/shares/${shareId}/accept`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });

                    if (response.ok) {
                        setPendingShares(prev => prev.filter(s => s.id !== shareId));
                        if (onAcceptShare) onAcceptShare();
                    }
                } catch (e) {
                    console.error('Error accepting share:', e);
                }
            };

            const handleDecline = async (shareId) => {
                try {
                    const response = await fetch(`${serverUrl}/api/shares/${shareId}/decline`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });

                    if (response.ok) {
                        setPendingShares(prev => prev.filter(s => s.id !== shareId));
                    }
                } catch (e) {
                    console.error('Error declining share:', e);
                }
            };

            return (
                <div className="relative" ref={dropdownRef}>
                    <button
                        onClick={() => setIsOpen(!isOpen)}
                        className={`p-2 rounded-lg transition-colors relative ${
                            pendingShares.length > 0
                                ? 'bg-emerald-500/20 text-emerald-400 hover:bg-emerald-500/30'
                                : 'bg-gray-700 hover:bg-gray-600'
                        }`}
                        title="Pending shares"
                    >
                        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
                        </svg>
                        {pendingShares.length > 0 && (
                            <span className="absolute -top-1 -right-1 w-5 h-5 bg-emerald-500 text-white text-xs rounded-full flex items-center justify-center">
                                {pendingShares.length}
                            </span>
                        )}
                    </button>

                    {isOpen && (
                        <div className="absolute right-0 mt-2 w-80 bg-gray-800 rounded-lg shadow-xl border border-gray-700 z-50">
                            <div className="p-3 border-b border-gray-700">
                                <h3 className="font-medium text-sm">Pending Shares</h3>
                            </div>

                            <div className="max-h-80 overflow-y-auto">
                                {isLoading ? (
                                    <div className="p-4 text-center text-gray-400 text-sm">Loading...</div>
                                ) : pendingShares.length > 0 ? (
                                    pendingShares.map(share => (
                                        <div key={share.id} className="p-3 border-b border-gray-700 last:border-b-0">
                                            <div className="flex gap-3">
                                                <img
                                                    src={share.videoThumbnail}
                                                    alt=""
                                                    className="w-16 h-10 rounded object-cover"
                                                />
                                                <div className="flex-1 min-w-0">
                                                    <p className="text-sm font-medium truncate">{share.videoTitle}</p>
                                                    <p className="text-xs text-gray-400">
                                                        From <span className="text-emerald-400">{share.ownerUsername}</span>
                                                    </p>
                                                </div>
                                            </div>
                                            <div className="flex gap-2 mt-2">
                                                <button
                                                    onClick={() => handleAccept(share.id)}
                                                    className="flex-1 px-3 py-1.5 bg-emerald-500 hover:bg-emerald-600 text-white text-xs rounded transition-colors"
                                                >
                                                    Accept
                                                </button>
                                                <button
                                                    onClick={() => handleDecline(share.id)}
                                                    className="flex-1 px-3 py-1.5 bg-gray-600 hover:bg-gray-500 text-gray-200 text-xs rounded transition-colors"
                                                >
                                                    Decline
                                                </button>
                                            </div>
                                        </div>
                                    ))
                                ) : (
                                    <div className="p-4 text-center text-gray-400 text-sm">No pending shares</div>
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Transcript Upload Modal for SRT/VTT files
        const TranscriptUploadModal = ({ isOpen, onClose, onUpload, serverUrl, authToken }) => {
            const [file, setFile] = useState(null);
            const [fileContent, setFileContent] = useState('');
            const [preview, setPreview] = useState([]);
            const [isUploading, setIsUploading] = useState(false);
            const [error, setError] = useState('');
            const fileInputRef = useRef(null);

            const handleFileSelect = (e) => {
                const selectedFile = e.target.files[0];
                if (!selectedFile) return;

                const ext = selectedFile.name.split('.').pop().toLowerCase();
                if (!['srt', 'vtt'].includes(ext)) {
                    setError('Please select an SRT or VTT file');
                    return;
                }

                setFile(selectedFile);
                setError('');

                // Read file content for preview
                const reader = new FileReader();
                reader.onload = (event) => {
                    const content = event.target.result;
                    setFileContent(content);

                    // Generate preview (first few segments)
                    const lines = content.split('\n').slice(0, 20);
                    setPreview(lines);
                };
                reader.onerror = () => {
                    setError('Failed to read file');
                };
                reader.readAsText(selectedFile);
            };

            const handleUpload = async () => {
                if (!file || !fileContent) return;

                setIsUploading(true);
                setError('');

                try {
                    const response = await fetch(`${serverUrl}/api/transcript/upload`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify({
                            content: fileContent,
                            filename: file.name
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'Upload failed');
                    }

                    const data = await response.json();
                    console.log(`✅ Uploaded transcript: ${data.segmentCount} segments`);

                    onUpload(data.transcript);
                    handleClose();
                } catch (e) {
                    console.error('Transcript upload error:', e);
                    setError(e.message || 'Failed to upload transcript');
                } finally {
                    setIsUploading(false);
                }
            };

            const handleClose = () => {
                setFile(null);
                setFileContent('');
                setPreview([]);
                setError('');
                setIsUploading(false);
                onClose();
            };

            useEffect(() => {
                if (!isOpen) {
                    setFile(null);
                    setFileContent('');
                    setPreview([]);
                    setError('');
                    setIsUploading(false);
                }
            }, [isOpen]);

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-lg p-6">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold flex items-center gap-2">
                                <Icons.Transcript />
                                Upload Transcript
                            </h2>
                            <button onClick={handleClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>

                        <div className="space-y-4">
                            {/* File input */}
                            <div>
                                <label className="block text-sm text-gray-400 mb-2">
                                    Select SRT or VTT file
                                </label>
                                <input
                                    type="file"
                                    ref={fileInputRef}
                                    accept=".srt,.vtt"
                                    onChange={handleFileSelect}
                                    className="hidden"
                                />
                                <button
                                    onClick={() => fileInputRef.current?.click()}
                                    className="w-full bg-gray-700 border-2 border-dashed border-gray-600 rounded-lg py-8 px-4 hover:border-emerald-500 hover:bg-gray-700/80 transition-colors"
                                >
                                    <div className="text-center">
                                        <Icons.Upload />
                                        <p className="mt-2 text-sm text-gray-400">
                                            {file ? file.name : 'Click to select a file'}
                                        </p>
                                        {file && (
                                            <p className="mt-1 text-xs text-emerald-400">
                                                {(file.size / 1024).toFixed(1)} KB
                                            </p>
                                        )}
                                    </div>
                                </button>
                            </div>

                            {/* Preview */}
                            {preview.length > 0 && (
                                <div>
                                    <label className="block text-sm text-gray-400 mb-2">
                                        Preview
                                    </label>
                                    <pre className="bg-gray-900 rounded-lg p-3 text-xs text-gray-300 overflow-auto max-h-48 font-mono">
                                        {preview.join('\n')}
                                        {preview.length >= 20 && '\n...'}
                                    </pre>
                                </div>
                            )}

                            {/* Error */}
                            {error && (
                                <div className="bg-red-500/20 text-red-400 px-4 py-2 rounded-lg text-sm">
                                    {error}
                                </div>
                            )}

                            {/* Buttons */}
                            <div className="flex gap-3 pt-2">
                                <button
                                    onClick={handleClose}
                                    className="flex-1 px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors"
                                >
                                    Cancel
                                </button>
                                <button
                                    onClick={handleUpload}
                                    disabled={!file || isUploading}
                                    className="flex-1 px-4 py-2 bg-emerald-500 hover:bg-emerald-600 disabled:bg-gray-600 disabled:cursor-not-allowed rounded-lg transition-colors flex items-center justify-center gap-2"
                                >
                                    {isUploading ? (
                                        <>
                                            <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24">
                                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
                                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z" />
                                            </svg>
                                            Parsing...
                                        </>
                                    ) : (
                                        <>
                                            <Icons.Upload />
                                            Upload & Parse
                                        </>
                                    )}
                                </button>
                            </div>
                        </div>

                        {/* Help text */}
                        <p className="mt-4 text-xs text-gray-500">
                            Supported formats: SubRip (.srt) and WebVTT (.vtt).
                            Timestamps will be extracted and can be used for note navigation.
                        </p>
                    </div>
                </div>
            );
        };

        // Backup Import Modal - preview and import backup files
        const BackupImportModal = ({ isOpen, onClose, importData, fileName, serverUrl, authToken, onImportComplete }) => {
            const [strategy, setStrategy] = useState('merge');
            const [isImporting, setIsImporting] = useState(false);
            const [result, setResult] = useState(null);
            const [importError, setImportError] = useState(null);

            // Reset state when modal opens
            useEffect(() => {
                if (isOpen) {
                    setStrategy('merge');
                    setIsImporting(false);
                    setResult(null);
                    setImportError(null);
                }
            }, [isOpen]);

            if (!isOpen) return null;

            // Parse and validate the import data
            let parsed = null;
            let parseError = null;

            try {
                if (importData && typeof importData === 'object' && !Array.isArray(importData)) {
                    if (importData.clipmark_backup && importData.data) {
                        // v1 format
                        const bookmarks = Array.isArray(importData.data.bookmarks) ? importData.data.bookmarks : [];
                        const categories = Array.isArray(importData.data.categories) ? importData.data.categories : [];
                        const noteCount = bookmarks.reduce((sum, v) => sum + (Array.isArray(v?.notes) ? v.notes.length : 0), 0);
                        parsed = {
                            format: 'v1',
                            username: importData.username,
                            exportedAt: importData.exportedAt,
                            videoCount: bookmarks.length,
                            noteCount,
                            categoryCount: categories.length
                        };
                    } else if (importData.videos || importData.categories) {
                        // Legacy format
                        const videos = Array.isArray(importData.videos) ? importData.videos : [];
                        const categories = Array.isArray(importData.categories) ? importData.categories : [];
                        const noteCount = videos.reduce((sum, v) => sum + (Array.isArray(v?.notes) ? v.notes.length : 0), 0);
                        parsed = {
                            format: 'legacy',
                            username: null,
                            exportedAt: importData.exportedAt,
                            videoCount: videos.length,
                            noteCount,
                            categoryCount: categories.length
                        };
                    } else {
                        parseError = 'This file is not a valid ClipMark backup. Expected a file exported from ClipMark.';
                    }
                } else {
                    parseError = 'This file is not a valid ClipMark backup. Expected a JSON object.';
                }
            } catch (e) {
                parseError = 'Failed to parse backup file: ' + e.message;
            }

            const doImport = async () => {
                setIsImporting(true);
                setImportError(null);

                try {
                    const payload = { ...importData, strategy };
                    const response = await fetch(`${serverUrl}/api/backup/import`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify(payload)
                    });

                    const data = await response.json();
                    if (!response.ok) {
                        throw new Error(data.error || 'Import failed');
                    }

                    setResult(data);
                } catch (err) {
                    setImportError(err.message);
                } finally {
                    setIsImporting(false);
                }
            };

            const handleDone = () => {
                onImportComplete();
                onClose();
            };

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-lg p-6 max-h-[90vh] overflow-y-auto">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold flex items-center gap-2">
                                <Icons.Upload />
                                Import Backup
                            </h2>
                            <button onClick={result ? handleDone : onClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>

                        {/* Success view */}
                        {result ? (
                            <div className="space-y-4">
                                <div className="bg-emerald-500/10 border border-emerald-500/30 rounded-lg p-4">
                                    <p className="text-emerald-400 font-medium flex items-center gap-2 mb-2">
                                        <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                            <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                                        </svg>
                                        Import Successful
                                    </p>
                                    <div className="text-sm text-gray-300 space-y-1">
                                        <p>Strategy: <span className="text-gray-100 font-medium">{result.strategy === 'merge' ? 'Merge' : 'Replace All'}</span></p>
                                        <p>Videos added: <span className="text-emerald-400 font-medium">{result.bookmarks.added}</span></p>
                                        {result.strategy === 'merge' && (
                                            <p>Videos skipped (duplicates): <span className="text-gray-400 font-medium">{result.bookmarks.skipped}</span></p>
                                        )}
                                        <p>Total videos: <span className="text-gray-100 font-medium">{result.bookmarks.total}</span></p>
                                        <p>Total categories: <span className="text-gray-100 font-medium">{result.categories.total}</span></p>
                                    </div>
                                </div>
                                <button
                                    onClick={handleDone}
                                    className="w-full bg-emerald-500 hover:bg-emerald-600 text-white font-medium py-2 rounded-lg transition-colors"
                                >
                                    Done
                                </button>
                            </div>
                        ) : (
                            <div className="space-y-4">
                                {/* File info */}
                                <div className="bg-gray-700/50 rounded-lg p-3">
                                    <p className="text-sm text-gray-400 mb-1">File</p>
                                    <p className="text-gray-200 font-medium truncate">{fileName}</p>
                                </div>

                                {/* Error for invalid files */}
                                {parseError && (
                                    <div className="bg-red-500/10 border border-red-500/30 rounded-lg p-4">
                                        <p className="text-red-400 text-sm">{parseError}</p>
                                    </div>
                                )}

                                {/* Parsed stats */}
                                {parsed && (
                                    <>
                                        <div className="bg-gray-700/50 rounded-lg p-3 space-y-2">
                                            <p className="text-sm text-gray-400 mb-2">Backup Contents</p>
                                            <div className="grid grid-cols-3 gap-3 text-center">
                                                <div>
                                                    <p className="text-2xl font-bold text-emerald-400">{parsed.videoCount}</p>
                                                    <p className="text-xs text-gray-400">Videos</p>
                                                </div>
                                                <div>
                                                    <p className="text-2xl font-bold text-emerald-400">{parsed.noteCount}</p>
                                                    <p className="text-xs text-gray-400">Notes</p>
                                                </div>
                                                <div>
                                                    <p className="text-2xl font-bold text-emerald-400">{parsed.categoryCount}</p>
                                                    <p className="text-xs text-gray-400">Categories</p>
                                                </div>
                                            </div>
                                            {parsed.exportedAt && (
                                                <p className="text-xs text-gray-500 mt-2">
                                                    Exported: {new Date(parsed.exportedAt).toLocaleDateString()} at {new Date(parsed.exportedAt).toLocaleTimeString()}
                                                </p>
                                            )}
                                            {parsed.username && (
                                                <p className="text-xs text-gray-500">From account: {typeof parsed.username === 'string' ? parsed.username : parsed.username?.username || String(parsed.username)}</p>
                                            )}
                                            {parsed.format === 'legacy' && (
                                                <p className="text-xs text-yellow-400">Legacy format detected — will be imported as-is</p>
                                            )}
                                        </div>

                                        {/* Strategy selection */}
                                        <div>
                                            <p className="text-sm text-gray-400 mb-2">Import Strategy</p>
                                            <div className="space-y-2">
                                                <label className={`flex items-start gap-3 p-3 rounded-lg cursor-pointer transition-colors ${strategy === 'merge' ? 'bg-emerald-500/10 border border-emerald-500/30' : 'bg-gray-700/50 border border-transparent hover:bg-gray-700'}`}>
                                                    <input
                                                        type="radio"
                                                        name="import-strategy"
                                                        value="merge"
                                                        checked={strategy === 'merge'}
                                                        onChange={() => setStrategy('merge')}
                                                        className="mt-1 accent-emerald-500"
                                                    />
                                                    <div>
                                                        <p className="text-gray-200 font-medium">Merge</p>
                                                        <p className="text-xs text-gray-400">Add new videos only. Existing videos are kept unchanged. Duplicate videos are skipped.</p>
                                                    </div>
                                                </label>
                                                <label className={`flex items-start gap-3 p-3 rounded-lg cursor-pointer transition-colors ${strategy === 'replace' ? 'bg-red-500/10 border border-red-500/30' : 'bg-gray-700/50 border border-transparent hover:bg-gray-700'}`}>
                                                    <input
                                                        type="radio"
                                                        name="import-strategy"
                                                        value="replace"
                                                        checked={strategy === 'replace'}
                                                        onChange={() => setStrategy('replace')}
                                                        className="mt-1 accent-red-500"
                                                    />
                                                    <div>
                                                        <p className="text-gray-200 font-medium">Replace All</p>
                                                        <p className="text-xs text-red-400">Overwrite all current data with the backup. Your existing videos and notes will be permanently removed.</p>
                                                    </div>
                                                </label>
                                            </div>
                                        </div>
                                    </>
                                )}

                                {/* Import error */}
                                {importError && (
                                    <div className="bg-red-500/10 border border-red-500/30 rounded-lg p-3">
                                        <p className="text-red-400 text-sm">{importError}</p>
                                    </div>
                                )}

                                {/* Action buttons */}
                                <div className="flex gap-3">
                                    <button
                                        onClick={onClose}
                                        className="flex-1 px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors"
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        onClick={doImport}
                                        disabled={!parsed || isImporting}
                                        className="flex-1 px-4 py-2 bg-emerald-500 hover:bg-emerald-600 disabled:bg-gray-600 disabled:cursor-not-allowed rounded-lg transition-colors flex items-center justify-center gap-2"
                                    >
                                        {isImporting ? (
                                            <>
                                                <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24">
                                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
                                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z" />
                                                </svg>
                                                Importing...
                                            </>
                                        ) : (
                                            <>
                                                <Icons.Upload />
                                                Import
                                            </>
                                        )}
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Transcript Help Modal - instructions for creating SRT files
        const TranscriptHelpModal = ({ isOpen, onClose }) => {
            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-2xl p-6 max-h-[90vh] overflow-y-auto">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold flex items-center gap-2">
                                <Icons.Info />
                                How to Create a Free Transcript
                            </h2>
                            <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>

                        <div className="space-y-6 text-gray-300">
                            {/* Option 1: Google Docs */}
                            <div className="bg-gray-700/50 rounded-lg p-4">
                                <h3 className="text-lg font-medium text-emerald-400 mb-3 flex items-center gap-2">
                                    <span className="bg-emerald-500 text-white w-6 h-6 rounded-full flex items-center justify-center text-sm">1</span>
                                    Google Docs (Free, No Installation)
                                </h3>
                                <ol className="list-decimal list-inside space-y-2 text-sm">
                                    <li>Open <a href="https://docs.google.com" target="_blank" rel="noopener noreferrer" className="text-emerald-400 hover:underline">Google Docs</a> and create a new document</li>
                                    <li>Go to <strong>Tools → Voice typing</strong> (or press Ctrl+Shift+S)</li>
                                    <li>Play your video with audio audible to your computer</li>
                                    <li>Click the microphone icon to start transcribing</li>
                                    <li>When done, copy the text and format as SRT:
                                        <pre className="bg-gray-900 rounded p-2 mt-2 text-xs font-mono overflow-x-auto">
{`1
00:00:00,000 --> 00:00:10,000
First segment of text here

2
00:00:10,000 --> 00:00:20,000
Second segment of text here`}
                                        </pre>
                                    </li>
                                    <li>Save as a <code className="bg-gray-900 px-1 rounded">.srt</code> file</li>
                                </ol>
                                <p className="mt-3 text-xs text-gray-400">
                                    <strong>Tip:</strong> Timestamps don't need to be exact - approximate times work for note-taking.
                                </p>
                            </div>

                            {/* Option 2: Whisper */}
                            <div className="bg-gray-700/50 rounded-lg p-4">
                                <h3 className="text-lg font-medium text-blue-400 mb-3 flex items-center gap-2">
                                    <span className="bg-blue-500 text-white w-6 h-6 rounded-full flex items-center justify-center text-sm">2</span>
                                    OpenAI Whisper (Free, Best Quality)
                                </h3>
                                <ol className="list-decimal list-inside space-y-2 text-sm">
                                    <li>Install Python and Whisper:
                                        <pre className="bg-gray-900 rounded p-2 mt-2 text-xs font-mono overflow-x-auto">
{`pip install openai-whisper`}
                                        </pre>
                                    </li>
                                    <li>Download your video file (MP4, WebM, etc.)</li>
                                    <li>Run Whisper to generate SRT:
                                        <pre className="bg-gray-900 rounded p-2 mt-2 text-xs font-mono overflow-x-auto">
{`whisper video.mp4 --output_format srt`}
                                        </pre>
                                    </li>
                                    <li>Upload the generated <code className="bg-gray-900 px-1 rounded">.srt</code> file</li>
                                </ol>
                                <p className="mt-3 text-xs text-gray-400">
                                    <strong>Note:</strong> Whisper runs locally and is completely free. Use <code className="bg-gray-900 px-1 rounded">--model medium</code> for better accuracy.
                                </p>
                            </div>

                            {/* Option 3: Online Tools */}
                            <div className="bg-gray-700/50 rounded-lg p-4">
                                <h3 className="text-lg font-medium text-purple-400 mb-3 flex items-center gap-2">
                                    <span className="bg-purple-500 text-white w-6 h-6 rounded-full flex items-center justify-center text-sm">3</span>
                                    Online Transcription Tools
                                </h3>
                                <ul className="list-disc list-inside space-y-2 text-sm">
                                    <li><a href="https://turboscribe.ai" target="_blank" rel="noopener noreferrer" className="text-purple-400 hover:underline">TurboScribe</a> - Free tier with limited minutes</li>
                                    <li><a href="https://otter.ai" target="_blank" rel="noopener noreferrer" className="text-purple-400 hover:underline">Otter.ai</a> - 300 free minutes/month, exports to SRT</li>
                                    <li><a href="https://veed.io" target="_blank" rel="noopener noreferrer" className="text-purple-400 hover:underline">VEED.io</a> - Auto-transcribe with free tier</li>
                                </ul>
                            </div>

                            {/* SRT Format Reference */}
                            <div className="bg-gray-900 rounded-lg p-4">
                                <h3 className="text-sm font-medium text-gray-400 mb-2">SRT Format Reference</h3>
                                <pre className="text-xs font-mono text-gray-300">
{`1
00:00:00,000 --> 00:00:05,000
First subtitle text

2
00:00:05,000 --> 00:00:10,500
Second subtitle text

3
00:00:10,500 --> 00:00:15,000
Third subtitle text`}
                                </pre>
                            </div>
                        </div>

                        <div className="mt-6 flex justify-end">
                            <button
                                onClick={onClose}
                                className="px-4 py-2 bg-emerald-500 hover:bg-emerald-600 rounded-lg transition-colors"
                            >
                                Got it
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Transcript status badge component
        const TranscriptStatusBadge = ({ transcript }) => {
            if (!transcript || !transcript.segments || transcript.segments.length === 0) {
                return (
                    <span className="inline-flex items-center gap-1 px-2 py-0.5 rounded text-xs bg-gray-600 text-gray-300">
                        <Icons.Transcript />
                        No transcript
                    </span>
                );
            }

            const colorMap = {
                platform: 'bg-green-500/20 text-green-400',
                srt: 'bg-blue-500/20 text-blue-400',
                vtt: 'bg-blue-500/20 text-blue-400',
                ai: 'bg-purple-500/20 text-purple-400'
            };

            const labelMap = {
                platform: 'Platform',
                srt: 'SRT',
                vtt: 'VTT',
                ai: 'AI Generated'
            };

            const color = colorMap[transcript.source] || 'bg-gray-500/20 text-gray-400';
            const label = labelMap[transcript.source] || 'Transcript';

            return (
                <span className={`inline-flex items-center gap-1 px-2 py-0.5 rounded text-xs ${color}`}>
                    <Icons.Transcript />
                    {label} ({transcript.segments.length} segments)
                </span>
            );
        };

        // Enhancement Review Modal for ambiguous AI suggestions
        const EnhancementReviewModal = ({ isOpen, onClose, pendingEnhancements, onApply }) => {
            const [selections, setSelections] = useState([]);
            const [customTexts, setCustomTexts] = useState({});

            useEffect(() => {
                if (pendingEnhancements && pendingEnhancements.length > 0) {
                    // Initialize selections with default values
                    setSelections(pendingEnhancements.map(item => ({
                        noteId: item.noteId,
                        selectedOption: 0,
                        selectedText: item.suggestedSummary
                    })));
                    setCustomTexts({});
                }
            }, [pendingEnhancements]);

            const handleOptionChange = (noteId, optionIndex, text) => {
                setSelections(prev => prev.map(s => {
                    if (s.noteId === noteId) {
                        return { ...s, selectedOption: optionIndex, selectedText: text };
                    }
                    return s;
                }));
            };

            const handleCustomTextChange = (noteId, text) => {
                setCustomTexts(prev => ({ ...prev, [noteId]: text }));
                setSelections(prev => prev.map(s => {
                    if (s.noteId === noteId && s.selectedOption === -1) {
                        return { ...s, selectedText: text };
                    }
                    return s;
                }));
            };

            const handleSelectCustom = (noteId) => {
                const customText = customTexts[noteId] || '';
                setSelections(prev => prev.map(s => {
                    if (s.noteId === noteId) {
                        return { ...s, selectedOption: -1, selectedText: customText };
                    }
                    return s;
                }));
            };

            const handleApply = () => {
                onApply(selections);
            };

            const handleSkipAll = () => {
                onClose();
            };

            if (!isOpen || !pendingEnhancements || pendingEnhancements.length === 0) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-2xl p-6 max-h-[90vh] overflow-y-auto">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold">Review AI Suggestions</h2>
                            <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>
                        <p className="text-gray-400 text-sm mb-4">
                            The AI found some notes that could have multiple interpretations. Please select the best option for each:
                        </p>
                        <div className="space-y-6">
                            {pendingEnhancements.map((item, idx) => {
                                const currentSelection = selections.find(s => s.noteId === item.noteId);
                                return (
                                    <div key={item.noteId} className="bg-gray-700/50 rounded-lg p-4">
                                        <div className="flex items-center gap-2 mb-2">
                                            <span className="text-emerald-400 font-medium">[{formatTime(item.timestamp)}]</span>
                                            <span className="text-gray-500 text-sm">Note {idx + 1} of {pendingEnhancements.length}</span>
                                        </div>
                                        <div className="mb-3">
                                            <p className="text-xs text-gray-500 mb-1">Original note:</p>
                                            <p className="text-sm text-gray-300 bg-gray-700 p-2 rounded">{item.originalText}</p>
                                        </div>
                                        <div className="mb-3">
                                            <p className="text-xs text-gray-500 mb-1">Transcript context:</p>
                                            <p className="text-xs text-gray-400 bg-gray-700 p-2 rounded italic">{item.context}</p>
                                        </div>
                                        <div className="space-y-2">
                                            <p className="text-xs text-gray-500 mb-1">Select interpretation:</p>
                                            {/* Primary suggestion */}
                                            <label className="flex items-start gap-2 cursor-pointer p-2 rounded hover:bg-gray-700/50">
                                                <input
                                                    type="radio"
                                                    name={`note-${item.noteId}`}
                                                    checked={currentSelection?.selectedOption === 0}
                                                    onChange={() => handleOptionChange(item.noteId, 0, item.suggestedSummary)}
                                                    className="mt-1 accent-emerald-500"
                                                />
                                                <span className="text-sm text-gray-300 whitespace-pre-wrap">{item.suggestedSummary}</span>
                                            </label>
                                            {/* Alternative suggestions */}
                                            {item.alternatives && item.alternatives.map((alt, altIdx) => (
                                                <label key={altIdx} className="flex items-start gap-2 cursor-pointer p-2 rounded hover:bg-gray-700/50">
                                                    <input
                                                        type="radio"
                                                        name={`note-${item.noteId}`}
                                                        checked={currentSelection?.selectedOption === altIdx + 1}
                                                        onChange={() => handleOptionChange(item.noteId, altIdx + 1, alt)}
                                                        className="mt-1 accent-emerald-500"
                                                    />
                                                    <span className="text-sm text-gray-300 whitespace-pre-wrap">{alt}</span>
                                                </label>
                                            ))}
                                            {/* Keep original option */}
                                            <label className="flex items-start gap-2 cursor-pointer p-2 rounded hover:bg-gray-700/50">
                                                <input
                                                    type="radio"
                                                    name={`note-${item.noteId}`}
                                                    checked={currentSelection?.selectedOption === -2}
                                                    onChange={() => handleOptionChange(item.noteId, -2, item.originalText)}
                                                    className="mt-1 accent-emerald-500"
                                                />
                                                <span className="text-sm text-gray-400 italic">Keep original</span>
                                            </label>
                                            {/* Custom option */}
                                            <label className="flex items-start gap-2 cursor-pointer p-2 rounded hover:bg-gray-700/50">
                                                <input
                                                    type="radio"
                                                    name={`note-${item.noteId}`}
                                                    checked={currentSelection?.selectedOption === -1}
                                                    onChange={() => handleSelectCustom(item.noteId)}
                                                    className="mt-1 accent-emerald-500"
                                                />
                                                <span className="text-sm text-gray-400">Custom:</span>
                                            </label>
                                            {currentSelection?.selectedOption === -1 && (
                                                <textarea
                                                    value={customTexts[item.noteId] || ''}
                                                    onChange={(e) => handleCustomTextChange(item.noteId, e.target.value)}
                                                    placeholder="Enter your custom text..."
                                                    className="w-full bg-gray-700 rounded p-2 text-sm text-gray-100 resize-none ml-6"
                                                    rows={3}
                                                />
                                            )}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                        <div className="flex gap-3 mt-6">
                            <button
                                onClick={handleSkipAll}
                                className="flex-1 bg-gray-600 hover:bg-gray-500 text-white font-medium py-2 rounded-lg transition-colors"
                            >
                                Skip All
                            </button>
                            <button
                                onClick={handleApply}
                                className="flex-1 bg-emerald-500 hover:bg-emerald-600 text-white font-medium py-2 rounded-lg transition-colors"
                            >
                                Update Notes
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Authentication Modal Component
        const AuthModal = ({ isOpen, onLogin, serverUrl, embedded = false }) => {
            const [mode, setMode] = useState('login'); // 'login' or 'register'
            const [username, setUsername] = useState('');
            const [password, setPassword] = useState('');
            const [confirmPassword, setConfirmPassword] = useState('');
            const [email, setEmail] = useState('');
            const [firstName, setFirstName] = useState('');
            const [lastName, setLastName] = useState('');
            const [error, setError] = useState('');
            const [isLoading, setIsLoading] = useState(false);

            if (!isOpen) return null;

            const validateForm = () => {
                setError('');

                if (!username.trim()) {
                    setError('Username is required');
                    return false;
                }

                if (!/^[a-zA-Z0-9_]{3,30}$/.test(username)) {
                    setError('Username must be 3-30 alphanumeric characters or underscores');
                    return false;
                }

                if (!password) {
                    setError('Password is required');
                    return false;
                }

                if (password.length < 6) {
                    setError('Password must be at least 6 characters');
                    return false;
                }

                if (mode === 'register' && password !== confirmPassword) {
                    setError('Passwords do not match');
                    return false;
                }

                if (mode === 'register' && email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
                    setError('Please enter a valid email address');
                    return false;
                }

                return true;
            };

            const handleSubmit = async (e) => {
                e.preventDefault();

                if (!validateForm()) return;

                setIsLoading(true);
                setError('');

                try {
                    const endpoint = mode === 'login' ? '/auth/login' : '/auth/register';
                    const payload = mode === 'login'
                        ? { username: username.trim(), password }
                        : {
                            username: username.trim(),
                            password,
                            email: email.trim() || null,
                            firstName: firstName.trim() || null,
                            lastName: lastName.trim() || null
                        };
                    const response = await fetch(`${serverUrl}${endpoint}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        setError(data.error || 'Authentication failed');
                        setIsLoading(false);
                        return;
                    }

                    // Success - call onLogin with the auth data
                    onLogin({
                        token: data.token,
                        userId: data.userId,
                        username: data.username,
                        expiresAt: data.expiresAt
                    });
                } catch (err) {
                    console.error('Auth error:', err);
                    setError('Connection failed. Please check if the server is running.');
                    setIsLoading(false);
                }
            };

            const switchMode = () => {
                setMode(mode === 'login' ? 'register' : 'login');
                setError('');
                setPassword('');
                setConfirmPassword('');
                setEmail('');
                setFirstName('');
                setLastName('');
            };

            const formContent = (
                <>
                    {!embedded && (
                        <div className="text-center mb-6">
                            <div className="inline-flex items-center justify-center w-16 h-16 bg-emerald-500/20 rounded-full mb-4">
                                <svg className="w-8 h-8 text-emerald-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                                </svg>
                            </div>
                            <h2 className="text-2xl font-bold mb-1">
                                {mode === 'login' ? 'Welcome Back' : 'Create Account'}
                            </h2>
                            <p className="text-gray-400 text-sm">
                                {mode === 'login'
                                    ? 'Sign in to access your bookmarks'
                                    : 'Register to start saving bookmarks'}
                            </p>
                        </div>
                    )}

                    <form onSubmit={handleSubmit}>
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-sm font-medium text-gray-300 mb-1">Username</label>
                                    <input
                                        type="text"
                                        value={username}
                                        onChange={(e) => setUsername(e.target.value)}
                                        placeholder="Enter username"
                                        className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2.5 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-transparent"
                                        autoComplete="username"
                                        autoFocus
                                    />
                                </div>

                                <div>
                                    <label className="block text-sm font-medium text-gray-300 mb-1">Password</label>
                                    <input
                                        type="password"
                                        value={password}
                                        onChange={(e) => setPassword(e.target.value)}
                                        placeholder="Enter password"
                                        className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2.5 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-transparent"
                                        autoComplete={mode === 'login' ? 'current-password' : 'new-password'}
                                    />
                                </div>

                                {mode === 'register' && (
                                    <>
                                        <div>
                                            <label className="block text-sm font-medium text-gray-300 mb-1">Confirm Password</label>
                                            <input
                                                type="password"
                                                value={confirmPassword}
                                                onChange={(e) => setConfirmPassword(e.target.value)}
                                                placeholder="Confirm password"
                                                className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2.5 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-transparent"
                                                autoComplete="new-password"
                                            />
                                        </div>

                                        <div className="pt-2 border-t border-gray-700">
                                            <p className="text-xs text-gray-500 mb-3">Optional profile info</p>
                                            <div className="grid grid-cols-2 gap-3">
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-300 mb-1">First Name</label>
                                                    <input
                                                        type="text"
                                                        value={firstName}
                                                        onChange={(e) => setFirstName(e.target.value)}
                                                        placeholder="First name"
                                                        className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2.5 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-transparent"
                                                        autoComplete="given-name"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-300 mb-1">Last Name</label>
                                                    <input
                                                        type="text"
                                                        value={lastName}
                                                        onChange={(e) => setLastName(e.target.value)}
                                                        placeholder="Last name"
                                                        className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2.5 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-transparent"
                                                        autoComplete="family-name"
                                                    />
                                                </div>
                                            </div>
                                        </div>

                                        <div>
                                            <label className="block text-sm font-medium text-gray-300 mb-1">Email</label>
                                            <input
                                                type="email"
                                                value={email}
                                                onChange={(e) => setEmail(e.target.value)}
                                                placeholder="your@email.com"
                                                className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2.5 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-transparent"
                                                autoComplete="email"
                                            />
                                        </div>
                                    </>
                                )}
                            </div>

                            {error && (
                                <div className="mt-4 p-3 bg-emerald-500/20 border border-emerald-500/50 rounded-lg">
                                    <p className="text-emerald-400 text-sm">{error}</p>
                                </div>
                            )}

                            <button
                                type="submit"
                                disabled={isLoading}
                                className="w-full mt-6 bg-emerald-500 hover:bg-emerald-600 disabled:bg-emerald-500/50 text-white font-medium py-2.5 rounded-lg transition-colors flex items-center justify-center gap-2"
                            >
                                {isLoading ? (
                                    <>
                                        <svg className="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                        </svg>
                                        {mode === 'login' ? 'Signing in...' : 'Creating account...'}
                                    </>
                                ) : (
                                    mode === 'login' ? 'Sign In' : 'Create Account'
                                )}
                            </button>
                        </form>

                    <div className="mt-4 text-center">
                        <p className="text-gray-400 text-sm">
                            {mode === 'login' ? "Don't have an account?" : 'Already have an account?'}
                            <button
                                type="button"
                                onClick={switchMode}
                                className="ml-2 text-emerald-400 hover:text-emerald-300 font-medium"
                            >
                                {mode === 'login' ? 'Register' : 'Sign In'}
                            </button>
                        </p>
                    </div>
                </>
            );

            // Return embedded version (no modal wrapper)
            if (embedded) {
                return formContent;
            }

            // Return modal version
            return (
                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50">
                    <div className="bg-gray-800 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl">
                        {formContent}
                    </div>
                </div>
            );
        };

        // Admin Dashboard Component
        const AdminDashboard = ({ serverUrl, authToken, onLogout, username }) => {
            const [stats, setStats] = useState(null);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [actionLoading, setActionLoading] = useState(null); // userId being acted on
            const [deleteConfirm, setDeleteConfirm] = useState(null); // userId to confirm delete

            useEffect(() => {
                const fetchStats = async () => {
                    try {
                        if (!authToken) {
                            setError('Not authenticated. Please log in again.');
                            setLoading(false);
                            return;
                        }

                        const response = await fetch(`${serverUrl}/admin/stats`, {
                            headers: { 'Authorization': `Bearer ${authToken}` }
                        });

                        // Try to parse JSON response
                        let data;
                        const contentType = response.headers.get('content-type');
                        if (contentType && contentType.includes('application/json')) {
                            data = await response.json();
                        } else {
                            // Not JSON - likely an error page
                            const text = await response.text();
                            console.error('Non-JSON response:', text.substring(0, 200));
                            throw new Error('Server returned non-JSON response');
                        }

                        if (response.status === 403) {
                            setError(data.error || 'Access denied. Admin privileges required.');
                            setLoading(false);
                            return;
                        }

                        if (response.status === 401) {
                            setError('Session expired. Please log in again.');
                            setLoading(false);
                            return;
                        }

                        if (!response.ok) {
                            throw new Error(data.error || 'Failed to fetch stats');
                        }

                        setStats(data);
                        setLoading(false);
                    } catch (e) {
                        console.error('Admin stats fetch error:', e);
                        setError(e.message);
                        setLoading(false);
                    }
                };

                fetchStats();
            }, [serverUrl, authToken]);

            const formatDuration = (seconds) => {
                if (!seconds || seconds < 60) return `${Math.round(seconds || 0)}s`;
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                if (hours > 0) return `${hours}h ${minutes}m`;
                return `${minutes}m`;
            };

            const formatDate = (timestamp) => {
                if (!timestamp) return 'N/A';
                return new Date(timestamp).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
            };

            const handleSuspendUser = async (userId, currentlySuspended) => {
                setActionLoading(userId);
                try {
                    const response = await fetch(`${serverUrl}/admin/users/${userId}/suspend`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${authToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ suspend: !currentlySuspended })
                    });

                    if (!response.ok) {
                        const data = await response.json();
                        throw new Error(data.error || 'Failed to update user');
                    }

                    // Update local state
                    setStats(prev => ({
                        ...prev,
                        users: prev.users.map(u =>
                            u.userId === userId ? { ...u, suspended: !currentlySuspended } : u
                        )
                    }));
                } catch (e) {
                    console.error('Suspend error:', e);
                    alert('Failed to update user: ' + e.message);
                } finally {
                    setActionLoading(null);
                }
            };

            const handleDeleteUser = async (userId) => {
                setActionLoading(userId);
                setDeleteConfirm(null);
                try {
                    const response = await fetch(`${serverUrl}/admin/users/${userId}`, {
                        method: 'DELETE',
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });

                    if (!response.ok) {
                        const data = await response.json();
                        throw new Error(data.error || 'Failed to delete user');
                    }

                    // Update local state
                    setStats(prev => ({
                        ...prev,
                        totalUsers: prev.totalUsers - 1,
                        users: prev.users.filter(u => u.userId !== userId)
                    }));
                } catch (e) {
                    console.error('Delete error:', e);
                    alert('Failed to delete user: ' + e.message);
                } finally {
                    setActionLoading(null);
                }
            };

            if (loading) {
                return (
                    <div className="h-screen flex items-center justify-center bg-gray-900">
                        <div className="text-center">
                            <svg className="animate-spin h-12 w-12 text-emerald-500 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <p className="text-gray-400">Loading admin stats...</p>
                        </div>
                    </div>
                );
            }

            if (error) {
                return (
                    <div className="h-screen flex items-center justify-center bg-gray-900">
                        <div className="text-center max-w-md mx-auto px-4">
                            <div className="w-16 h-16 bg-emerald-500/20 rounded-full flex items-center justify-center mx-auto mb-4">
                                <svg className="w-8 h-8 text-emerald-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                                </svg>
                            </div>
                            <h2 className="text-xl font-semibold text-gray-100 mb-2">Access Denied</h2>
                            <p className="text-gray-400 mb-6">{error}</p>
                            <div className="flex gap-3 justify-center">
                                <a
                                    href="/"
                                    className="px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg text-gray-100 transition-colors"
                                >
                                    Go Home
                                </a>
                                <button
                                    onClick={onLogout}
                                    className="px-4 py-2 bg-emerald-500 hover:bg-emerald-600 rounded-lg text-white transition-colors"
                                >
                                    Logout
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="min-h-screen bg-gray-900 text-gray-100">
                    {/* Header */}
                    <header className="bg-gray-800 border-b border-gray-700 px-6 py-4">
                        <div className="max-w-7xl mx-auto flex items-center justify-between">
                            <div className="flex items-center gap-4">
                                <h1 className="text-2xl font-bold text-emerald-500">Admin Dashboard</h1>
                                <span className="px-2 py-1 bg-emerald-500/20 text-emerald-400 text-xs font-medium rounded">
                                    {username}
                                </span>
                            </div>
                            <div className="flex items-center gap-3">
                                <a
                                    href="/"
                                    className="px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg text-sm transition-colors"
                                >
                                    Back to App
                                </a>
                                <button
                                    onClick={onLogout}
                                    className="px-3 py-2 bg-emerald-500/20 hover:bg-emerald-500/30 text-emerald-400 rounded-lg text-sm transition-colors"
                                >
                                    Logout
                                </button>
                            </div>
                        </div>
                    </header>

                    <main className="max-w-7xl mx-auto px-6 py-8">
                        {/* Stats Cards */}
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                            <div className="bg-gray-800 rounded-xl p-6 border border-gray-700">
                                <div className="flex items-center gap-3 mb-2">
                                    <div className="w-10 h-10 bg-blue-500/20 rounded-lg flex items-center justify-center">
                                        <svg className="w-5 h-5 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                                        </svg>
                                    </div>
                                    <span className="text-gray-400 text-sm">Total Users</span>
                                </div>
                                <p className="text-3xl font-bold text-gray-100">{stats.totalUsers}</p>
                            </div>

                            <div className="bg-gray-800 rounded-xl p-6 border border-gray-700">
                                <div className="flex items-center gap-3 mb-2">
                                    <div className="w-10 h-10 bg-green-500/20 rounded-lg flex items-center justify-center">
                                        <svg className="w-5 h-5 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                                        </svg>
                                    </div>
                                    <span className="text-gray-400 text-sm">Total Videos</span>
                                </div>
                                <p className="text-3xl font-bold text-gray-100">{stats.totalVideos}</p>
                            </div>

                            <div className="bg-gray-800 rounded-xl p-6 border border-gray-700">
                                <div className="flex items-center gap-3 mb-2">
                                    <div className="w-10 h-10 bg-yellow-500/20 rounded-lg flex items-center justify-center">
                                        <svg className="w-5 h-5 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                                        </svg>
                                    </div>
                                    <span className="text-gray-400 text-sm">Total Notes</span>
                                </div>
                                <p className="text-3xl font-bold text-gray-100">{stats.totalNotes}</p>
                            </div>

                            <div className="bg-gray-800 rounded-xl p-6 border border-gray-700">
                                <div className="flex items-center gap-3 mb-2">
                                    <div className="w-10 h-10 bg-purple-500/20 rounded-lg flex items-center justify-center">
                                        <svg className="w-5 h-5 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                                        </svg>
                                    </div>
                                    <span className="text-gray-400 text-sm">Total Watch Time</span>
                                </div>
                                <p className="text-3xl font-bold text-gray-100">{formatDuration(stats.totalWatchTime)}</p>
                            </div>
                        </div>

                        {/* Users Table */}
                        <div className="bg-gray-800 rounded-xl border border-gray-700 overflow-hidden">
                            <div className="px-6 py-4 border-b border-gray-700">
                                <h2 className="text-lg font-semibold text-gray-100">Users</h2>
                            </div>
                            <div className="overflow-x-auto">
                                <table className="w-full">
                                    <thead className="bg-gray-700/50">
                                        <tr>
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Username</th>
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Status</th>
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Joined</th>
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Videos</th>
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Notes</th>
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Watch Time</th>
                                            <th className="px-6 py-3 text-right text-xs font-medium text-gray-400 uppercase tracking-wider">Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody className="divide-y divide-gray-700">
                                        {stats.users.map((user) => {
                                            const isAdmin = user.username.toLowerCase() === 'absolute0net';
                                            const isCurrentUser = user.username.toLowerCase() === username?.toLowerCase();
                                            return (
                                            <tr key={user.userId} className={`hover:bg-gray-700/30 transition-colors ${user.suspended ? 'opacity-60' : ''}`}>
                                                <td className="px-6 py-4 whitespace-nowrap">
                                                    <div className="flex items-center gap-3">
                                                        <div className={`w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium ${user.suspended ? 'bg-gray-700 text-gray-500' : 'bg-gray-600 text-gray-300'}`}>
                                                            {user.username.charAt(0).toUpperCase()}
                                                        </div>
                                                        <span className={`font-medium ${user.suspended ? 'text-gray-500 line-through' : 'text-gray-100'}`}>{user.username}</span>
                                                        {isAdmin && (
                                                            <span className="px-1.5 py-0.5 bg-emerald-500/20 text-emerald-400 text-xs rounded">Admin</span>
                                                        )}
                                                    </div>
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap">
                                                    {user.suspended ? (
                                                        <span className="px-2 py-1 bg-emerald-500/20 text-emerald-400 text-xs rounded">Suspended</span>
                                                    ) : (
                                                        <span className="px-2 py-1 bg-green-500/20 text-green-400 text-xs rounded">Active</span>
                                                    )}
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap text-gray-400 text-sm">
                                                    {formatDate(user.createdAt)}
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap">
                                                    <span className="px-2 py-1 bg-green-500/20 text-green-400 text-sm rounded">
                                                        {user.videoCount}
                                                    </span>
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap">
                                                    <span className="px-2 py-1 bg-yellow-500/20 text-yellow-400 text-sm rounded">
                                                        {user.noteCount}
                                                    </span>
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap text-gray-400 text-sm">
                                                    {formatDuration(user.watchTime)}
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap text-right">
                                                    {!isAdmin && !isCurrentUser && (
                                                        <div className="flex items-center justify-end gap-2">
                                                            <button
                                                                onClick={() => handleSuspendUser(user.userId, user.suspended)}
                                                                disabled={actionLoading === user.userId}
                                                                className={`px-3 py-1 text-xs rounded transition-colors disabled:opacity-50 ${
                                                                    user.suspended
                                                                        ? 'bg-green-500/20 text-green-400 hover:bg-green-500/30'
                                                                        : 'bg-yellow-500/20 text-yellow-400 hover:bg-yellow-500/30'
                                                                }`}
                                                                title={user.suspended ? 'Unsuspend user' : 'Suspend user'}
                                                            >
                                                                {actionLoading === user.userId ? '...' : (user.suspended ? 'Unsuspend' : 'Suspend')}
                                                            </button>
                                                            {deleteConfirm === user.userId ? (
                                                                <div className="flex items-center gap-1">
                                                                    <button
                                                                        onClick={() => handleDeleteUser(user.userId)}
                                                                        disabled={actionLoading === user.userId}
                                                                        className="px-2 py-1 text-xs bg-emerald-500 text-white rounded hover:bg-emerald-600 transition-colors disabled:opacity-50"
                                                                    >
                                                                        Confirm
                                                                    </button>
                                                                    <button
                                                                        onClick={() => setDeleteConfirm(null)}
                                                                        className="px-2 py-1 text-xs bg-gray-600 text-gray-300 rounded hover:bg-gray-500 transition-colors"
                                                                    >
                                                                        Cancel
                                                                    </button>
                                                                </div>
                                                            ) : (
                                                                <button
                                                                    onClick={() => setDeleteConfirm(user.userId)}
                                                                    disabled={actionLoading === user.userId}
                                                                    className="px-3 py-1 text-xs bg-emerald-500/20 text-emerald-400 rounded hover:bg-emerald-500/30 transition-colors disabled:opacity-50"
                                                                    title="Delete user"
                                                                >
                                                                    Delete
                                                                </button>
                                                            )}
                                                        </div>
                                                    )}
                                                    {(isAdmin || isCurrentUser) && (
                                                        <span className="text-gray-600 text-xs">-</span>
                                                    )}
                                                </td>
                                            </tr>
                                            );
                                        })}
                                        {stats.users.length === 0 && (
                                            <tr>
                                                <td colSpan={7} className="px-6 py-8 text-center text-gray-500">
                                                    No users yet
                                                </td>
                                            </tr>
                                        )}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </main>
                </div>
            );
        };

        // Main App Component
        const App = () => {
            const [videos, setVideos] = useState([]);
            const [categories, setCategories] = useState([]);
            const [activeVideoId, setActiveVideoId] = useState(null);
            const [activeSharedVideo, setActiveSharedVideo] = useState(null); // For viewing shared videos
            const [currentTime, setCurrentTime] = useState(0);
            const [searchQuery, setSearchQuery] = useState('');
            const [selectedCategory, setSelectedCategory] = useState('all');
            const [sortBy, setSortBy] = useState('date-desc');
            const [showAddModal, setShowAddModal] = useState(false);
            const [showCategoryModal, setShowCategoryModal] = useState(false);
            const [showSettingsModal, setShowSettingsModal] = useState(false);
            const [showProfileModal, setShowProfileModal] = useState(false);
            const [showShareModal, setShowShareModal] = useState(false);
            const [shareVideo, setShareVideo] = useState(null);
            const [sharedWithMe, setSharedWithMe] = useState([]);
            const [showSharedWithMe, setShowSharedWithMe] = useState(false);
            const [pendingShareToken, setPendingShareToken] = useState(null);
            const [sharePreview, setSharePreview] = useState(null);
            const [sharePreviewError, setSharePreviewError] = useState(null);
            const [isClaimingShare, setIsClaimingShare] = useState(false);
            const [showLibrary, setShowLibrary] = useState(true);
            const [libraryViewMode, setLibraryViewMode] = useState('grid'); // 'grid' or 'list'
            const [newNote, setNewNote] = useState('');
            const [noteSearch, setNoteSearch] = useState('');
            const [geminiApiKey, setGeminiApiKey] = useState(''); // Deprecated - kept for backward compatibility
            const [youtubeApiKey, setYoutubeApiKey] = useState(''); // Deprecated - kept for backward compatibility
            const [apiStatus, setApiStatus] = useState({ geminiConfigured: false, youtubeConfigured: false });
            const [contextWordCount, setContextWordCount] = useState(10);
            const [cachedTranscript, setCachedTranscript] = useState(null);
            const [isLoadingContext, setIsLoadingContext] = useState(false);
            const [showFullDescription, setShowFullDescription] = useState(false);
            const [fetchingDateFor, setFetchingDateFor] = useState(null);
            const [editingVideo, setEditingVideo] = useState(null);
            const [showEditModal, setShowEditModal] = useState(false);
            const [isRefreshing, setIsRefreshing] = useState(false);
            const playerRef = useRef(null);
            const fileInputRef = useRef(null);

            // Save status and storage state
            const [saveStatus, setSaveStatus] = useState('saved'); // 'saving' | 'saved' | 'error'
            const [lastSaveTime, setLastSaveTime] = useState(null);
            const [storageAvailable, setStorageAvailable] = useState(true);

            // Enhancement state for AI note processing
            const [isEnhancing, setIsEnhancing] = useState(false);
            const [enhancementProgress, setEnhancementProgress] = useState({ current: 0, total: 0 });
            const [pendingEnhancements, setPendingEnhancements] = useState([]); // Notes needing user selection
            const [showEnhancementReview, setShowEnhancementReview] = useState(false);

            // Transcript upload modal state
            const [showTranscriptModal, setShowTranscriptModal] = useState(false);
            const [showTranscriptHelp, setShowTranscriptHelp] = useState(false);

            // Backup import modal state
            const [showImportModal, setShowImportModal] = useState(false);
            const [importData, setImportData] = useState(null);
            const [importFileName, setImportFileName] = useState('');

            // Authentication state
            const [isAuthenticated, setIsAuthenticated] = useState(false);
            const [currentUser, setCurrentUser] = useState(null);
            const [authToken, setAuthToken] = useState(null);
            const [showAuthModal, setShowAuthModal] = useState(false);
            const [authLoading, setAuthLoading] = useState(true); // Loading auth check on startup
            const [isAdmin, setIsAdmin] = useState(false);

            // Admin route detection
            const isAdminRoute = window.location.pathname === '/admin' || window.location.hash === '#/admin';

            // Server URL for syncing bookmarks
            const SERVER_HOST = window.location.protocol === 'file:'
                ? 'localhost'
                : window.location.hostname;
            // Use same origin when served via nginx (port 80), otherwise use port 3456
            const SERVER_URL = (window.location.port === '' || window.location.port === '80')
                ? window.location.origin
                : `http://${SERVER_HOST}:3456`;

            // Handle successful login
            const handleLogin = async (authData) => {
                const { token, userId, username, expiresAt } = authData;

                // Save token to localStorage
                try {
                    localStorage.setItem('ytBookmarks_authToken', token);
                    localStorage.setItem('ytBookmarks_authExpires', expiresAt.toString());
                    console.log('✅ Saved auth token to localStorage');
                } catch (e) {
                    console.warn('Could not save auth token to localStorage:', e.message);
                }

                // Check if user is admin
                try {
                    const checkResponse = await fetch(`${SERVER_URL}/auth/check`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (checkResponse.ok) {
                        const checkData = await checkResponse.json();
                        setIsAdmin(checkData.isAdmin || false);
                    }
                } catch (e) {
                    console.log('Could not check admin status:', e.message);
                }

                // Update auth state
                setAuthToken(token);
                setCurrentUser({ userId, username });
                setIsAuthenticated(true);
                setShowAuthModal(false);
                setAuthLoading(false);

                // Load user's data from server
                await loadUserData(token);

                // Check if there's a pending share token to claim
                if (pendingShareToken) {
                    console.log('🎁 Claiming pending share...');
                    setIsClaimingShare(true);
                    try {
                        const claimResponse = await fetch(`${SERVER_URL}/api/shares/claim?token=${encodeURIComponent(pendingShareToken)}`, {
                            method: 'POST',
                            headers: { 'Authorization': `Bearer ${token}` }
                        });

                        if (claimResponse.ok) {
                            console.log('✅ Share claimed successfully!');
                            // Reload shared videos
                            const sharedResponse = await fetch(`${SERVER_URL}/api/shares/library`, {
                                headers: { 'Authorization': `Bearer ${token}` }
                            });
                            if (sharedResponse.ok) {
                                const sharedData = await sharedResponse.json();
                                setSharedWithMe(sharedData);
                            }
                            // Clear the URL param
                            window.history.replaceState({}, document.title, window.location.pathname);
                        } else {
                            const errorData = await claimResponse.json();
                            console.warn('Failed to claim share:', errorData.error);
                        }
                    } catch (e) {
                        console.error('Error claiming share:', e.message);
                    } finally {
                        setPendingShareToken(null);
                        setSharePreview(null);
                        setIsClaimingShare(false);
                    }
                }
            };

            // Handle logout
            const handleLogout = async () => {
                // Call logout endpoint
                try {
                    await fetch(`${SERVER_URL}/auth/logout`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        }
                    });
                } catch (e) {
                    console.log('Logout request failed:', e.message);
                }

                // Clear local auth state
                try {
                    localStorage.removeItem('ytBookmarks_authToken');
                    localStorage.removeItem('ytBookmarks_authExpires');
                } catch (e) {
                    console.warn('Could not clear auth token from localStorage:', e.message);
                }

                setAuthToken(null);
                setCurrentUser(null);
                setIsAuthenticated(false);
                setVideos([]);
                setCategories([]);
                setShowAuthModal(true);

                console.log('🚪 Logged out');
            };

            // Load user data after authentication
            const loadUserData = async (token) => {
                try {
                    // Load categories from server
                    const catResponse = await fetch(`${SERVER_URL}/categories`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (catResponse.ok) {
                        const serverCategories = await catResponse.json();
                        if (Array.isArray(serverCategories)) {
                            setCategories(serverCategories);
                            console.log('✅ Loaded categories from server:', serverCategories.length);
                        }
                    } else if (catResponse.status === 401) {
                        // Token is invalid, show auth modal
                        setShowAuthModal(true);
                        setAuthLoading(false);
                        return;
                    }

                    // Load bookmarks from server
                    const response = await fetch(`${SERVER_URL}/bookmarks`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (response.ok) {
                        const serverData = await response.json();
                        if (Array.isArray(serverData)) {
                            // Apply migration for multi-source video support
                            const migratedData = migrateVideosArray(serverData);
                            setVideos(migratedData);
                            console.log('✅ Loaded bookmarks from server:', migratedData.length);
                        }
                    } else if (response.status === 401) {
                        // Token is invalid, show auth modal
                        setShowAuthModal(true);
                        setAuthLoading(false);
                        return;
                    }

                    // Load shared-with-me videos
                    try {
                        const sharedResponse = await fetch(`${SERVER_URL}/api/shares/library`, {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });
                        if (sharedResponse.ok) {
                            const sharedData = await sharedResponse.json();
                            if (Array.isArray(sharedData)) {
                                setSharedWithMe(sharedData);
                                console.log('✅ Loaded shared videos:', sharedData.length);
                            }
                        }
                    } catch (e) {
                        console.log('Could not load shared videos:', e.message);
                    }
                } catch (e) {
                    console.error('Error loading user data:', e.message);
                }
            };

            // Reload shared-with-me videos
            const reloadSharedVideos = async () => {
                if (!authToken) return;
                try {
                    const response = await fetch(`${SERVER_URL}/api/shares/library`, {
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });
                    if (response.ok) {
                        const sharedData = await response.json();
                        if (Array.isArray(sharedData)) {
                            setSharedWithMe(sharedData);
                        }
                    }
                } catch (e) {
                    console.log('Could not reload shared videos:', e.message);
                }
            };

            // Load data from server (with localStorage fallback)
            useEffect(() => {
                const loadData = async () => {
                    // Check for share token in URL
                    const urlParams = new URLSearchParams(window.location.search);
                    const shareToken = urlParams.get('share_token');
                    if (shareToken) {
                        console.log('🔗 Found share token in URL:', shareToken);
                        setPendingShareToken(shareToken);

                        // Fetch share preview
                        try {
                            const previewResponse = await fetch(`${SERVER_URL}/api/shares/preview?token=${encodeURIComponent(shareToken)}`);
                            if (previewResponse.ok) {
                                const preview = await previewResponse.json();
                                setSharePreview(preview);
                                console.log('✅ Loaded share preview:', preview.videoTitle);
                            } else {
                                const errorData = await previewResponse.json();
                                setSharePreviewError(errorData.error || 'Failed to load share');
                            }
                        } catch (e) {
                            setSharePreviewError('Could not connect to server');
                        }
                    }

                    // Check storage availability (for private browsing detection)
                    const storageOk = isStorageAvailable('localStorage');
                    setStorageAvailable(storageOk);
                    if (!storageOk) {
                        console.warn('⚠️ localStorage unavailable - private browsing mode detected');
                    }

                    // Fetch server API status (Gemini/YouTube configured)
                    try {
                        const statusResponse = await fetch(`${SERVER_URL}/api/status`);
                        if (statusResponse.ok) {
                            const status = await statusResponse.json();
                            setApiStatus(status);
                            console.log(`✅ API Status: Gemini=${status.geminiConfigured}, YouTube=${status.youtubeConfigured}`);
                        }
                    } catch (e) {
                        console.warn('Could not fetch API status:', e.message);
                    }

                    try {
                        const savedContextWords = localStorage.getItem('ytBookmarks_contextWordCount');
                        if (savedContextWords) {
                            setContextWordCount(parseInt(savedContextWords, 10));
                            console.log('✅ Loaded context word count from localStorage');
                        }
                    } catch (e) {
                        console.warn('Could not access localStorage:', e.message);
                    }

                    // Check for saved auth token
                    let savedToken = null;
                    try {
                        savedToken = localStorage.getItem('ytBookmarks_authToken');
                        const savedExpires = localStorage.getItem('ytBookmarks_authExpires');

                        // Check if token is expired
                        if (savedToken && savedExpires) {
                            const expiresAt = parseInt(savedExpires, 10);
                            if (Date.now() > expiresAt) {
                                console.log('⚠️ Auth token expired, clearing...');
                                localStorage.removeItem('ytBookmarks_authToken');
                                localStorage.removeItem('ytBookmarks_authExpires');
                                savedToken = null;
                            }
                        }
                    } catch (e) {
                        console.warn('Could not read auth token from localStorage:', e.message);
                    }

                    // If we have a saved token, verify it with the server
                    if (savedToken) {
                        try {
                            const checkResponse = await fetch(`${SERVER_URL}/auth/check`, {
                                headers: { 'Authorization': `Bearer ${savedToken}` }
                            });

                            if (checkResponse.ok) {
                                const checkData = await checkResponse.json();
                                if (checkData.valid) {
                                    // Token is valid, set auth state and load user data
                                    setAuthToken(savedToken);
                                    setCurrentUser({ userId: checkData.userId, username: checkData.username });
                                    setIsAuthenticated(true);
                                    setIsAdmin(checkData.isAdmin || false);
                                    setAuthLoading(false);

                                    console.log(`✅ Authenticated as ${checkData.username}${checkData.isAdmin ? ' (Admin)' : ''}`);

                                    // Load user data
                                    await loadUserData(savedToken);
                                    return;
                                }
                            }

                            // Token is invalid, clear it
                            console.log('⚠️ Auth token invalid, clearing...');
                            localStorage.removeItem('ytBookmarks_authToken');
                            localStorage.removeItem('ytBookmarks_authExpires');
                        } catch (e) {
                            console.log('Could not verify auth token:', e.message);
                        }
                    }

                    // No valid token, show auth modal
                    setAuthLoading(false);
                    setShowAuthModal(true);
                    return; // Don't load any data without authentication

                    // LEGACY CODE BELOW - kept for reference but never reached
                    // Try to load categories from server first
                    let categoriesLoaded = false;
                    try {
                        const catResponse = await fetch(`${SERVER_URL}/categories`);
                        if (catResponse.ok) {
                            const serverCategories = await catResponse.json();
                            if (Array.isArray(serverCategories) && serverCategories.length > 0) {
                                setCategories(serverCategories);
                                console.log('✅ Loaded categories from server:', serverCategories.length);
                                categoriesLoaded = true;
                            }
                        }
                    } catch (e) {
                        console.log('Server categories not available:', e.message);
                    }

                    // Fall back to localStorage for categories
                    if (!categoriesLoaded) {
                        try {
                            const savedCategories = localStorage.getItem('ytBookmarks_categories');
                            console.log('Raw saved categories from localStorage:', savedCategories);
                            if (savedCategories) {
                                const parsedCategories = JSON.parse(savedCategories);

                                // Check if categories are in correct format: array of {id, name} objects
                                let validCategories = [];
                                if (Array.isArray(parsedCategories) && parsedCategories.length > 0) {
                                    // Check if items are objects with id and name, or just strings (corrupted)
                                    const firstItem = parsedCategories[0];
                                    if (typeof firstItem === 'string') {
                                        // Categories are corrupted - just IDs stored as strings
                                        console.warn('⚠️ Categories are corrupted (strings instead of objects). Clearing and will rebuild.');
                                        validCategories = [];
                                    } else if (typeof firstItem === 'object' && firstItem.id && firstItem.name) {
                                        // Valid category objects
                                        validCategories = parsedCategories;
                                        console.log('✅ Loaded categories from localStorage:', validCategories);
                                    } else {
                                        console.warn('⚠️ Categories have invalid structure:', firstItem);
                                        validCategories = [];
                                    }
                                }
                                setCategories(validCategories);
                            } else {
                                console.log('⚠️ No categories found in localStorage (ytBookmarks_categories is null/undefined)');
                                setCategories([]);
                            }
                        } catch (e) {
                            console.error('❌ Could not load categories from localStorage:', e.message, e);
                            setCategories([]);
                        }
                    }

                    // Try to load bookmarks from server
                    try {
                        const response = await fetch(`${SERVER_URL}/bookmarks`);
                        if (response.ok) {
                            const serverData = await response.json();
                            if (Array.isArray(serverData) && serverData.length > 0) {
                                // Apply migration for multi-source video support
                                const migratedData = migrateVideosArray(serverData);
                                setVideos(migratedData);
                                console.log('✅ Loaded bookmarks from server:', migratedData.length);
                                return;
                            }
                        }
                    } catch (e) {
                        console.log('Server not available, using localStorage:', e.message);
                    }

                    // Fallback to localStorage for videos
                    try {
                        let savedVideos = localStorage.getItem('ytBookmarks_videos');

                        // If localStorage is empty, try to recover from sessionStorage backup
                        if (!savedVideos && isStorageAvailable('sessionStorage')) {
                            try {
                                const backup = sessionStorage.getItem('ytBookmarks_backup');
                                if (backup) {
                                    const parsed = JSON.parse(backup);
                                    if (parsed.videos && parsed.categories) {
                                        // Apply migration for multi-source video support
                                        setVideos(migrateVideosArray(parsed.videos));
                                        setCategories(parsed.categories);
                                        console.log('✅ Recovered from sessionStorage backup');
                                        return;
                                    }
                                }
                            } catch (e) {
                                console.warn('Could not recover from sessionStorage backup:', e.message);
                            }
                        }

                        if (savedVideos) {
                            const parsedVideos = JSON.parse(savedVideos);
                            // Apply migration for multi-source video support
                            const migratedVideos = migrateVideosArray(parsedVideos);
                            setVideos(migratedVideos);
                            console.log('✅ Loaded videos from localStorage:', migratedVideos.length);
                        } else {
                            console.log('⚠️ No videos found in localStorage');
                        }
                    } catch (e) {
                        console.error('❌ Could not load videos from localStorage:', e.message, e);
                    }

                    // Debug info
                    console.log('📊 Current state after load:', {
                        categoriesCount: categories.length,
                        videosCount: videos.length
                    });
                    console.log('💾 All localStorage keys:', Object.keys(localStorage).filter(k => k.startsWith('ytBookmarks_')));
                };
                loadData();
            }, []);

            // Immediate save to localStorage and sessionStorage (no debounce)
            const saveImmediately = useCallback((videosToSave, categoriesToSave) => {
                // Save to localStorage immediately
                try {
                    saveToStorage('ytBookmarks_videos', videosToSave, localStorage);
                    setSaveStatus('saved');
                    setLastSaveTime(new Date());
                } catch (e) {
                    console.error('Failed to save videos to localStorage:', e.message);
                    setSaveStatus('error');
                }

                // Save categories to localStorage immediately
                try {
                    saveToStorage('ytBookmarks_categories', categoriesToSave, localStorage);
                } catch (e) {
                    console.error('Failed to save categories to localStorage:', e.message);
                }

                // Mirror to sessionStorage as backup
                try {
                    if (isStorageAvailable('sessionStorage')) {
                        sessionStorage.setItem('ytBookmarks_backup', JSON.stringify({
                            videos: videosToSave,
                            categories: categoriesToSave,
                            timestamp: Date.now()
                        }));
                    }
                } catch (e) {
                    console.warn('SessionStorage backup failed:', e.message);
                }
            }, []);

            // Sync to server (async, with debounce) - requires authentication
            const syncToServer = async (videosToSave, categoriesToSave) => {
                // Don't sync if not authenticated
                if (!authToken) {
                    console.log('⚠️ Cannot sync to server: not authenticated');
                    return;
                }

                try {
                    const response = await fetch(`${SERVER_URL}/bookmarks`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify(videosToSave)
                    });
                    if (response.ok) {
                        console.log('✅ Synced bookmarks to server');
                    } else if (response.status === 401) {
                        console.log('⚠️ Auth token expired, showing login...');
                        setShowAuthModal(true);
                        setIsAuthenticated(false);
                    } else {
                        console.log('Server returned status:', response.status);
                        setSaveStatus('error');
                    }
                } catch (e) {
                    console.log('Could not sync bookmarks to server:', e.message);
                    setSaveStatus('error');
                }

                // Also sync categories
                try {
                    const catResponse = await fetch(`${SERVER_URL}/categories`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify(categoriesToSave)
                    });
                    if (catResponse.ok) {
                        console.log('✅ Synced categories to server');
                    }
                } catch (e) {
                    console.log('Could not sync categories to server:', e.message);
                }
            };

            // Track watch time - debounced to avoid excessive requests
            const watchTimeBufferRef = useRef({});
            const watchTimeSyncRef = useRef(null);

            const trackWatchTime = useCallback((videoId, seconds) => {
                if (!authToken || !videoId || seconds < 1) return;

                // Accumulate watch time in buffer
                watchTimeBufferRef.current[videoId] = (watchTimeBufferRef.current[videoId] || 0) + seconds;

                // Debounce the server sync (every 30 seconds or when video changes)
                if (watchTimeSyncRef.current) clearTimeout(watchTimeSyncRef.current);
                watchTimeSyncRef.current = setTimeout(() => {
                    const buffer = { ...watchTimeBufferRef.current };
                    watchTimeBufferRef.current = {};

                    // Send accumulated watch time to server
                    Object.entries(buffer).forEach(([vid, duration]) => {
                        if (duration > 0) {
                            fetch(`${SERVER_URL}/admin/watch-time`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${authToken}`
                                },
                                body: JSON.stringify({ videoId: vid, duration })
                            }).then(res => {
                                if (res.ok) {
                                    console.log(`⏱️ Tracked ${duration}s watch time for ${vid}`);
                                }
                            }).catch(e => {
                                console.log('Could not track watch time:', e.message);
                            });
                        }
                    });
                }, 30000); // Sync every 30 seconds
            }, [authToken, SERVER_URL]);

            // Flush watch time on unmount or visibility change
            useEffect(() => {
                const flushWatchTime = () => {
                    if (Object.keys(watchTimeBufferRef.current).length > 0 && authToken) {
                        const buffer = { ...watchTimeBufferRef.current };
                        watchTimeBufferRef.current = {};

                        Object.entries(buffer).forEach(([vid, duration]) => {
                            if (duration > 0) {
                                // Use fetch with keepalive for reliability on page hide
                                fetch(`${SERVER_URL}/admin/watch-time`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'Authorization': `Bearer ${authToken}`
                                    },
                                    body: JSON.stringify({ videoId: vid, duration }),
                                    keepalive: true
                                }).catch(() => {}); // Ignore errors on page close
                            }
                        });
                    }
                };

                const handleVisibility = () => {
                    if (document.hidden) flushWatchTime();
                };

                window.addEventListener('pagehide', flushWatchTime);
                document.addEventListener('visibilitychange', handleVisibility);

                return () => {
                    flushWatchTime();
                    window.removeEventListener('pagehide', flushWatchTime);
                    document.removeEventListener('visibilitychange', handleVisibility);
                };
            }, [authToken, SERVER_URL]);

            // Debounced server sync effect for videos
            const saveTimeoutRef = useRef(null);
            useEffect(() => {
                // Only sync when authenticated
                if (!isAuthenticated) return;

                // Save immediately to localStorage (backup)
                if (videos.length > 0) {
                    saveImmediately(videos, categories);
                }

                // Debounce server sync to avoid too many requests
                if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);
                saveTimeoutRef.current = setTimeout(() => {
                    if (videos.length > 0 || categories.length > 0) {
                        syncToServer(videos, categories);
                    }
                }, 500);

                return () => clearTimeout(saveTimeoutRef.current);
            }, [videos, categories, saveImmediately, isAuthenticated]);

            // Page lifecycle handlers to save on unload (iOS Safari support)
            useEffect(() => {
                const handleBeforeUnload = (e) => {
                    // Force immediate save before page unload
                    saveImmediately(videos, categories);
                };

                const handlePageHide = (e) => {
                    // iOS Safari - more reliable than beforeunload
                    saveImmediately(videos, categories);
                };

                const handleVisibilityChange = () => {
                    // Tab backgrounded on mobile
                    if (document.hidden) {
                        saveImmediately(videos, categories);
                    }
                };

                window.addEventListener('beforeunload', handleBeforeUnload);
                window.addEventListener('pagehide', handlePageHide);
                document.addEventListener('visibilitychange', handleVisibilityChange);

                return () => {
                    window.removeEventListener('beforeunload', handleBeforeUnload);
                    window.removeEventListener('pagehide', handlePageHide);
                    document.removeEventListener('visibilitychange', handleVisibilityChange);
                };
            }, [videos, categories, saveImmediately]);

            // Save API key handlers
            const handleSaveGeminiApiKey = (key) => {
                setGeminiApiKey(key);
                try {
                    localStorage.setItem('ytBookmarks_geminiApiKey', key);
                    console.log('✅ Saved Gemini API key to localStorage');
                } catch (e) {
                    console.error('Could not save Gemini API key:', e.message);
                }
            };

            const handleSaveYoutubeApiKey = (key) => {
                setYoutubeApiKey(key);
                try {
                    localStorage.setItem('ytBookmarks_youtubeApiKey', key);
                    console.log('✅ Saved YouTube API key to localStorage');
                } catch (e) {
                    console.error('Could not save YouTube API key:', e.message);
                }
            };

            const handleSaveContextWordCount = (count) => {
                setContextWordCount(count);
                try {
                    localStorage.setItem('ytBookmarks_contextWordCount', count.toString());
                    console.log('✅ Saved context word count to localStorage');
                } catch (e) {
                    console.error('Could not save context word count:', e.message);
                }
            };

            // Function to extract context words from transcript at a given timestamp
            const getTranscriptContext = (transcript, timestamp, wordsBefore = 10, wordsAfter = 10) => {
                if (!transcript || transcript.length === 0) return '';

                // Build full text with word positions mapped to timestamps
                const wordData = [];
                transcript.forEach(segment => {
                    const words = segment.text.split(/\s+/).filter(w => w.trim());
                    const segmentDuration = segment.duration || 2;
                    const timePerWord = segmentDuration / Math.max(words.length, 1);

                    words.forEach((word, idx) => {
                        wordData.push({
                            word: word,
                            timestamp: segment.start + (idx * timePerWord)
                        });
                    });
                });

                // Find the word closest to the current timestamp
                let closestIdx = 0;
                let closestDiff = Math.abs(wordData[0]?.timestamp - timestamp) || Infinity;

                for (let i = 1; i < wordData.length; i++) {
                    const diff = Math.abs(wordData[i].timestamp - timestamp);
                    if (diff < closestDiff) {
                        closestDiff = diff;
                        closestIdx = i;
                    }
                }

                // Extract words before and after
                const startIdx = Math.max(0, closestIdx - wordsBefore);
                const endIdx = Math.min(wordData.length, closestIdx + wordsAfter + 1);

                const contextWords = wordData.slice(startIdx, endIdx).map(w => w.word);
                return contextWords.join(' ');
            };

            // Function to extract extended context words from transcript (for AI enhancement)
            const getExtendedTranscriptContext = (transcript, timestamp, wordsBefore = 75, wordsAfter = 75) => {
                if (!transcript || transcript.length === 0) return '';

                // Build full text with word positions mapped to timestamps
                const wordData = [];
                transcript.forEach(segment => {
                    const words = segment.text.split(/\s+/).filter(w => w.trim());
                    const segmentDuration = segment.duration || 2;
                    const timePerWord = segmentDuration / Math.max(words.length, 1);

                    words.forEach((word, idx) => {
                        wordData.push({
                            word: word,
                            timestamp: segment.start + (idx * timePerWord)
                        });
                    });
                });

                if (wordData.length === 0) return '';

                // Find the word closest to the current timestamp
                let closestIdx = 0;
                let closestDiff = Math.abs(wordData[0]?.timestamp - timestamp) || Infinity;

                for (let i = 1; i < wordData.length; i++) {
                    const diff = Math.abs(wordData[i].timestamp - timestamp);
                    if (diff < closestDiff) {
                        closestDiff = diff;
                        closestIdx = i;
                    }
                }

                // Extract more words before and after for complete thought capture
                const startIdx = Math.max(0, closestIdx - wordsBefore);
                const endIdx = Math.min(wordData.length, closestIdx + wordsAfter + 1);

                const contextWords = wordData.slice(startIdx, endIdx).map(w => w.word);
                return contextWords.join(' ');
            };

            // Function to load transcript context into note field
            const handleLoadContext = async () => {
                // Use displayVideo to support both regular and shared videos
                const video = activeSharedVideo || videos.find(v => v.id === activeVideoId);
                if (!video) return;

                // Get the YouTube video ID - shared videos use youtubeVideoId, regular videos use videoId
                const ytVideoId = activeSharedVideo ? video.youtubeVideoId : video.videoId;

                setIsLoadingContext(true);

                try {
                    // Use cached transcript or fetch new one
                    let transcript = cachedTranscript;
                    if (!transcript || cachedTranscript?.videoId !== ytVideoId) {
                        transcript = await fetchTranscript(ytVideoId);
                        if (transcript) {
                            setCachedTranscript({ videoId: ytVideoId, data: transcript });
                            transcript = transcript;
                        }
                    } else {
                        transcript = cachedTranscript.data;
                    }

                    if (!transcript || transcript.length === 0) {
                        setNewNote('[No transcript available for this video]');
                        return;
                    }

                    const context = getTranscriptContext(transcript, currentTime, contextWordCount, contextWordCount);
                    if (context) {
                        setNewNote(context);
                    } else {
                        setNewNote('[Could not find transcript at this timestamp]');
                    }
                } catch (error) {
                    console.error('Error loading transcript context:', error);
                    // Provide helpful error message based on error type
                    if (error.message?.includes('rate limit') || error.message?.includes('empty responses')) {
                        setNewNote('[YouTube rate limited. Please try again in a few minutes.]');
                    } else if (error.message?.includes('No captions')) {
                        setNewNote('[This video does not have captions/subtitles available]');
                    } else {
                        setNewNote('[Error loading transcript. Make sure the transcript server is running.]');
                    }
                } finally {
                    setIsLoadingContext(false);
                }
            };

            const activeVideo = videos.find(v => v.id === activeVideoId);

            // Computed video for player - either regular or shared video
            const displayVideo = activeSharedVideo ? {
                id: activeSharedVideo.shareId,
                videoId: activeSharedVideo.youtubeVideoId,
                title: activeSharedVideo.videoTitle,
                thumbnail: activeSharedVideo.videoThumbnail,
                notes: activeSharedVideo.notes || [],
                isShared: true,
                sharedFrom: activeSharedVideo.fromUsername
            } : activeVideo;

            // Filter videos
            const filteredVideos = videos.filter(video => {
                const matchesSearch = searchQuery === '' ||
                    video.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
                    video.tags?.some(t => t.toLowerCase().includes(searchQuery.toLowerCase())) ||
                    video.notes?.some(n => n.text.toLowerCase().includes(searchQuery.toLowerCase()));
                const matchesCategory = selectedCategory === 'all' || video.category === selectedCategory;
                return matchesSearch && matchesCategory;
            });

            const sortedVideos = [...filteredVideos].sort((a, b) => {
                if (sortBy === 'date-desc') {
                    if (!a.publishDate && !b.publishDate) return 0;
                    if (!a.publishDate) return 1;
                    if (!b.publishDate) return -1;
                    return b.publishDate.localeCompare(a.publishDate);
                }
                if (sortBy === 'date-asc') {
                    if (!a.publishDate && !b.publishDate) return 0;
                    if (!a.publishDate) return 1;
                    if (!b.publishDate) return -1;
                    return a.publishDate.localeCompare(b.publishDate);
                }
                return 0; // default
            });

            // Video handlers
            const handleAddVideo = (video) => {
                setVideos(prev => [...prev, video]);
            };

            const handleDeleteVideo = (id) => {
                setVideos(prev => prev.filter(v => v.id !== id));
                if (activeVideoId === id) setActiveVideoId(null);
            };

            const handleEditVideo = (videoId) => {
                const video = videos.find(v => v.id === videoId);
                if (video) {
                    setEditingVideo(video);
                    setShowEditModal(true);
                }
            };

            const handleSaveEditedVideo = (updates) => {
                setVideos(prev => prev.map(v =>
                    v.id === editingVideo.id
                        ? { ...v, ...updates }
                        : v
                ));
                setShowEditModal(false);
                setEditingVideo(null);
            };

            // Increment view count when video is opened
            const incrementViewCount = (videoId) => {
                setVideos(prev => prev.map(v =>
                    v.id === videoId
                        ? { ...v, viewCount: (v.viewCount || 0) + 1 }
                        : v
                ));
            };

            // Select video and increment view count
            const handleSelectVideo = (videoId) => {
                incrementViewCount(videoId);
                setActiveVideoId(videoId);
                setActiveSharedVideo(null);
                setShowLibrary(false);
                setShowSharedWithMe(false);
                setNoteSearch('');
            };

            const handleRefresh = async () => {
                if (!authToken) {
                    console.log('⚠️ Cannot refresh: not authenticated');
                    return;
                }

                setIsRefreshing(true);
                try {
                    // Try to load bookmarks from server
                    const response = await fetch(`${SERVER_URL}/bookmarks`, {
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });
                    if (response.ok) {
                        const serverData = await response.json();
                        if (Array.isArray(serverData)) {
                            // Apply migration for multi-source video support
                            const migratedData = migrateVideosArray(serverData);
                            setVideos(migratedData);
                            console.log('✅ Refreshed bookmarks from server:', migratedData.length);
                        }
                    } else if (response.status === 401) {
                        setShowAuthModal(true);
                        setIsAuthenticated(false);
                    }

                    // Also refresh categories
                    const catResponse = await fetch(`${SERVER_URL}/categories`, {
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });
                    if (catResponse.ok) {
                        const serverCategories = await catResponse.json();
                        if (Array.isArray(serverCategories)) {
                            setCategories(serverCategories);
                            console.log('✅ Refreshed categories from server:', serverCategories.length);
                        }
                    }
                } catch (e) {
                    console.log('Could not refresh from server:', e.message);
                }

                setIsRefreshing(false);
            };

            const handleFetchPublishDate = async (videoId, videoYoutubeId) => {
                if (!apiStatus.youtubeConfigured) {
                    alert('YouTube API is not configured on the server. Please contact the administrator.');
                    setFetchingDateFor(null);
                    return;
                }

                setFetchingDateFor(videoId);
                try {
                    const response = await fetch(
                        `${SERVER_URL}/api/youtube/video?id=${videoYoutubeId}`,
                        { headers: { 'Authorization': `Bearer ${authToken}` } }
                    );
                    const data = await response.json();
                    console.log('YouTube API response:', data);

                    if (data.error) {
                        console.error('YouTube API error:', data.error);
                        alert(`Error: ${data.error}`);
                        setFetchingDateFor(null);
                        return;
                    }

                    const updates = {};
                    if (data.publishedAt) {
                        updates.publishDate = data.publishedAt.split('T')[0];
                        console.log('✅ Publish date fetched:', updates.publishDate);
                    }
                    if (data.description) {
                        updates.description = data.description;
                        console.log('✅ Description fetched:', data.description.substring(0, 100) + '...');
                    }
                    if (data.thumbnails?.maxres?.url || data.thumbnails?.high?.url) {
                        updates.thumbnail = data.thumbnails.maxres?.url || data.thumbnails.high.url;
                    }

                    if (Object.keys(updates).length > 0) {
                        setVideos(prev => prev.map(v =>
                            v.id === videoId ? { ...v, ...updates } : v
                        ));
                    } else {
                        console.error('No metadata found in YouTube API response');
                        alert('Could not fetch details for this video');
                    }
                } catch (err) {
                    console.error('Failed to fetch video details:', err);
                    alert('Failed to fetch video details: ' + err.message);
                } finally {
                    setFetchingDateFor(null);
                }
            };

            // Note handlers
            const handleAddNote = () => {
                if (!newNote.trim()) return;

                // Get author info (first 3 letters of username, uppercase)
                const authorShort = currentUser?.username?.substring(0, 3).toUpperCase() || 'USR';
                const authorFull = currentUser?.username || 'Unknown';

                const newNoteObj = {
                    id: generateId(),
                    text: newNote.trim(),
                    timestamp: currentTime,
                    createdAt: new Date().toISOString(),
                    author: authorShort,
                    authorFull: authorFull
                };

                // Handle shared videos
                if (activeSharedVideo) {
                    const updatedNotes = [...(activeSharedVideo.notes || []), newNoteObj].sort((a, b) => b.timestamp - a.timestamp);
                    const updatedSharedVideo = { ...activeSharedVideo, notes: updatedNotes };

                    setSharedWithMe(prev => prev.map(shared =>
                        shared.shareId === activeSharedVideo.shareId ? updatedSharedVideo : shared
                    ));
                    setActiveSharedVideo(updatedSharedVideo);
                    // Save updated shared videos to server
                    saveSharedVideosToServer(activeSharedVideo.shareId, updatedNotes);
                    setNewNote('');
                    return;
                }

                // Handle regular videos
                if (!activeVideoId) return;
                setVideos(prev => prev.map(video => {
                    if (video.id === activeVideoId) {
                        return {
                            ...video,
                            notes: [...(video.notes || []), newNoteObj].sort((a, b) => b.timestamp - a.timestamp)
                        };
                    }
                    return video;
                }));
                setNewNote('');
            };

            // Save shared video notes to server
            const saveSharedVideosToServer = async (shareId, notes) => {
                if (!authToken || !shareId) return;
                try {
                    const response = await fetch(`${SERVER_URL}/api/shares/library`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify({ shareId, notes })
                    });
                    if (response.ok) {
                        console.log('✅ Shared video notes saved to server');
                    } else {
                        console.warn('⚠️ Failed to save shared video notes to server');
                    }
                } catch (e) {
                    console.error('❌ Error saving shared video notes:', e.message);
                }
            };

            const handleDeleteNote = (noteId) => {
                // Handle shared videos
                if (activeSharedVideo) {
                    const updatedNotes = (activeSharedVideo.notes || []).filter(n => n.id !== noteId);
                    const updatedSharedVideo = { ...activeSharedVideo, notes: updatedNotes };

                    setSharedWithMe(prev => prev.map(shared =>
                        shared.shareId === activeSharedVideo.shareId ? updatedSharedVideo : shared
                    ));
                    setActiveSharedVideo(updatedSharedVideo);
                    saveSharedVideosToServer(activeSharedVideo.shareId, updatedNotes);
                    return;
                }

                // Handle regular videos
                setVideos(prev => prev.map(video => {
                    if (video.id === activeVideoId) {
                        return {
                            ...video,
                            notes: video.notes.filter(n => n.id !== noteId)
                        };
                    }
                    return video;
                }));
            };

            const handleEditNote = (noteId, newText) => {
                // Handle shared videos
                if (activeSharedVideo) {
                    const updatedNotes = (activeSharedVideo.notes || []).map(n =>
                        n.id === noteId ? { ...n, text: newText } : n
                    ).sort((a, b) => b.timestamp - a.timestamp);
                    const updatedSharedVideo = { ...activeSharedVideo, notes: updatedNotes };

                    setSharedWithMe(prev => prev.map(shared =>
                        shared.shareId === activeSharedVideo.shareId ? updatedSharedVideo : shared
                    ));
                    setActiveSharedVideo(updatedSharedVideo);
                    saveSharedVideosToServer(activeSharedVideo.shareId, updatedNotes);
                    return;
                }

                // Handle regular videos
                setVideos(prev => prev.map(video => {
                    if (video.id === activeVideoId) {
                        return {
                            ...video,
                            notes: video.notes.map(n =>
                                n.id === noteId ? { ...n, text: newText } : n
                            ).sort((a, b) => b.timestamp - a.timestamp)
                        };
                    }
                    return video;
                }));
            };

            const handleExportNotes = (video) => {
                if (!video || !video.notes || video.notes.length === 0) {
                    alert('No notes to export for this video');
                    return;
                }

                // Sort notes by timestamp (oldest to newest for export)
                const sortedNotes = [...video.notes].sort((a, b) => a.timestamp - b.timestamp);

                // Build export text
                let exportText = `${video.title}\n`;
                if (video.publishDate) {
                    exportText += `Published: ${formatPublishDate(video.publishDate)}\n`;
                }
                exportText += `\n---\n\n`;

                sortedNotes.forEach((note, index) => {
                    const timestamp = formatTime(note.timestamp);
                    exportText += `[${timestamp}] ${note.text}\n\n`;
                });

                // Download as text file
                const blob = new Blob([exportText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const filename = video.title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                a.download = `${filename}_notes.txt`;
                a.click();
                URL.revokeObjectURL(url);
            };

            // Export notes as Markdown file
            const handleExportMarkdown = (video) => {
                if (!video || !video.notes || video.notes.length === 0) {
                    alert('No notes to export for this video');
                    return;
                }

                // Sort notes by timestamp (oldest to newest for export)
                const sortedNotes = [...video.notes].sort((a, b) => a.timestamp - b.timestamp);

                // Build markdown content
                let markdown = `# ${video.title}\n\n`;
                if (video.publishDate) {
                    markdown += `**Published:** ${formatPublishDate(video.publishDate)}\n`;
                }
                // Get source-aware video URL
                const videoUrl = (() => {
                    const id = video.sourceId || video.videoId;
                    switch (video.sourceType) {
                        case 'vimeo': return `https://vimeo.com/${id}`;
                        case 'loom': return `https://www.loom.com/share/${id}`;
                        case 'googledrive': return `https://drive.google.com/file/d/${id}/view`;
                        case 'wistia': return `https://home.wistia.com/medias/${id}`;
                        case 'direct': return video.sourceUrl;
                        case 'youtube':
                        default: return `https://youtube.com/watch?v=${id}`;
                    }
                })();
                markdown += `**Video:** ${videoUrl}\n\n`;
                markdown += `---\n\n`;
                markdown += `## Notes\n\n`;

                sortedNotes.forEach((note) => {
                    const timestamp = formatTime(note.timestamp);
                    markdown += `### [${timestamp}]\n`;
                    // Handle bullet points - if note already has bullets, use as-is, otherwise wrap
                    if (note.text.trim().startsWith('-')) {
                        markdown += `${note.text}\n\n`;
                    } else {
                        markdown += `- ${note.text}\n\n`;
                    }
                });

                markdown += `---\n\n`;
                markdown += `*Exported from ClipMark on ${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}*\n`;

                // Download as markdown file
                const blob = new Blob([markdown], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const filename = video.title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                a.download = `${filename}_notes.md`;
                a.click();
                URL.revokeObjectURL(url);
            };

            // Handle transcript upload for current video
            const handleTranscriptUpload = (transcript) => {
                if (!activeVideoId || !transcript) return;

                const updatedVideos = videos.map(v => {
                    if (v.id === activeVideoId) {
                        return { ...v, transcript };
                    }
                    return v;
                });

                setVideos(updatedVideos);
                console.log(`✅ Transcript saved for video: ${activeVideoId}`);
            };

            // Enhance all notes with AI summarization
            const handleEnhanceAllNotes = async () => {
                // Support both regular videos and shared videos
                const video = activeSharedVideo || videos.find(v => v.id === activeVideoId);
                const isShared = !!activeSharedVideo;

                if (!video || !video.notes || video.notes.length === 0) {
                    alert('No notes to enhance for this video');
                    return;
                }

                if (!apiStatus.geminiConfigured) {
                    alert('Gemini API is not configured on the server. Please contact the administrator.');
                    return;
                }

                // Get the YouTube video ID - shared videos use youtubeVideoId, regular videos use videoId
                const ytVideoId = isShared ? video.youtubeVideoId : video.videoId;

                setIsEnhancing(true);
                setEnhancementProgress({ current: 0, total: video.notes.length });

                try {
                    // Fetch transcript
                    let transcript = cachedTranscript?.data;
                    if (!transcript || cachedTranscript?.videoId !== ytVideoId) {
                        transcript = await fetchTranscript(ytVideoId);
                        if (transcript) {
                            setCachedTranscript({ videoId: ytVideoId, data: transcript });
                        }
                    }

                    if (!transcript || transcript.length === 0) {
                        alert('Could not fetch transcript for this video. Enhancement requires transcript data.');
                        setIsEnhancing(false);
                        return;
                    }

                    const enhancedNotes = [];
                    const ambiguousNotes = [];

                    // Process each note
                    for (let i = 0; i < video.notes.length; i++) {
                        const note = video.notes[i];
                        setEnhancementProgress({ current: i + 1, total: video.notes.length });

                        try {
                            // Get extended context around the note timestamp
                            const context = getExtendedTranscriptContext(transcript, note.timestamp, 75, 75);

                            if (!context) {
                                // No context available, keep original
                                enhancedNotes.push({ ...note });
                                continue;
                            }

                            // Call AI to summarize with retry logic
                            let result = null;
                            let retries = 3;
                            while (retries > 0 && !result) {
                                try {
                                    result = await summarizeNoteWithContext(context, note.text, SERVER_URL, authToken);
                                } catch (apiError) {
                                    retries--;
                                    if (retries > 0) {
                                        // Wait with exponential backoff
                                        await new Promise(resolve => setTimeout(resolve, 1000 * (4 - retries)));
                                    } else {
                                        console.error(`Failed to enhance note at ${formatTime(note.timestamp)}:`, apiError);
                                        enhancedNotes.push({ ...note }); // Keep original on failure
                                        continue;
                                    }
                                }
                            }

                            if (result) {
                                if (result.isAmbiguous && result.alternatives) {
                                    // Flag for review
                                    ambiguousNotes.push({
                                        noteId: note.id,
                                        timestamp: note.timestamp,
                                        originalText: note.text,
                                        context: context.substring(0, 200) + '...', // Truncate for display
                                        suggestedSummary: result.summary,
                                        alternatives: result.alternatives,
                                        selectedOption: 0 // Default to first option (the suggestion)
                                    });
                                    enhancedNotes.push({ ...note }); // Keep original for now
                                } else {
                                    // Direct replacement - store original text
                                    enhancedNotes.push({
                                        ...note,
                                        text: result.summary,
                                        enhanced: true,
                                        originalText: note.originalText || note.text // Preserve if already enhanced
                                    });
                                }
                            } else {
                                enhancedNotes.push({ ...note });
                            }

                            // Rate limiting delay between API calls
                            await new Promise(resolve => setTimeout(resolve, 500));

                        } catch (error) {
                            console.error(`Error enhancing note at ${formatTime(note.timestamp)}:`, error);
                            enhancedNotes.push({ ...note }); // Keep original on error
                        }
                    }

                    // Update video with enhanced notes (non-ambiguous ones)
                    if (isShared) {
                        // Update shared video
                        const updatedSharedVideo = { ...video, notes: enhancedNotes };
                        setSharedWithMe(prev => prev.map(shared =>
                            shared.shareId === video.shareId ? updatedSharedVideo : shared
                        ));
                        setActiveSharedVideo(updatedSharedVideo);
                        saveSharedVideosToServer(video.shareId, enhancedNotes);
                    } else {
                        // Update regular video
                        const updatedVideos = videos.map(v => {
                            if (v.id === activeVideoId) {
                                return { ...v, notes: enhancedNotes };
                            }
                            return v;
                        });
                        setVideos(updatedVideos);
                    }

                    // If there are ambiguous notes, show review modal
                    if (ambiguousNotes.length > 0) {
                        setPendingEnhancements(ambiguousNotes);
                        setShowEnhancementReview(true);
                    }

                    console.log(`✅ Enhanced ${video.notes.length - ambiguousNotes.length} notes, ${ambiguousNotes.length} need review`);

                } catch (error) {
                    console.error('Enhancement failed:', error);
                    alert(`Enhancement failed: ${error.message}`);
                } finally {
                    setIsEnhancing(false);
                    setEnhancementProgress({ current: 0, total: 0 });
                }
            };

            // Apply selected enhancements from review modal
            const handleApplyEnhancements = (selections) => {
                // Support both regular and shared videos
                const video = activeSharedVideo || videos.find(v => v.id === activeVideoId);
                const isShared = !!activeSharedVideo;

                if (!video) return;

                const updatedNotes = video.notes.map(note => {
                    const selection = selections.find(s => s.noteId === note.id);
                    if (selection) {
                        // Only mark as enhanced if text actually changed
                        const isChanged = selection.selectedText !== note.text;
                        return {
                            ...note,
                            text: selection.selectedText,
                            enhanced: isChanged ? true : note.enhanced,
                            originalText: isChanged ? (note.originalText || note.text) : note.originalText
                        };
                    }
                    return note;
                });

                if (isShared) {
                    // Update shared video
                    const updatedSharedVideo = { ...video, notes: updatedNotes };
                    setSharedWithMe(prev => prev.map(shared =>
                        shared.shareId === video.shareId ? updatedSharedVideo : shared
                    ));
                    setActiveSharedVideo(updatedSharedVideo);
                    saveSharedVideosToServer(video.shareId, updatedNotes);
                } else {
                    // Update regular video
                    const updatedVideos = videos.map(v => {
                        if (v.id === activeVideoId) {
                            return { ...v, notes: updatedNotes };
                        }
                        return v;
                    });
                    setVideos(updatedVideos);
                }

                setPendingEnhancements([]);
                setShowEnhancementReview(false);
            };

            // Parse timestamp string like "1:23" or "1:23:45" to seconds
            const parseTimestamp = (timeStr) => {
                const parts = timeStr.split(':').map(Number);
                if (parts.length === 3) {
                    return parts[0] * 3600 + parts[1] * 60 + parts[2];
                } else if (parts.length === 2) {
                    return parts[0] * 60 + parts[1];
                }
                return 0;
            };

            const handleImportNotes = (video) => {
                if (!video) {
                    alert('Please select a video first');
                    return;
                }

                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.txt';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const content = event.target.result;
                        // Handle Windows (\r\n) and Unix (\n) line endings
                        const lines = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
                        const importedNotes = [];

                        // Parse each line looking for [timestamp] text pattern
                        // Supports formats: [0:30], [1:23:45], with optional spaces
                        for (let line of lines) {
                            line = line.trim();
                            // More flexible regex: allows spaces, handles various timestamp formats
                            const match = line.match(/^\[(\d{1,2}:\d{2}(?::\d{2})?)\]\s*(.+)$/);
                            if (match) {
                                const timestamp = parseTimestamp(match[1]);
                                const text = match[2].trim();
                                if (text) {
                                    importedNotes.push({
                                        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                                        text: text,
                                        timestamp: timestamp,
                                        createdAt: new Date().toISOString(),
                                        imported: true
                                    });
                                }
                            }
                        }

                        if (importedNotes.length === 0) {
                            alert('No valid notes found in file. Expected format:\n[0:30] Note text here');
                            return;
                        }

                        // Ask user whether to merge or replace
                        const existingCount = video.notes?.length || 0;
                        let shouldMerge = true;
                        if (existingCount > 0) {
                            shouldMerge = confirm(
                                `Found ${importedNotes.length} notes to import.\n\n` +
                                `This video has ${existingCount} existing notes.\n\n` +
                                `Click OK to MERGE (add to existing notes)\n` +
                                `Click Cancel to REPLACE (delete existing notes)`
                            );
                        }

                        setVideos(prev => prev.map(v => {
                            if (v.id === video.id) {
                                const newNotes = shouldMerge
                                    ? [...(v.notes || []), ...importedNotes]
                                    : importedNotes;
                                // Sort by timestamp
                                newNotes.sort((a, b) => a.timestamp - b.timestamp);
                                return { ...v, notes: newNotes };
                            }
                            return v;
                        }));

                        alert(`Successfully imported ${importedNotes.length} notes${shouldMerge && existingCount > 0 ? ' (merged with existing)' : ''}`);
                    };
                    reader.readAsText(file);
                };
                input.click();
            };

            const handleSeek = (timestamp) => {
                if (playerRef.current && playerRef.current.seekTo) {
                    playerRef.current.seekTo(timestamp, true);
                }
            };

            // Category handlers
            const handleAddCategory = (category) => {
                setCategories(prev => [...prev, category]);
            };

            const handleEditCategory = (id, newName) => {
                setCategories(prev => prev.map(c =>
                    c.id === id ? { ...c, name: newName } : c
                ));
                console.log('✅ Updated category:', id, 'to', newName);
            };

            const handleDeleteCategory = (id) => {
                setCategories(prev => prev.filter(c => c.id !== id));
                setVideos(prev => prev.map(v =>
                    v.category === id ? { ...v, category: '' } : v
                ));
            };

            // Export/Import
            const handleExport = async () => {
                try {
                    if (isAuthenticated && authToken) {
                        // Server-side export
                        const response = await fetch(`${SERVER_URL}/api/backup/export`, {
                            headers: { 'Authorization': `Bearer ${authToken}` }
                        });
                        if (response.ok) {
                            const blob = await response.blob();
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `clipmark-backup-${new Date().toISOString().split('T')[0]}.json`;
                            a.click();
                            URL.revokeObjectURL(url);
                            return;
                        }
                    }
                } catch (err) {
                    console.warn('⚠️ Server export failed, falling back to client-side:', err.message);
                }

                // Fallback: client-side export
                const noteCount = videos.reduce((sum, v) => sum + (v.notes?.length || 0), 0);
                const data = {
                    clipmark_backup: true,
                    version: 1,
                    exportedAt: new Date().toISOString(),
                    username: currentUser?.username || 'unknown',
                    stats: {
                        videoCount: videos.length,
                        noteCount,
                        categoryCount: categories.length
                    },
                    data: { bookmarks: videos, categories }
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `clipmark-backup-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            };

            const handleImport = (e) => {
                const file = e.target.files?.[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        setImportData(data);
                        setImportFileName(file.name);
                        setShowImportModal(true);
                    } catch (err) {
                        setImportData({});
                        setImportFileName(file.name);
                        setShowImportModal(true);
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            };

            const handleImportComplete = async () => {
                try {
                    if (isAuthenticated && authToken) {
                        const [bookmarksRes, categoriesRes] = await Promise.all([
                            fetch(`${SERVER_URL}/bookmarks`, {
                                headers: { 'Authorization': `Bearer ${authToken}` }
                            }),
                            fetch(`${SERVER_URL}/categories`, {
                                headers: { 'Authorization': `Bearer ${authToken}` }
                            })
                        ]);
                        if (bookmarksRes.ok) {
                            const bookmarks = await bookmarksRes.json();
                            if (Array.isArray(bookmarks)) setVideos(bookmarks);
                        }
                        if (categoriesRes.ok) {
                            const cats = await categoriesRes.json();
                            if (Array.isArray(cats)) setCategories(cats);
                        }
                    }
                } catch (err) {
                    console.error('❌ Error reloading data after import:', err.message);
                }
            };

            // Show loading screen while checking authentication
            if (authLoading) {
                return (
                    <div className="h-screen flex items-center justify-center bg-gray-900">
                        <div className="text-center">
                            <svg className="animate-spin h-12 w-12 text-emerald-500 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <p className="text-gray-400">Loading...</p>
                        </div>
                    </div>
                );
            }

            // Show auth modal if not authenticated
            if (showAuthModal && !isAuthenticated) {
                // Show share preview landing page if there's a pending share
                if (pendingShareToken && (sharePreview || sharePreviewError)) {
                    return (
                        <div className="min-h-screen bg-gray-900 flex items-center justify-center p-4">
                            <div className="max-w-md w-full">
                                {/* Logo */}
                                <div className="text-center mb-8">
                                    <div className="flex items-center justify-center gap-3 mb-2">
                                        <img src="logos/clipmark-favicon.svg" alt="ClipMark" className="w-12 h-12" />
                                        <h1 className="text-3xl font-bold text-emerald-500">ClipMark</h1>
                                    </div>
                                    <p className="text-gray-400">Mark the moments that matter</p>
                                </div>

                                {sharePreviewError ? (
                                    /* Error State */
                                    <div className="bg-gray-800 rounded-xl p-6 text-center">
                                        <div className="w-16 h-16 bg-red-500/20 rounded-full flex items-center justify-center mx-auto mb-4">
                                            <svg className="w-8 h-8 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                                            </svg>
                                        </div>
                                        <h2 className="text-xl font-semibold text-gray-200 mb-2">Share Link Invalid</h2>
                                        <p className="text-gray-400 mb-6">{sharePreviewError}</p>
                                        <button
                                            onClick={() => {
                                                setPendingShareToken(null);
                                                setSharePreviewError(null);
                                                window.history.replaceState({}, document.title, window.location.pathname);
                                            }}
                                            className="px-6 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors"
                                        >
                                            Go to Login
                                        </button>
                                    </div>
                                ) : sharePreview && (
                                    /* Share Preview */
                                    <div className="bg-gray-800 rounded-xl overflow-hidden">
                                        <div className="p-4 bg-gradient-to-r from-emerald-500/20 to-blue-500/20 border-b border-gray-700">
                                            <p className="text-center text-gray-200">
                                                <span className="text-emerald-400 font-semibold">{sharePreview.ownerUsername}</span>
                                                {' '}wants to share a video with you!
                                            </p>
                                        </div>

                                        {/* Video Preview */}
                                        <div className="p-4">
                                            <div className="relative rounded-lg overflow-hidden mb-4">
                                                <img
                                                    src={sharePreview.videoThumbnail}
                                                    alt={sharePreview.videoTitle}
                                                    className="w-full aspect-video object-cover"
                                                />
                                                <div className="absolute inset-0 bg-black/40 flex items-center justify-center">
                                                    <div className="w-16 h-16 bg-red-600 rounded-full flex items-center justify-center">
                                                        <svg className="w-8 h-8 text-white ml-1" fill="currentColor" viewBox="0 0 24 24">
                                                            <path d="M8 5v14l11-7z" />
                                                        </svg>
                                                    </div>
                                                </div>
                                            </div>

                                            <h3 className="font-semibold text-gray-200 mb-2">{sharePreview.videoTitle}</h3>

                                            {sharePreview.includeNotes && sharePreview.noteCount > 0 && (
                                                <p className="text-sm text-gray-400 flex items-center gap-2">
                                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                                                    </svg>
                                                    Includes {sharePreview.noteCount} notes
                                                </p>
                                            )}
                                        </div>

                                        {/* CTA */}
                                        <div className="p-4 bg-gray-700/50 border-t border-gray-700">
                                            <p className="text-sm text-gray-400 text-center mb-4">
                                                Sign up or log in to accept this shared video
                                            </p>
                                            <AuthModal
                                                isOpen={true}
                                                onLogin={handleLogin}
                                                serverUrl={SERVER_URL}
                                                embedded={true}
                                            />
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    );
                }

                return (
                    <AuthModal
                        isOpen={true}
                        onLogin={handleLogin}
                        serverUrl={SERVER_URL}
                    />
                );
            }

            // Show admin dashboard if on admin route
            if (isAdminRoute && isAuthenticated) {
                return (
                    <AdminDashboard
                        serverUrl={SERVER_URL}
                        authToken={authToken}
                        onLogout={handleLogout}
                        username={currentUser?.username}
                    />
                );
            }

            return (
                <div className="h-screen flex flex-col">
                    {/* Header */}
                    <header className="bg-gray-800 border-b border-gray-700 px-4 py-3 flex items-center justify-between shrink-0">
                        <div className="flex items-center gap-3">
                            <div className="flex items-center gap-3">
                                {/* ClipMark Logo */}
                                <img src="logos/clipmark-favicon.svg" alt="ClipMark" className="w-10 h-10" />
                                <h1 className="text-2xl font-bold text-emerald-500">ClipMark</h1>
                            </div>
                        </div>
                        <div className="flex items-center gap-2">
                            <button
                                onClick={() => setShowLibrary(!showLibrary)}
                                className={`p-2 rounded-lg transition-colors ${showLibrary ? 'bg-emerald-500 text-white' : 'bg-gray-700 hover:bg-gray-600'}`}
                                title="Toggle Library"
                            >
                                <Icons.Grid />
                            </button>
                            <button
                                onClick={handleExport}
                                className="p-2 bg-gray-700 hover:bg-gray-600 rounded-lg"
                                title="Export Backup"
                            >
                                <Icons.Download />
                            </button>
                            <button
                                onClick={() => fileInputRef.current?.click()}
                                className="p-2 bg-gray-700 hover:bg-gray-600 rounded-lg"
                                title="Import Backup"
                            >
                                <Icons.Upload />
                            </button>
                            <input
                                ref={fileInputRef}
                                type="file"
                                accept=".json"
                                onChange={handleImport}
                                className="hidden"
                            />
                            {/* Pending Shares Notification */}
                            <PendingSharesDropdown
                                serverUrl={SERVER_URL}
                                authToken={authToken}
                                onAcceptShare={reloadSharedVideos}
                            />
                            <button
                                onClick={() => setShowSettingsModal(true)}
                                className={`p-2 rounded-lg transition-colors ${apiStatus.geminiConfigured ? 'bg-gray-700 hover:bg-gray-600' : 'bg-yellow-600 hover:bg-yellow-700'}`}
                                title={apiStatus.geminiConfigured ? 'Settings' : 'Gemini AI not configured'}
                            >
                                <Icons.Settings />
                            </button>
                            <button
                                onClick={handleRefresh}
                                disabled={isRefreshing}
                                className="p-2 bg-gray-700 hover:bg-gray-600 disabled:bg-gray-600 disabled:cursor-not-allowed rounded-lg transition-colors"
                                title="Refresh bookmarks from server"
                            >
                                {isRefreshing ? (
                                    <svg className="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                ) : (
                                    <Icons.Refresh />
                                )}
                            </button>
                            <div className="flex items-center gap-2 text-sm px-3 py-2 rounded-lg">
                                {saveStatus === 'saving' && (
                                    <span className="text-yellow-400 animate-pulse">💾 Saving...</span>
                                )}
                                {saveStatus === 'saved' && lastSaveTime && (
                                    <span className="text-green-400">✓ Saved</span>
                                )}
                                {saveStatus === 'error' && (
                                    <span className="text-emerald-400">⚠️ Save failed</span>
                                )}
                            </div>
                            {/* Admin link for admin users */}
                            {isAdmin && (
                                <a
                                    href="/admin"
                                    className="p-2 bg-purple-500/20 hover:bg-purple-500/30 text-purple-400 rounded-lg transition-colors"
                                    title="Admin Dashboard"
                                >
                                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                                    </svg>
                                </a>
                            )}
                            {/* User info and logout */}
                            {currentUser && (
                                <div className="flex items-center gap-2 px-3 py-1 bg-gray-700 rounded-lg">
                                    <svg className="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                                    </svg>
                                    <span className="text-sm text-gray-300">{currentUser.username}</span>
                                    {isAdmin && (
                                        <span className="px-1.5 py-0.5 bg-purple-500/20 text-purple-400 text-xs rounded">Admin</span>
                                    )}
                                    <button
                                        onClick={handleLogout}
                                        className="ml-1 p-1 text-gray-400 hover:text-emerald-400 transition-colors"
                                        title="Logout"
                                    >
                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                                        </svg>
                                    </button>
                                </div>
                            )}
                            <button
                                onClick={() => setShowAddModal(true)}
                                className="flex items-center gap-2 bg-emerald-500 hover:bg-emerald-600 px-4 py-2 rounded-lg font-medium transition-colors"
                            >
                                <Icons.Plus />
                                Add Video
                            </button>
                        </div>
                    </header>

                    {/* Storage Warning Banner */}
                    {!storageAvailable && (
                        <div className="bg-red-900/90 text-white px-4 py-4 border-b border-red-800 flex items-center justify-between gap-4">
                            <div>
                                <p className="font-semibold">⚠️ Storage Unavailable</p>
                                <p className="text-sm text-red-100">Private browsing mode detected. Your bookmarks cannot be saved. Please use normal browsing mode or download your data regularly.</p>
                            </div>
                            <button
                                onClick={handleExport}
                                className="flex-shrink-0 bg-white text-red-900 font-medium px-4 py-2 rounded-lg hover:bg-red-50 transition-colors whitespace-nowrap"
                            >
                                Download Data Now
                            </button>
                        </div>
                    )}

                    <div className="flex flex-1 overflow-hidden">
                        {/* Sidebar */}
                        <aside className="w-64 bg-gray-800 border-r border-gray-700 flex flex-col shrink-0">
                            {/* Search */}
                            <div className="p-4">
                                <div className="relative">
                                    <input
                                        type="text"
                                        value={searchQuery}
                                        onChange={(e) => setSearchQuery(e.target.value)}
                                        placeholder="Search videos & notes..."
                                        className="w-full bg-gray-700 rounded-lg pl-10 pr-4 py-2 text-sm placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                    />
                                    <div className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400">
                                        <Icons.Search />
                                    </div>
                                </div>
                            </div>

                            {/* Categories */}
                            <div className="px-4 pb-2">
                                <div className="flex items-center justify-between mb-2">
                                    <h3 className="text-sm font-medium text-gray-400">Categories</h3>
                                    <button
                                        onClick={() => setShowCategoryModal(true)}
                                        className="p-1 hover:bg-gray-700 rounded text-gray-400 hover:text-gray-200"
                                    >
                                        <Icons.Plus />
                                    </button>
                                </div>
                                <div className="space-y-1">
                                    <button
                                        onClick={() => {
                                            setSelectedCategory('all');
                                            setShowSharedWithMe(false);
                                        }}
                                        className={`w-full flex items-center gap-2 px-3 py-2 rounded-lg text-sm transition-colors ${
                                            selectedCategory === 'all' && !showSharedWithMe ? 'bg-emerald-500/20 text-emerald-400' : 'hover:bg-gray-700'
                                        }`}
                                    >
                                        <Icons.Folder />
                                        All Videos
                                        <span className="ml-auto text-xs text-gray-500">{videos.length}</span>
                                    </button>
                                    {/* Shared with me button */}
                                    <button
                                        onClick={() => {
                                            setShowSharedWithMe(true);
                                            setShowLibrary(true);
                                        }}
                                        className={`w-full flex items-center gap-2 px-3 py-2 rounded-lg text-sm transition-colors ${
                                            showSharedWithMe ? 'bg-blue-500/20 text-blue-400' : 'hover:bg-gray-700'
                                        }`}
                                    >
                                        <Icons.Users />
                                        Shared with me
                                        {sharedWithMe.length > 0 && (
                                            <span className="ml-auto text-xs text-gray-500">{sharedWithMe.length}</span>
                                        )}
                                    </button>
                                    {categories.map(cat => (
                                        <button
                                            key={cat.id}
                                            onClick={() => {
                                                setSelectedCategory(cat.id);
                                                setShowSharedWithMe(false);
                                            }}
                                            className={`w-full flex items-center gap-2 px-3 py-2 rounded-lg text-sm transition-colors ${
                                                selectedCategory === cat.id && !showSharedWithMe ? 'bg-emerald-500/20 text-emerald-400' : 'hover:bg-gray-700'
                                            }`}
                                        >
                                            <Icons.Folder />
                                            {cat.name}
                                            <span className="ml-auto text-xs text-gray-500">
                                                {videos.filter(v => v.category === cat.id).length}
                                            </span>
                                        </button>
                                    ))}
                                </div>
                            </div>

                            {/* Sort By */}
                            <div className="px-3 mb-3">
                                <label className="block text-xs text-gray-400 mb-1">Sort By</label>
                                <select
                                    value={sortBy}
                                    onChange={(e) => setSortBy(e.target.value)}
                                    className="w-full bg-gray-700 rounded-lg px-3 py-2 text-sm text-gray-100"
                                >
                                    <option value="default">Default Order</option>
                                    <option value="date-desc">Newest First</option>
                                    <option value="date-asc">Oldest First</option>
                                </select>
                            </div>

                            {/* Video List */}
                            <div className="flex-1 overflow-y-auto scrollbar-thin px-4 py-2">
                                <h3 className="text-sm font-medium text-gray-400 mb-2">Videos</h3>
                                <div className="space-y-2">
                                    {sortedVideos.map(video => (
                                        <div key={video.id} className="mb-2">
                                            <button
                                                onClick={() => handleSelectVideo(video.id)}
                                                className={`w-full text-left p-2 rounded-lg transition-colors ${
                                                    activeVideoId === video.id ? 'bg-emerald-500/20 ring-1 ring-emerald-500' : 'bg-gray-700 hover:bg-gray-600'
                                                }`}
                                            >
                                                <div className="flex gap-2">
                                                    <img
                                                        src={`https://img.youtube.com/vi/${video.videoId}/default.jpg`}
                                                        alt=""
                                                        className="w-16 h-12 object-cover rounded"
                                                />
                                                    <div className="flex-1 min-w-0">
                                                        <p className="text-sm font-medium truncate">{video.title}</p>
                                                        <p className="text-xs text-gray-400">{video.notes?.length || 0} notes</p>
                                                    </div>
                                                </div>
                                            </button>
                                            {video.publishDate && (
                                                <p className="text-xs text-gray-500 mt-1 pl-1 border-t border-gray-600 pt-1">
                                                    Published: {formatPublishDate(video.publishDate)}
                                                </p>
                                            )}
                                        </div>
                                    ))}
                                    {sortedVideos.length === 0 && (
                                        <p className="text-center text-gray-500 py-4 text-sm">
                                            {videos.length === 0 ? 'No videos yet. Add one!' : 'No matching videos'}
                                        </p>
                                    )}
                                </div>
                            </div>
                        </aside>

                        {/* Main Content */}
                        <main className="flex-1 flex flex-col overflow-hidden">
                            {showLibrary ? (
                                showSharedWithMe ? (
                                    /* Shared with me Grid View */
                                    <div className="flex-1 overflow-y-auto p-6 scrollbar-thin">
                                        <h2 className="text-2xl font-bold mb-6 flex items-center gap-3">
                                            <Icons.Users />
                                            Shared with me
                                        </h2>
                                        {sharedWithMe.length > 0 ? (
                                            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                                                {sharedWithMe.map(shared => (
                                                    <div
                                                        key={shared.shareId}
                                                        className={`cursor-pointer rounded-lg overflow-hidden transition-all hover:ring-2 hover:ring-gray-600 ${
                                                            activeSharedVideo?.shareId === shared.shareId ? 'ring-2 ring-blue-500' : ''
                                                        }`}
                                                        onClick={() => {
                                                            // Open shared video in player view
                                                            setActiveSharedVideo(shared);
                                                            setActiveVideoId(null); // Clear regular video
                                                            setShowLibrary(false);
                                                            setNoteSearch('');
                                                        }}
                                                    >
                                                        <div className="relative group">
                                                            <img
                                                                src={shared.videoThumbnail || `https://img.youtube.com/vi/${shared.youtubeVideoId}/mqdefault.jpg`}
                                                                alt={shared.videoTitle}
                                                                className="w-full aspect-video object-cover"
                                                            />
                                                            <div className="absolute bottom-2 right-2 bg-black/80 px-2 py-0.5 rounded text-xs">
                                                                {shared.notes?.length || 0} notes
                                                            </div>
                                                            <div className="absolute top-2 left-2 bg-blue-500/90 px-2 py-0.5 rounded text-xs flex items-center gap-1">
                                                                <span>From {shared.fromUsername}</span>
                                                            </div>
                                                        </div>
                                                        <div className="p-3 bg-gray-800">
                                                            <h3 className="font-medium text-sm line-clamp-2">{shared.videoTitle}</h3>
                                                            <p className="text-xs text-gray-400 mt-1">
                                                                Shared {new Date(shared.sharedAt).toLocaleDateString()}
                                                            </p>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        ) : (
                                            <div className="flex flex-col items-center justify-center h-64 text-gray-400">
                                                <Icons.Users />
                                                <p className="mt-4 text-lg">No shared videos yet</p>
                                                <p className="text-sm">When someone shares a video with you, it will appear here</p>
                                            </div>
                                        )}
                                    </div>
                                ) : (
                                    /* Library Grid/List View */
                                    <div className="flex-1 overflow-y-auto p-6 scrollbar-thin">
                                        <div className="flex items-center justify-between mb-6">
                                            <h2 className="text-2xl font-bold">Your Library</h2>
                                            <div className="flex items-center gap-1 bg-gray-700 p-1 rounded-lg">
                                                <button
                                                    onClick={() => setLibraryViewMode('grid')}
                                                    className={`p-2 rounded transition-colors ${libraryViewMode === 'grid' ? 'bg-emerald-500 text-white' : 'hover:bg-gray-600'}`}
                                                    title="Grid view"
                                                >
                                                    <Icons.Grid />
                                                </button>
                                                <button
                                                    onClick={() => setLibraryViewMode('list')}
                                                    className={`p-2 rounded transition-colors ${libraryViewMode === 'list' ? 'bg-emerald-500 text-white' : 'hover:bg-gray-600'}`}
                                                    title="List view"
                                                >
                                                    <Icons.List />
                                                </button>
                                            </div>
                                        </div>
                                        {sortedVideos.length > 0 ? (
                                            libraryViewMode === 'grid' ? (
                                            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                                                {sortedVideos.map(video => (
                                                    <VideoCard
                                                        key={video.id}
                                                        video={video}
                                                        isActive={video.id === activeVideoId}
                                                        onClick={() => handleSelectVideo(video.id)}
                                                        onDelete={() => handleDeleteVideo(video.id)}
                                                        onEdit={handleEditVideo}
                                                        onShare={(video) => {
                                                            setShareVideo(video);
                                                            setShowShareModal(true);
                                                        }}
                                                        onFetchPublishDate={handleFetchPublishDate}
                                                        isFetchingDate={fetchingDateFor === video.id}
                                                    />
                                                ))}
                                            </div>
                                            ) : (
                                            /* List View */
                                            <div className="flex flex-col gap-3">
                                                {sortedVideos.map(video => (
                                                    <VideoListItem
                                                        key={video.id}
                                                        video={video}
                                                        isActive={video.id === activeVideoId}
                                                        onClick={() => handleSelectVideo(video.id)}
                                                        onDelete={() => handleDeleteVideo(video.id)}
                                                        onEdit={handleEditVideo}
                                                        onShare={(video) => {
                                                            setShareVideo(video);
                                                            setShowShareModal(true);
                                                        }}
                                                        onFetchPublishDate={handleFetchPublishDate}
                                                        isFetchingDate={fetchingDateFor === video.id}
                                                    />
                                                ))}
                                            </div>
                                            )
                                        ) : (
                                            <div className="flex flex-col items-center justify-center h-64 text-gray-400">
                                                <Icons.Bookmark />
                                                <p className="mt-4 text-lg">No videos yet</p>
                                                <p className="text-sm">Click "Add Video" to get started</p>
                                            </div>
                                        )}
                                    </div>
                                )
                            ) : (
                                /* Video Player View */
                                <div className="flex-1 flex overflow-hidden">
                                    {/* Player Area */}
                                    <div className="flex-1 flex flex-col p-4 overflow-hidden">
                                        {/* Video Player - Smaller size */}
                                        <div className="w-full max-w-3xl mx-auto shrink-0 mb-4">
                                            <div className="aspect-video bg-black rounded-lg overflow-hidden">
                                                <VideoPlayer
                                                    video={displayVideo}
                                                    onTimeUpdate={setCurrentTime}
                                                    playerRef={playerRef}
                                                    onWatchTime={trackWatchTime}
                                                />
                                            </div>
                                        </div>

                                        {/* Enhancement Toolbar - works for both regular and shared videos */}
                                        {displayVideo && (
                                            <div className="w-full max-w-3xl mx-auto mb-4">
                                                <div className="bg-gray-800 rounded-lg px-4 py-3 flex items-center justify-between">
                                                    <div className="flex items-center gap-3">
                                                        <button
                                                            onClick={handleEnhanceAllNotes}
                                                            disabled={isEnhancing || !displayVideo.notes || displayVideo.notes.length === 0 || !apiStatus.geminiConfigured}
                                                            className="flex items-center gap-2 px-3 py-2 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-700 disabled:cursor-not-allowed disabled:opacity-50 rounded-lg text-sm font-medium transition-colors"
                                                            title={!apiStatus.geminiConfigured ? "Gemini AI not configured on server" : "Enhance all notes with AI"}
                                                        >
                                                            {isEnhancing ? (
                                                                <>
                                                                    <svg className="animate-spin h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                                    </svg>
                                                                    Processing {enhancementProgress.current}/{enhancementProgress.total}...
                                                                </>
                                                            ) : (
                                                                <>
                                                                    <Icons.Sparkles />
                                                                    Enhance Notes
                                                                </>
                                                            )}
                                                        </button>
                                                        <button
                                                            onClick={() => handleExportMarkdown(displayVideo)}
                                                            disabled={!displayVideo.notes || displayVideo.notes.length === 0}
                                                            className="flex items-center gap-2 px-3 py-2 bg-gray-600 hover:bg-gray-500 disabled:bg-gray-700 disabled:cursor-not-allowed disabled:opacity-50 rounded-lg text-sm font-medium transition-colors"
                                                            title="Download notes as Markdown file"
                                                        >
                                                            <Icons.Download />
                                                            Download .md
                                                        </button>
                                                        {/* Show transcript upload for non-YouTube videos */}
                                                        {(displayVideo.sourceType && displayVideo.sourceType !== 'youtube') && (
                                                            <>
                                                                <button
                                                                    onClick={() => setShowTranscriptModal(true)}
                                                                    className="flex items-center gap-2 px-3 py-2 bg-blue-600 hover:bg-blue-500 rounded-lg text-sm font-medium transition-colors"
                                                                    title="Upload SRT/VTT transcript file"
                                                                >
                                                                    <Icons.Transcript />
                                                                    Upload Transcript
                                                                </button>
                                                                <button
                                                                    onClick={() => setShowTranscriptHelp(true)}
                                                                    className="flex items-center justify-center w-8 h-8 bg-gray-600 hover:bg-gray-500 rounded-lg transition-colors"
                                                                    title="How to create a transcript"
                                                                >
                                                                    <Icons.Info />
                                                                </button>
                                                            </>
                                                        )}
                                                    </div>
                                                    <div className="flex items-center gap-2">
                                                        {/* Transcript status */}
                                                        {displayVideo.transcript && (
                                                            <TranscriptStatusBadge transcript={displayVideo.transcript} />
                                                        )}
                                                    </div>
                                                    {!apiStatus.geminiConfigured && (
                                                        <p className="text-xs text-gray-500">
                                                            Gemini AI not configured on server - AI enhancement unavailable
                                                        </p>
                                                    )}
                                                </div>
                                            </div>
                                        )}

                                        {/* Video Info & Note Input */}
                                        {displayVideo && (
                                            <div className="w-full max-w-3xl mx-auto flex-1 overflow-y-auto min-h-0">
                                                <div className="flex items-start justify-between mb-4">
                                                    <div>
                                                        <h2 className="text-xl font-semibold">{displayVideo.title}</h2>
                                                        <div className="flex items-center gap-2 mt-1">
                                                            {displayVideo.isShared && (
                                                                <span className="flex items-center gap-1 text-xs bg-blue-500/20 text-blue-400 px-2 py-1 rounded-full">
                                                                    <Icons.Users />
                                                                    Shared by {displayVideo.sharedFrom}
                                                                </span>
                                                            )}
                                                            {displayVideo.tags?.map(tag => (
                                                                <span key={tag} className="flex items-center gap-1 text-xs bg-gray-700 px-2 py-1 rounded-full">
                                                                    <Icons.Tag />
                                                                    {tag}
                                                                </span>
                                                            ))}
                                                        </div>
                                                    </div>
                                                    <div className="flex items-center gap-2">
                                                        {!displayVideo.isShared && (
                                                            <>
                                                                <button
                                                                    onClick={() => {
                                                                        setShareVideo(activeVideo);
                                                                        setShowShareModal(true);
                                                                    }}
                                                                    className="p-2 hover:bg-gray-700 rounded-lg text-gray-400 hover:text-blue-400"
                                                                    title="Share video"
                                                                >
                                                                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
                                                                    </svg>
                                                                </button>
                                                                <button
                                                                    onClick={() => handleDeleteVideo(activeVideo.id)}
                                                                    className="p-2 hover:bg-gray-700 rounded-lg text-gray-400 hover:text-emerald-400"
                                                                    title="Delete video"
                                                                >
                                                                    <Icons.Trash />
                                                                </button>
                                                            </>
                                                        )}
                                                        {displayVideo.isShared && (
                                                            <button
                                                                onClick={() => {
                                                                    setActiveSharedVideo(null);
                                                                    setShowLibrary(true);
                                                                    setShowSharedWithMe(true);
                                                                }}
                                                                className="p-2 hover:bg-gray-700 rounded-lg text-gray-400 hover:text-emerald-400"
                                                                title="Back to shared videos"
                                                            >
                                                                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                                                                </svg>
                                                            </button>
                                                        )}
                                                    </div>
                                                </div>

                                                {/* Note Input */}
                                                <div className="bg-gray-800 rounded-lg p-4">
                                                    {/* Header row */}
                                                    <div className="flex items-center justify-between mb-3">
                                                        <span className="text-emerald-500 font-semibold italic">ClipMark</span>
                                                        <span className="text-gray-400 text-sm">Adding note at {formatTime(currentTime)}</span>
                                                    </div>
                                                    {/* Main input row */}
                                                    <div className="flex gap-3">
                                                        <textarea
                                                            value={newNote}
                                                            onChange={(e) => setNewNote(e.target.value)}
                                                            placeholder="Add a note at this timestamp... (Click 'Get Context' to auto-fill with transcript)"
                                                            className="flex-1 bg-gray-700 rounded-lg px-4 py-3 text-gray-100 placeholder-gray-500 resize-none focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                                            rows={3}
                                                            onKeyDown={(e) => {
                                                                if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
                                                                    handleAddNote();
                                                                }
                                                            }}
                                                        />
                                                        <div className="flex flex-col gap-2 w-32">
                                                            <button
                                                                onClick={handleLoadContext}
                                                                disabled={isLoadingContext}
                                                                className="flex-1 bg-red-600 hover:bg-red-700 disabled:bg-gray-700 disabled:cursor-not-allowed rounded-lg text-sm font-medium transition-colors flex items-center justify-center gap-2"
                                                                title={`Load transcript context (±${contextWordCount} words around current timestamp)`}
                                                            >
                                                                {isLoadingContext ? (
                                                                    <>
                                                                        <svg className="animate-spin h-3 w-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                                        </svg>
                                                                        Loading...
                                                                    </>
                                                                ) : 'Get Context'}
                                                            </button>
                                                            <button
                                                                onClick={handleAddNote}
                                                                disabled={!newNote.trim()}
                                                                className={`flex-1 ${newNote.trim() ? 'bg-emerald-500 hover:bg-emerald-600' : 'bg-gray-700'} disabled:cursor-not-allowed text-white font-medium rounded-lg transition-colors`}
                                                            >
                                                                Add Note
                                                            </button>
                                                        </div>
                                                    </div>
                                                    {/* Help text */}
                                                    <p className="text-xs text-gray-500 mt-3 text-center">Press Ctrl+Enter to save • Click "Get Context" to load ±{contextWordCount} words from transcript</p>
                                                </div>
                                                {/* Video Description (YouTube only) */}
                                                {displayVideo && (displayVideo.sourceType === 'youtube' || (!displayVideo.sourceType && displayVideo.videoId)) && displayVideo.description && (
                                                    <div className="bg-gray-800 rounded-lg p-4 mt-2">
                                                        <button
                                                            onClick={() => setShowFullDescription(v => !v)}
                                                            className="w-full flex items-center justify-between text-left gap-2 group"
                                                        >
                                                            <span className="text-xs font-semibold text-gray-400 uppercase tracking-wide">Description</span>
                                                            <svg
                                                                className={`w-4 h-4 text-gray-500 group-hover:text-gray-300 transition-transform ${showFullDescription ? 'rotate-180' : ''}`}
                                                                fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}
                                                            >
                                                                <path strokeLinecap="round" strokeLinejoin="round" d="M19 9l-7 7-7-7" />
                                                            </svg>
                                                        </button>
                                                        <div className={`mt-2 text-sm text-gray-300 whitespace-pre-wrap leading-relaxed ${showFullDescription ? '' : 'line-clamp-2'}`}>
                                                            {displayVideo.description}
                                                        </div>
                                                        {!showFullDescription && displayVideo.description.length > 120 && (
                                                            <button
                                                                onClick={() => setShowFullDescription(true)}
                                                                className="text-xs text-emerald-500 hover:text-emerald-400 mt-1 transition-colors"
                                                            >
                                                                Show more
                                                            </button>
                                                        )}
                                                        {showFullDescription && (
                                                            <button
                                                                onClick={() => setShowFullDescription(false)}
                                                                className="text-xs text-emerald-500 hover:text-emerald-400 mt-1 transition-colors"
                                                            >
                                                                Show less
                                                            </button>
                                                        )}
                                                    </div>
                                                )}
                                                {/* Footer - outside note container */}
                                                <p className="text-xs text-gray-600 mt-2 text-center">© 2026 Absolute 0 Internet Studios</p>
                                            </div>
                                        )}
                                    </div>

                                    {/* Notes Panel */}
                                    {displayVideo && (
                                        <aside className="w-80 bg-gray-800 border-l border-gray-700 flex flex-col shrink-0">
                                            <div className="p-4 border-b border-gray-700 flex items-center justify-between">
                                                <h3 className="font-semibold">Notes ({displayVideo.notes?.length || 0})</h3>
                                                <div className="flex gap-1">
                                                    {!displayVideo.isShared && (
                                                        <button
                                                            onClick={() => handleImportNotes(activeVideo)}
                                                            className="px-3 py-1 bg-gray-600 hover:bg-gray-500 rounded text-xs font-medium transition-colors flex items-center gap-1"
                                                            title="Import notes from text file"
                                                        >
                                                        <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                                                        </svg>
                                                        Import
                                                        </button>
                                                    )}
                                                    <button
                                                        onClick={() => handleExportNotes(displayVideo)}
                                                        disabled={!displayVideo.notes || displayVideo.notes.length === 0}
                                                        className="px-3 py-1 bg-gray-600 hover:bg-gray-500 disabled:bg-gray-700 disabled:cursor-not-allowed disabled:opacity-50 rounded text-xs font-medium transition-colors flex items-center gap-1"
                                                        title="Export notes as text file"
                                                    >
                                                        <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                                        </svg>
                                                        Export
                                                    </button>
                                                </div>
                                            </div>
                                            {/* Notes Search */}
                                            {displayVideo.notes?.length > 0 && (
                                                <div className="px-4 pt-3 pb-2 border-b border-gray-700">
                                                    <div className="relative">
                                                        <svg className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                                        </svg>
                                                        <input
                                                            type="text"
                                                            value={noteSearch}
                                                            onChange={(e) => setNoteSearch(e.target.value)}
                                                            placeholder="Search notes..."
                                                            className="w-full bg-gray-700 rounded-lg pl-10 pr-8 py-2 text-sm text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                                        />
                                                        {noteSearch && (
                                                            <button
                                                                onClick={() => setNoteSearch('')}
                                                                className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-500 hover:text-gray-300"
                                                            >
                                                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                                                </svg>
                                                            </button>
                                                        )}
                                                    </div>
                                                    {noteSearch && (
                                                        <p className="text-xs text-gray-500 mt-1">
                                                            {displayVideo.notes.filter(n => n.text.toLowerCase().includes(noteSearch.toLowerCase())).length} of {displayVideo.notes.length} notes
                                                        </p>
                                                    )}
                                                </div>
                                            )}
                                            <div className="flex-1 overflow-y-auto p-4 scrollbar-thin">
                                                {displayVideo.notes?.length > 0 ? (
                                                    (() => {
                                                        const filteredNotes = noteSearch
                                                            ? displayVideo.notes.filter(n => n.text.toLowerCase().includes(noteSearch.toLowerCase()))
                                                            : displayVideo.notes;
                                                        return filteredNotes.length > 0 ? (
                                                            filteredNotes.map(note => (
                                                                <NoteItem
                                                                    key={note.id}
                                                                    note={note}
                                                                    onSeek={handleSeek}
                                                                    onDelete={handleDeleteNote}
                                                                    onEdit={handleEditNote}
                                                                    searchTerm={noteSearch}
                                                                />
                                                            ))
                                                        ) : (
                                                            <p className="text-center text-gray-500 py-8">
                                                                No notes match "{noteSearch}"
                                                            </p>
                                                        );
                                                    })()
                                                ) : (
                                                    <p className="text-center text-gray-500 py-8">
                                                        No notes yet. Add one below!
                                                    </p>
                                                )}
                                            </div>
                                        </aside>
                                    )}
                                </div>
                            )}
                        </main>
                    </div>

                    {/* Modals */}
                    <AddVideoModal
                        isOpen={showAddModal}
                        onClose={() => setShowAddModal(false)}
                        onAdd={handleAddVideo}
                        categories={categories}
                        onAddCategory={handleAddCategory}
                    />
                    <EditVideoModal
                        isOpen={showEditModal}
                        onClose={() => setShowEditModal(false)}
                        video={editingVideo}
                        onSave={handleSaveEditedVideo}
                        categories={categories}
                        onAddCategory={handleAddCategory}
                    />
                    <CategoryModal
                        isOpen={showCategoryModal}
                        onClose={() => setShowCategoryModal(false)}
                        categories={categories}
                        onAdd={handleAddCategory}
                        onEdit={handleEditCategory}
                        onDelete={handleDeleteCategory}
                    />
                    <SettingsModal
                        isOpen={showSettingsModal}
                        onClose={() => setShowSettingsModal(false)}
                        apiStatus={apiStatus}
                        contextWordCount={contextWordCount}
                        onSaveContextWordCount={handleSaveContextWordCount}
                        onOpenProfile={() => setShowProfileModal(true)}
                        onExport={handleExport}
                        onImport={() => fileInputRef.current?.click()}
                    />
                    <ProfileModal
                        isOpen={showProfileModal}
                        onClose={() => setShowProfileModal(false)}
                        serverUrl={SERVER_URL}
                        authToken={authToken}
                        currentUser={currentUser}
                    />
                    <ShareModal
                        isOpen={showShareModal}
                        onClose={() => {
                            setShowShareModal(false);
                            setShareVideo(null);
                        }}
                        video={shareVideo}
                        serverUrl={SERVER_URL}
                        authToken={authToken}
                    />
                    <TranscriptUploadModal
                        isOpen={showTranscriptModal}
                        onClose={() => setShowTranscriptModal(false)}
                        onUpload={handleTranscriptUpload}
                        serverUrl={SERVER_URL}
                        authToken={authToken}
                    />
                    <BackupImportModal
                        isOpen={showImportModal}
                        onClose={() => { setShowImportModal(false); setImportData(null); }}
                        importData={importData}
                        fileName={importFileName}
                        serverUrl={SERVER_URL}
                        authToken={authToken}
                        onImportComplete={handleImportComplete}
                    />
                    <TranscriptHelpModal
                        isOpen={showTranscriptHelp}
                        onClose={() => setShowTranscriptHelp(false)}
                    />
                    <EnhancementReviewModal
                        isOpen={showEnhancementReview}
                        onClose={() => {
                            setShowEnhancementReview(false);
                            setPendingEnhancements([]);
                        }}
                        pendingEnhancements={pendingEnhancements}
                        onApply={handleApplyEnhancements}
                    />
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
