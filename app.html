<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ClipMark - Mark the Moments That Matter</title>

    <!-- Favicons and Apple Touch Icons -->
    <link rel="icon" type="image/svg+xml" href="logos/clipmark-favicon.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="167x167" href="apple-touch-icon-167x167.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ClipMark">
    <meta name="theme-color" content="#0f172a">

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { font-family: 'Inter', sans-serif; }
        .scrollbar-thin::-webkit-scrollbar { width: 6px; }
        .scrollbar-thin::-webkit-scrollbar-track { background: #1f2937; }
        .scrollbar-thin::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
        .scrollbar-thin::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Utility functions
        const formatTime = (seconds) => {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        };

        const formatPublishDate = (dateStr) => {
            if (!dateStr) return null;
            try {
                // Handle various date formats (YYYY-MM-DD, YYYYMMDD, etc.)
                const cleaned = dateStr.replace(/[^\d-]/g, '');
                let date;
                if (cleaned.length === 8 && !cleaned.includes('-')) {
                    // YYYYMMDD format
                    date = new Date(cleaned.slice(0,4), cleaned.slice(4,6) - 1, cleaned.slice(6,8));
                } else {
                    date = new Date(dateStr);
                }
                if (isNaN(date.getTime())) return null;
                return date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
            } catch (e) {
                return null;
            }
        };

        const parseTime = (timeStr) => {
            const parts = timeStr.split(':').map(Number);
            if (parts.length === 2) return parts[0] * 60 + parts[1];
            if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
            return 0;
        };

        const extractVideoId = (url) => {
            const patterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
                /^([a-zA-Z0-9_-]{11})$/
            ];
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) return match[1];
            }
            return null;
        };

        const generateId = () => Math.random().toString(36).substr(2, 9);

        // Storage Utility Functions
        const isStorageAvailable = (type) => {
            try {
                const storage = window[type];
                const testKey = '__storage_test__';
                storage.setItem(testKey, 'test');
                storage.removeItem(testKey);
                return true;
            } catch (e) {
                console.warn(`⚠️ ${type} not available:`, e.message);
                return false;
            }
        };

        const saveToStorage = (key, value, storage = localStorage) => {
            try {
                storage.setItem(key, JSON.stringify(value));
                return true;
            } catch (e) {
                console.error(`❌ Failed to save to storage (${key}):`, e.message);
                return false;
            }
        };

        const loadFromStorage = (key, storage = localStorage) => {
            try {
                const item = storage.getItem(key);
                return item ? JSON.parse(item) : null;
            } catch (e) {
                console.error(`❌ Failed to load from storage (${key}):`, e.message);
                return null;
            }
        };

        // Icons
        const Icons = {
            Search: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
            ),
            Plus: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                </svg>
            ),
            Bookmark: () => (
                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z" />
                </svg>
            ),
            Folder: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                </svg>
            ),
            Tag: () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />
                </svg>
            ),
            Play: () => (
                <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M8 5v14l11-7z" />
                </svg>
            ),
            Trash: () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
            ),
            Download: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                </svg>
            ),
            Upload: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                </svg>
            ),
            Clock: () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            ),
            Edit: () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                </svg>
            ),
            Grid: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
                </svg>
            ),
            X: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
            ),
            Sparkles: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />
                </svg>
            ),
            Settings: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
            ),
            Calendar: () => (
                <svg className="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                    <line x1="16" y1="2" x2="16" y2="6"/>
                    <line x1="8" y1="2" x2="8" y2="6"/>
                    <line x1="3" y1="10" x2="21" y2="10"/>
                </svg>
            ),
            Refresh: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
            ),
            Share: () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
                </svg>
            ),
            Users: () => (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z" />
                </svg>
            )
        };

        // Tip-finding keywords and phrases (legacy - kept for fallback)
        const TIP_PATTERNS = [
            // Direct tip mentions
            /(?:here'?s?\s+(?:a\s+)?(?:pro\s+)?tip|tip\s*(?:number|#)?\s*\d*|quick\s+tip|hot\s+tip|bonus\s+tip)/i,
            // Important callouts
            /(?:important(?:ly)?|key\s+point|remember\s+(?:this|that)|don'?t\s+forget|keep\s+in\s+mind|note\s+that|pay\s+attention)/i,
            // Advice phrases
            /(?:you\s+should|make\s+sure|always\s+(?:remember|make)|never\s+(?:forget|do)|the\s+(?:trick|secret|key)\s+is)/i,
            // Best practices
            /(?:best\s+practice|pro\s+tip|life\s+hack|game\s+changer|this\s+is\s+(?:huge|important|critical))/i,
            // Mistakes to avoid
            /(?:(?:common\s+)?mistake|avoid\s+(?:this|doing)|don'?t\s+(?:make\s+)?this\s+(?:mistake|error))/i,
            // Recommendations
            /(?:i\s+(?:highly\s+)?recommend|my\s+(?:top\s+)?recommendation|what\s+(?:i\s+)?suggest)/i
        ];

        // Gemini AI API for transcript analysis (via server proxy)
        const analyzeTranscriptWithGemini = async (transcript, serverUrl, authToken) => {
            const fullText = transcript.map(t => `[${formatTime(t.start)}] ${t.text}`).join('\n');

            const prompt = `You are analyzing a YouTube video transcript to extract key tips, insights, and actionable advice.

Transcript:
${fullText}

Instructions:
1. Identify the most valuable tips, insights, key points, and actionable advice from this transcript
2. For each tip found, provide the exact timestamp where it appears (use the timestamps from the transcript)
3. Summarize each tip concisely but include enough context to be useful
4. Focus on practical, actionable information
5. Ignore filler content, introductions, and promotional material

Return your response as a JSON array with this exact format:
[
  {"timestamp": 45.5, "tip": "Brief description of the tip or insight"},
  {"timestamp": 120.0, "tip": "Another tip description"}
]

Only return the JSON array, no other text. If no meaningful tips are found, return an empty array [].`;

            const response = await fetch(`${serverUrl}/api/gemini`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${authToken}`
                },
                body: JSON.stringify({ prompt, maxTokens: 2048, temperature: 0.3 })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `API error: ${response.status}`);
            }

            const data = await response.json();
            const responseText = data.text || '';

            // Extract JSON from response (handle markdown code blocks)
            let jsonStr = responseText;
            const jsonMatch = responseText.match(/```(?:json)?\s*([\s\S]*?)```/);
            if (jsonMatch) {
                jsonStr = jsonMatch[1];
            }

            // Clean and parse JSON
            jsonStr = jsonStr.trim();
            if (!jsonStr.startsWith('[')) {
                const arrayStart = jsonStr.indexOf('[');
                const arrayEnd = jsonStr.lastIndexOf(']');
                if (arrayStart !== -1 && arrayEnd !== -1) {
                    jsonStr = jsonStr.substring(arrayStart, arrayEnd + 1);
                }
            }

            const tips = JSON.parse(jsonStr);
            return tips;
        };

        // AI function to summarize a note with transcript context (via server proxy)
        const summarizeNoteWithContext = async (contextText, originalNote, serverUrl, authToken) => {
            const prompt = `You are helping to enhance and clarify notes taken while watching a video. Given the transcript context and the original note, create a clear, bullet-point summary that captures the complete thought.

Transcript context (words surrounding the note timestamp):
"${contextText}"

Original note:
"${originalNote}"

Instructions:
1. Understand what topic or idea the note is referring to based on the transcript context
2. Create a concise bullet-point summary (1-3 bullets) that captures the complete thought
3. Each bullet should start with "- " and be on its own line
4. If the context is unclear or could have multiple interpretations, flag this as ambiguous
5. If ambiguous, provide 2-3 alternative interpretations as separate summaries

Return your response as a JSON object with this exact format:
{
  "summary": "- First bullet point\\n- Second bullet point",
  "isAmbiguous": false,
  "alternatives": null
}

OR if ambiguous:
{
  "summary": "- Most likely interpretation bullet",
  "isAmbiguous": true,
  "alternatives": ["- Alternative interpretation 1", "- Alternative interpretation 2"]
}

Only return the JSON object, no other text.`;

            const response = await fetch(`${serverUrl}/api/gemini`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${authToken}`
                },
                body: JSON.stringify({ prompt, maxTokens: 1024, temperature: 0.3 })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `API error: ${response.status}`);
            }

            const data = await response.json();
            const responseText = data.text || '';

            // Extract JSON from response (handle markdown code blocks)
            let jsonStr = responseText;
            const jsonMatch = responseText.match(/```(?:json)?\s*([\s\S]*?)```/);
            if (jsonMatch) {
                jsonStr = jsonMatch[1];
            }

            // Clean and parse JSON
            jsonStr = jsonStr.trim();
            if (!jsonStr.startsWith('{')) {
                const objStart = jsonStr.indexOf('{');
                const objEnd = jsonStr.lastIndexOf('}');
                if (objStart !== -1 && objEnd !== -1) {
                    jsonStr = jsonStr.substring(objStart, objEnd + 1);
                }
            }

            const result = JSON.parse(jsonStr);
            return {
                summary: result.summary || originalNote,
                isAmbiguous: result.isAmbiguous || false,
                alternatives: result.alternatives || null
            };
        };

        // Function to fetch YouTube transcript using local proxy server
        const fetchTranscript = async (videoId) => {
            // Auto-detect server: use same host as page, or localhost if on file://
            const SERVER_HOST = window.location.protocol === 'file:'
                ? 'localhost'
                : window.location.hostname;
            // Use same origin when served via nginx (port 80), otherwise use port 3456
            const LOCAL_SERVER = (window.location.port === '' || window.location.port === '80')
                ? window.location.origin
                : `http://${SERVER_HOST}:3456`;

            // Method 1: Try local transcript server (most reliable - no CORS issues)
            const tryLocalServer = async () => {
                try {
                    console.log('Trying local transcript server...');
                    const response = await fetch(`${LOCAL_SERVER}/transcript?v=${videoId}`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.transcript && data.transcript.length > 0) {
                            return data.transcript;
                        }
                        if (data.error) {
                            console.log('Local server error:', data.error);
                        }
                    }
                } catch (e) {
                    console.log('Local server not available:', e.message);
                }
                return null;
            };

            // Method 2: Direct YouTube timedtext API (fallback, may work for some videos)
            const tryDirectTimedText = async () => {
                try {
                    console.log('Trying direct YouTube timedtext...');
                    const langs = ['en', 'en-US', 'en-GB', 'a.en'];
                    for (const lang of langs) {
                        const url = `https://www.youtube.com/api/timedtext?v=${videoId}&lang=${lang}&fmt=srv3`;
                        const response = await fetch(url);
                        if (response.ok) {
                            const text = await response.text();
                            if (text && text.includes('<p')) {
                                const parser = new DOMParser();
                                const xmlDoc = parser.parseFromString(text, 'text/xml');
                                const textElements = xmlDoc.getElementsByTagName('p');

                                if (textElements.length > 0) {
                                    const transcript = [];
                                    for (let el of textElements) {
                                        const start = parseFloat(el.getAttribute('t') || '0') / 1000;
                                        const duration = parseFloat(el.getAttribute('d') || '0') / 1000;
                                        transcript.push({
                                            start,
                                            duration,
                                            text: el.textContent
                                                ?.replace(/&#39;/g, "'")
                                                .replace(/&quot;/g, '"')
                                                .replace(/&amp;/g, '&')
                                                .trim() || ''
                                        });
                                    }
                                    if (transcript.length > 0) {
                                        return transcript.filter(t => t.text);
                                    }
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.log('Direct timedtext failed:', e.message);
                }
                return null;
            };

            try {
                // Try local server first (requires running transcript-server.js)
                let transcript = await tryLocalServer();
                if (transcript && transcript.length > 0) {
                    console.log(`Got ${transcript.length} transcript segments via local server`);
                    return transcript;
                }

                // Fallback to direct API (usually blocked by CORS)
                transcript = await tryDirectTimedText();
                if (transcript && transcript.length > 0) {
                    console.log(`Got ${transcript.length} transcript segments via direct timedtext`);
                    return transcript;
                }

                console.log('All transcript fetch methods failed');
                console.log('Make sure the transcript server is running: node transcript-server.js');
                return null;
            } catch (error) {
                console.error('Transcript fetch error:', error);
                return null;
            }
        };

        // Function to find tips in transcript
        const findTipsInTranscript = (transcript) => {
            const tips = [];
            const windowSize = 3; // Look at groups of 3 segments for context

            for (let i = 0; i < transcript.length; i++) {
                // Build context from surrounding segments
                const contextSegments = transcript.slice(
                    Math.max(0, i - 1),
                    Math.min(transcript.length, i + windowSize)
                );
                const contextText = contextSegments.map(s => s.text).join(' ');

                // Check if any tip pattern matches
                for (const pattern of TIP_PATTERNS) {
                    if (pattern.test(contextText)) {
                        // Get the full tip content (current segment + next few)
                        const tipSegments = transcript.slice(i, Math.min(transcript.length, i + 3));
                        const tipText = tipSegments.map(s => s.text).join(' ').trim();

                        // Avoid duplicates (within 10 seconds)
                        const isDuplicate = tips.some(t =>
                            Math.abs(t.timestamp - transcript[i].start) < 10
                        );

                        if (!isDuplicate && tipText.length > 10) {
                            tips.push({
                                timestamp: transcript[i].start,
                                text: tipText,
                                matchedPattern: pattern.source
                            });
                        }
                        break;
                    }
                }
            }

            return tips;
        };

        // YouTube Player Component
        const YouTubePlayer = ({ videoId, onTimeUpdate, playerRef, onWatchTime }) => {
            const [playerId] = useState(() => `yt-player-${generateId()}`);
            const [isReady, setIsReady] = useState(false);
            const [playerError, setPlayerError] = useState(null);

            useEffect(() => {
                if (!videoId) return;

                let isMounted = true;
                setPlayerError(null);

                // Clean up existing player
                const cleanupPlayer = () => {
                    if (playerRef.current) {
                        try {
                            if (playerRef.current._timeInterval) {
                                clearInterval(playerRef.current._timeInterval);
                            }
                            playerRef.current.destroy();
                        } catch (e) {
                            console.log('Player cleanup error:', e);
                        }
                        playerRef.current = null;
                    }
                };

                // Load YouTube IFrame API
                const loadYouTubeAPI = () => {
                    return new Promise((resolve) => {
                        if (window.YT && window.YT.Player) {
                            resolve();
                            return;
                        }

                        // Check if script is already loading
                        if (document.querySelector('script[src*="youtube.com/iframe_api"]')) {
                            const checkReady = setInterval(() => {
                                if (window.YT && window.YT.Player) {
                                    clearInterval(checkReady);
                                    resolve();
                                }
                            }, 100);
                            return;
                        }

                        const tag = document.createElement('script');
                        tag.src = 'https://www.youtube.com/iframe_api';
                        const firstScriptTag = document.getElementsByTagName('script')[0];
                        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

                        window.onYouTubeIframeAPIReady = () => {
                            resolve();
                        };
                    });
                };

                const initPlayer = async () => {
                    await loadYouTubeAPI();

                    if (!isMounted) return;

                    // Wait for DOM element to be ready
                    const container = document.getElementById(playerId);
                    if (!container) {
                        console.error('Player container not found');
                        return;
                    }

                    cleanupPlayer();

                    try {
                        playerRef.current = new window.YT.Player(playerId, {
                            height: '100%',
                            width: '100%',
                            videoId: videoId,
                            playerVars: {
                                autoplay: 0,
                                modestbranding: 1,
                                rel: 0,
                                enablejsapi: 1,
                                fs: 1,
                                cc_load_policy: 1,  // Enable captions by default
                                cc_lang_pref: 'en'  // Prefer English captions
                            },
                            events: {
                                onReady: () => {
                                    if (isMounted) setIsReady(true);
                                },
                                onError: (event) => {
                                    console.error('YouTube Player Error:', event.data);
                                    if (isMounted) {
                                        setPlayerError(`Video error (code: ${event.data})`);
                                    }
                                },
                                onStateChange: (event) => {
                                    if (!isMounted) return;
                                    if (event.data === window.YT.PlayerState.PLAYING) {
                                        // Clear existing interval
                                        if (playerRef.current._timeInterval) {
                                            clearInterval(playerRef.current._timeInterval);
                                        }
                                        // Track watch time start
                                        playerRef.current._watchTimeStart = Date.now();
                                        // Time update interval
                                        const interval = setInterval(() => {
                                            if (playerRef.current && playerRef.current.getCurrentTime) {
                                                try {
                                                    onTimeUpdate(playerRef.current.getCurrentTime());
                                                } catch (e) {}
                                            }
                                        }, 1000);
                                        playerRef.current._timeInterval = interval;
                                    } else {
                                        // Video stopped/paused
                                        if (playerRef.current && playerRef.current._timeInterval) {
                                            clearInterval(playerRef.current._timeInterval);
                                        }
                                        // Calculate and report watch time
                                        if (playerRef.current?._watchTimeStart && onWatchTime) {
                                            const watchedSeconds = Math.round((Date.now() - playerRef.current._watchTimeStart) / 1000);
                                            if (watchedSeconds > 0) {
                                                onWatchTime(videoId, watchedSeconds);
                                            }
                                            playerRef.current._watchTimeStart = null;
                                        }
                                    }
                                }
                            }
                        });
                    } catch (e) {
                        console.error('Player initialization error:', e);
                        if (isMounted) {
                            setPlayerError('Failed to initialize player');
                        }
                    }
                };

                // Small delay to ensure DOM is ready
                const timer = setTimeout(initPlayer, 100);

                return () => {
                    isMounted = false;
                    clearTimeout(timer);
                    cleanupPlayer();
                };
            }, [videoId, playerId]);

            if (!videoId) {
                return (
                    <div className="w-full h-full bg-gray-800 rounded-lg flex items-center justify-center">
                        <div className="text-center text-gray-400">
                            <Icons.Bookmark />
                            <p className="mt-2">Select a video or add a new bookmark</p>
                        </div>
                    </div>
                );
            }

            if (playerError) {
                return (
                    <div className="w-full h-full bg-gray-800 rounded-lg flex flex-col items-center justify-center">
                        <div className="text-center text-gray-400">
                            <p className="text-emerald-400 mb-2">{playerError}</p>
                            <a
                                href={`https://www.youtube.com/watch?v=${videoId}`}
                                target="_blank"
                                rel="noopener noreferrer"
                                className="text-emerald-500 hover:text-emerald-400 underline"
                            >
                                Watch on YouTube
                            </a>
                        </div>
                    </div>
                );
            }

            return <div id={playerId} className="w-full h-full rounded-lg overflow-hidden" />;
        };

        // Note Item Component
        const NoteItem = ({ note, onSeek, onDelete, onEdit, searchTerm }) => {
            const [isEditing, setIsEditing] = useState(false);
            const [editText, setEditText] = useState(note.text);
            const [showOriginal, setShowOriginal] = useState(false);

            const handleSave = () => {
                onEdit(note.id, editText);
                setIsEditing(false);
            };

            // Highlight search term in text
            const highlightText = (text, term) => {
                if (!term) return text;
                const regex = new RegExp(`(${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                const parts = text.split(regex);
                return parts.map((part, i) =>
                    regex.test(part) ? <mark key={i} className="bg-yellow-500 text-gray-900 px-0.5 rounded">{part}</mark> : part
                );
            };

            // Format note text to properly render bullet points
            const formatNoteText = (text, term) => {
                // Check if text contains bullet points (lines starting with "- ")
                const lines = text.split('\n');
                const hasBullets = lines.some(line => line.trim().startsWith('- '));

                if (hasBullets) {
                    return (
                        <ul className="list-none space-y-1">
                            {lines.map((line, idx) => {
                                const trimmedLine = line.trim();
                                if (trimmedLine.startsWith('- ')) {
                                    const bulletContent = trimmedLine.substring(2);
                                    return (
                                        <li key={idx} className="flex items-start gap-2">
                                            <span className="text-emerald-400 mt-0.5">•</span>
                                            <span>{highlightText(bulletContent, term)}</span>
                                        </li>
                                    );
                                } else if (trimmedLine) {
                                    return <li key={idx}>{highlightText(trimmedLine, term)}</li>;
                                }
                                return null;
                            }).filter(Boolean)}
                        </ul>
                    );
                }

                return highlightText(text, term);
            };

            return (
                <div className={`bg-gray-800 rounded-lg p-3 mb-2 hover:bg-gray-750 transition-colors ${searchTerm ? 'ring-1 ring-yellow-500/30' : ''}`}>
                    <div className="flex items-start justify-between gap-2">
                        <div className="flex items-center gap-2">
                            <button
                                onClick={() => onSeek(note.timestamp)}
                                className="flex items-center gap-1 text-emerald-400 hover:text-emerald-300 text-sm font-medium shrink-0"
                            >
                                <Icons.Play />
                                {formatTime(note.timestamp)}
                            </button>
                            {note.enhanced && (
                                <button
                                    onClick={() => setShowOriginal(!showOriginal)}
                                    className={`text-xs px-2 py-0.5 rounded-full transition-colors ${
                                        showOriginal
                                            ? 'bg-purple-500 text-white'
                                            : 'bg-purple-500/20 text-purple-400 hover:bg-purple-500/30'
                                    }`}
                                    title={showOriginal ? 'Show enhanced note' : 'Show original note'}
                                >
                                    {showOriginal ? 'Original' : 'Enhanced'}
                                </button>
                            )}
                        </div>
                        <div className="flex gap-1">
                            <button
                                onClick={() => setIsEditing(true)}
                                className="p-1 hover:bg-gray-700 rounded text-gray-400 hover:text-gray-200"
                                title="Edit note"
                            >
                                <Icons.Edit />
                            </button>
                            <button
                                onClick={() => onDelete(note.id)}
                                className="p-1 hover:bg-gray-700 rounded text-gray-400 hover:text-emerald-400"
                                title="Delete note"
                            >
                                <Icons.Trash />
                            </button>
                        </div>
                    </div>
                    {isEditing ? (
                        <div className="mt-2">
                            <textarea
                                value={editText}
                                onChange={(e) => setEditText(e.target.value)}
                                className="w-full bg-gray-700 rounded p-2 text-sm text-gray-100 resize-none"
                                rows={3}
                                autoFocus
                            />
                            <div className="flex gap-2 mt-2">
                                <button
                                    onClick={handleSave}
                                    className="px-3 py-1 bg-emerald-500 hover:bg-emerald-600 rounded text-sm"
                                >
                                    Save
                                </button>
                                <button
                                    onClick={() => {
                                        setIsEditing(false);
                                        setEditText(note.text);
                                    }}
                                    className="px-3 py-1 bg-gray-600 hover:bg-gray-500 rounded text-sm"
                                >
                                    Cancel
                                </button>
                            </div>
                        </div>
                    ) : (
                        <div className="mt-2 text-sm text-gray-300">
                            {showOriginal && note.originalText ? (
                                <div>
                                    <div className="text-xs text-purple-400 mb-1">Original note:</div>
                                    <div className="bg-gray-700/50 p-2 rounded">{formatNoteText(note.originalText, searchTerm)}</div>
                                </div>
                            ) : (
                                formatNoteText(note.text, searchTerm)
                            )}
                        </div>
                    )}
                </div>
            );
        };

        // Video Card Component
        const VideoCard = ({ video, isActive, onClick, onDelete, onEdit, onShare, onFetchPublishDate, isFetchingDate, isShared }) => (
            <div
                onClick={onClick}
                className={`cursor-pointer rounded-lg overflow-hidden transition-all ${
                    isActive ? 'ring-2 ring-emerald-500' : 'hover:ring-2 hover:ring-gray-600'
                }`}
            >
                <div className="relative group">
                    <img
                        src={`https://img.youtube.com/vi/${video.videoId}/mqdefault.jpg`}
                        alt={video.title}
                        className="w-full aspect-video object-cover"
                    />
                    <div className="absolute bottom-2 right-2 bg-black/80 px-2 py-0.5 rounded text-xs">
                        {video.notes?.length || 0} notes
                    </div>
                    {/* Action buttons */}
                    <div className="absolute top-2 right-2 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                        {onShare && !isShared && (
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onShare(video);
                                }}
                                className="bg-blue-500 hover:bg-blue-600 p-2 rounded-lg"
                                title="Share video"
                            >
                                <Icons.Share />
                            </button>
                        )}
                        {onEdit && (
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onEdit(video.id);
                                }}
                                className="bg-emerald-500 hover:bg-emerald-600 p-2 rounded-lg"
                                title="Edit video"
                            >
                                <Icons.Edit />
                            </button>
                        )}
                    </div>
                    {/* Shared badge */}
                    {isShared && (
                        <div className="absolute top-2 left-2 bg-blue-500/90 px-2 py-0.5 rounded text-xs flex items-center gap-1">
                            <Icons.Users />
                            <span>Shared</span>
                        </div>
                    )}
                </div>
                <div className="p-3 bg-gray-800">
                    <h3 className="font-medium text-sm line-clamp-2">{video.title}</h3>
                    <div className="flex flex-wrap gap-1 mt-2">
                        {video.tags?.slice(0, 3).map(tag => (
                            <span key={tag} className="text-xs bg-gray-700 px-2 py-0.5 rounded-full text-gray-300">
                                {tag}
                            </span>
                        ))}
                    </div>
                    <div className="mt-2 text-xs">
                        {video.publishDate ? (
                            <div className="flex items-center gap-1 text-gray-400">
                                <Icons.Calendar />
                                <span>{formatPublishDate(video.publishDate)}</span>
                            </div>
                        ) : (
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onFetchPublishDate(video.id, video.videoId);
                                }}
                                disabled={isFetchingDate}
                                className="flex items-center gap-1 text-blue-400 hover:text-blue-300 disabled:opacity-50"
                            >
                                <Icons.Calendar />
                                <span>{isFetchingDate ? 'Fetching...' : 'Get Publish Date'}</span>
                            </button>
                        )}
                    </div>
                </div>
            </div>
        );

        // Auto-tagging keywords map
        const TAG_KEYWORDS = {
            'tutorial': ['tutorial', 'how to', 'learn', 'guide', 'step by step', 'beginner', 'course', 'lesson'],
            'coding': ['code', 'coding', 'programming', 'developer', 'software', 'engineer'],
            'javascript': ['javascript', 'js', 'node', 'react', 'vue', 'angular', 'typescript'],
            'python': ['python', 'django', 'flask', 'pandas', 'numpy'],
            'web development': ['web dev', 'frontend', 'backend', 'fullstack', 'html', 'css'],
            'gaming': ['game', 'gaming', 'playthrough', 'walkthrough', 'gameplay', 'lets play'],
            'music': ['music', 'song', 'album', 'concert', 'live performance', 'cover', 'remix'],
            'podcast': ['podcast', 'interview', 'conversation', 'talk', 'discussion'],
            'review': ['review', 'unboxing', 'first look', 'hands on', 'comparison'],
            'vlog': ['vlog', 'day in the life', 'daily', 'routine'],
            'education': ['explained', 'education', 'documentary', 'history', 'science', 'physics', 'math'],
            'fitness': ['workout', 'fitness', 'exercise', 'gym', 'yoga', 'training'],
            'cooking': ['recipe', 'cooking', 'food', 'chef', 'kitchen', 'baking'],
            'tech': ['tech', 'technology', 'gadget', 'iphone', 'android', 'apple', 'google'],
            'ai': ['ai', 'artificial intelligence', 'machine learning', 'chatgpt', 'openai', 'llm', 'neural'],
            'design': ['design', 'figma', 'ui', 'ux', 'graphic', 'photoshop', 'illustrator'],
            'business': ['business', 'startup', 'entrepreneur', 'marketing', 'finance', 'investing'],
            'motivation': ['motivation', 'inspiration', 'success', 'mindset', 'productivity']
        };

        // Category keywords for auto-categorization
        const CATEGORY_KEYWORDS = {
            'Technology': ['tech', 'coding', 'programming', 'software', 'developer', 'javascript', 'python', 'react', 'ai', 'machine learning'],
            'Education': ['tutorial', 'learn', 'course', 'lesson', 'explained', 'education', 'how to', 'guide'],
            'Entertainment': ['gaming', 'music', 'vlog', 'comedy', 'entertainment', 'funny', 'movie', 'film'],
            'Lifestyle': ['fitness', 'cooking', 'recipe', 'vlog', 'routine', 'travel', 'fashion'],
            'Business': ['business', 'startup', 'marketing', 'finance', 'investing', 'entrepreneur'],
            'Creative': ['design', 'art', 'music', 'photography', 'video editing', 'creative']
        };

        // Function to extract tags from title
        const extractTagsFromTitle = (title) => {
            const titleLower = title.toLowerCase();
            const foundTags = new Set();

            for (const [tag, keywords] of Object.entries(TAG_KEYWORDS)) {
                for (const keyword of keywords) {
                    if (titleLower.includes(keyword.toLowerCase())) {
                        foundTags.add(tag);
                        break;
                    }
                }
            }

            return Array.from(foundTags).slice(0, 5); // Limit to 5 tags
        };

        // Function to suggest category based on title
        const suggestCategory = (title, categories) => {
            const titleLower = title.toLowerCase();
            let bestMatch = { id: '', score: 0 };

            for (const cat of categories) {
                const catNameLower = cat.name.toLowerCase();
                let score = 0;

                // Check if category name matches any category keywords
                for (const [catType, keywords] of Object.entries(CATEGORY_KEYWORDS)) {
                    if (catNameLower.includes(catType.toLowerCase()) || catType.toLowerCase().includes(catNameLower)) {
                        for (const keyword of keywords) {
                            if (titleLower.includes(keyword)) {
                                score += 1;
                            }
                        }
                    }
                }

                // Direct match with category name
                if (titleLower.includes(catNameLower)) {
                    score += 3;
                }

                if (score > bestMatch.score) {
                    bestMatch = { id: cat.id, score };
                }
            }

            return bestMatch.score > 0 ? bestMatch.id : '';
        };

        // Add Video Modal
        const AddVideoModal = ({ isOpen, onClose, onAdd, categories, onAddCategory }) => {
            const [url, setUrl] = useState('');
            const [title, setTitle] = useState('');
            const [selectedCategory, setSelectedCategory] = useState('');
            const [tags, setTags] = useState('');
            const [publishDate, setPublishDate] = useState('');
            const [error, setError] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [autoFetched, setAutoFetched] = useState(false);
            const [isCreatingNewCategory, setIsCreatingNewCategory] = useState(false);
            const [newCategoryName, setNewCategoryName] = useState('');
            const [categoryError, setCategoryError] = useState('');

            // Fetch video metadata when URL changes
            const fetchVideoMetadata = async (videoUrl) => {
                const videoId = extractVideoId(videoUrl);
                if (!videoId) return;

                setIsLoading(true);
                setError('');

                try {
                    // Use YouTube oEmbed API (no API key required)
                    const response = await fetch(
                        `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`
                    );

                    if (!response.ok) {
                        throw new Error('Could not fetch video info');
                    }

                    const data = await response.json();
                    const videoTitle = data.title || '';

                    // Set title
                    setTitle(videoTitle);

                    // Auto-generate tags from title
                    const autoTags = extractTagsFromTitle(videoTitle);
                    setTags(autoTags.join(', '));

                    // Auto-suggest category
                    const suggestedCategory = suggestCategory(videoTitle, categories);
                    if (suggestedCategory) {
                        setSelectedCategory(suggestedCategory);
                    }

                    // Try to fetch publish date from noembed (includes upload_date)
                    try {
                        const noembedResponse = await fetch(
                            `https://noembed.com/embed?url=https://www.youtube.com/watch?v=${videoId}`
                        );
                        const noembedData = await noembedResponse.json();
                        if (noembedData.upload_date) {
                            setPublishDate(noembedData.upload_date);
                        }
                    } catch (e) {
                        // Publish date is optional, don't fail if we can't get it
                        console.log('Could not fetch publish date');
                    }

                    setAutoFetched(true);
                } catch (err) {
                    console.log('Could not auto-fetch metadata:', err);
                    // Don't show error - just leave fields empty for manual entry
                } finally {
                    setIsLoading(false);
                }
            };

            // Handle URL input change with debounce
            const handleUrlChange = (e) => {
                const newUrl = e.target.value;
                setUrl(newUrl);
                setError('');
                setAutoFetched(false);

                // Check if it's a valid YouTube URL and fetch metadata
                const videoId = extractVideoId(newUrl);
                if (videoId && newUrl.length > 10) {
                    fetchVideoMetadata(newUrl);
                }
            };

            const handleSubmit = (e) => {
                e.preventDefault();
                const videoId = extractVideoId(url);
                if (!videoId) {
                    setError('Invalid YouTube URL');
                    return;
                }

                let categoryIdToUse = selectedCategory;

                // If creating a new category, validate and create it first
                if (isCreatingNewCategory) {
                    const trimmedName = newCategoryName.trim();
                    if (!trimmedName) {
                        setCategoryError('Category name cannot be empty');
                        return;
                    }

                    // Check for duplicate category names (case-insensitive)
                    if (categories.some(c => c.name.toLowerCase() === trimmedName.toLowerCase())) {
                        setCategoryError('A category with this name already exists');
                        return;
                    }

                    // Create new category
                    const newCategory = {
                        id: generateId(),
                        name: trimmedName
                    };
                    onAddCategory(newCategory);
                    categoryIdToUse = newCategory.id;
                }

                onAdd({
                    id: generateId(),
                    videoId,
                    title: title || `Video ${videoId}`,
                    category: categoryIdToUse,
                    tags: tags.split(',').map(t => t.trim()).filter(Boolean),
                    notes: [],
                    publishDate: publishDate || null,
                    createdAt: new Date().toISOString()
                });
                setUrl('');
                setTitle('');
                setSelectedCategory('');
                setTags('');
                setPublishDate('');
                setError('');
                setAutoFetched(false);
                setIsCreatingNewCategory(false);
                setNewCategoryName('');
                setCategoryError('');
                onClose();
            };

            // Reset state when modal closes
            useEffect(() => {
                if (!isOpen) {
                    setUrl('');
                    setTitle('');
                    setSelectedCategory('');
                    setTags('');
                    setPublishDate('');
                    setError('');
                    setIsLoading(false);
                    setAutoFetched(false);
                    setIsCreatingNewCategory(false);
                    setNewCategoryName('');
                    setCategoryError('');
                }
            }, [isOpen]);

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-md p-6">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold">Add New Video</h2>
                            <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div>
                                <label className="block text-sm text-gray-400 mb-1">YouTube URL *</label>
                                <div className="relative">
                                    <input
                                        type="text"
                                        value={url}
                                        onChange={handleUrlChange}
                                        placeholder="https://youtube.com/watch?v=..."
                                        className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                        required
                                    />
                                    {isLoading && (
                                        <div className="absolute right-3 top-1/2 -translate-y-1/2">
                                            <svg className="animate-spin h-5 w-5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                            </svg>
                                        </div>
                                    )}
                                </div>
                                {error && <p className="text-emerald-400 text-sm mt-1">{error}</p>}
                                {autoFetched && !isLoading && (
                                    <p className="text-green-400 text-sm mt-1 flex items-center gap-1">
                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                                        </svg>
                                        Auto-filled from video
                                    </p>
                                )}
                            </div>
                            <div>
                                <label className="block text-sm text-gray-400 mb-1">
                                    Title {autoFetched && <span className="text-green-400 text-xs">(auto-filled)</span>}
                                </label>
                                <input
                                    type="text"
                                    value={title}
                                    onChange={(e) => setTitle(e.target.value)}
                                    placeholder="Video title (optional)"
                                    className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                />
                            </div>
                            <div>
                                <label className="block text-sm text-gray-400 mb-1">
                                    Category {selectedCategory && autoFetched && <span className="text-green-400 text-xs">(auto-suggested)</span>}
                                </label>
                                <div className="flex gap-2 mb-2">
                                    <button
                                        type="button"
                                        onClick={() => {
                                            setIsCreatingNewCategory(false);
                                            setNewCategoryName('');
                                            setCategoryError('');
                                        }}
                                        className={`flex-1 px-3 py-1 rounded-lg text-sm font-medium transition-colors ${
                                            !isCreatingNewCategory
                                                ? 'bg-emerald-500 text-white'
                                                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                        }`}
                                    >
                                        Select
                                    </button>
                                    <button
                                        type="button"
                                        onClick={() => {
                                            setIsCreatingNewCategory(true);
                                            setSelectedCategory('');
                                            setCategoryError('');
                                        }}
                                        className={`flex-1 px-3 py-1 rounded-lg text-sm font-medium transition-colors ${
                                            isCreatingNewCategory
                                                ? 'bg-emerald-500 text-white'
                                                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                        }`}
                                    >
                                        Create New
                                    </button>
                                </div>
                                {isCreatingNewCategory ? (
                                    <div>
                                        <input
                                            type="text"
                                            value={newCategoryName}
                                            onChange={(e) => {
                                                setNewCategoryName(e.target.value);
                                                setCategoryError('');
                                            }}
                                            placeholder="New category name"
                                            className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                        />
                                        {categoryError && <p className="text-emerald-400 text-sm mt-1">{categoryError}</p>}
                                    </div>
                                ) : (
                                    <select
                                        value={selectedCategory}
                                        onChange={(e) => setSelectedCategory(e.target.value)}
                                        className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                    >
                                        <option value="">No category</option>
                                        {categories.map(cat => (
                                            <option key={cat.id} value={cat.id}>{cat.name}</option>
                                        ))}
                                    </select>
                                )}
                            </div>
                            <div>
                                <label className="block text-sm text-gray-400 mb-1">
                                    Tags {tags && autoFetched && <span className="text-green-400 text-xs">(auto-generated)</span>}
                                </label>
                                <input
                                    type="text"
                                    value={tags}
                                    onChange={(e) => setTags(e.target.value)}
                                    placeholder="tutorial, react, coding (comma separated)"
                                    className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                />
                            </div>
                            <button
                                type="submit"
                                disabled={isLoading}
                                className="w-full bg-emerald-500 hover:bg-emerald-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-medium py-2 rounded-lg transition-colors"
                            >
                                {isLoading ? 'Loading...' : 'Add Video'}
                            </button>
                        </form>
                    </div>
                </div>
            );
        };

        // Edit Video Modal
        const EditVideoModal = ({ isOpen, onClose, video, onSave, categories, onAddCategory }) => {
            const [title, setTitle] = useState('');
            const [selectedCategory, setSelectedCategory] = useState('');
            const [tags, setTags] = useState('');
            const [error, setError] = useState('');
            const [isCreatingNewCategory, setIsCreatingNewCategory] = useState(false);
            const [newCategoryName, setNewCategoryName] = useState('');
            const [categoryError, setCategoryError] = useState('');

            // Initialize state when modal opens
            useEffect(() => {
                if (isOpen && video) {
                    setTitle(video.title || '');
                    setSelectedCategory(video.category || '');
                    setTags(video.tags?.join(', ') || '');
                    setError('');
                    setIsCreatingNewCategory(false);
                    setNewCategoryName('');
                    setCategoryError('');
                }
            }, [isOpen, video]);

            const handleSubmit = (e) => {
                e.preventDefault();
                if (!title.trim()) {
                    setError('Title cannot be empty');
                    return;
                }

                let categoryIdToUse = selectedCategory;

                // If creating a new category, validate and create it first
                if (isCreatingNewCategory) {
                    const trimmedName = newCategoryName.trim();
                    if (!trimmedName) {
                        setCategoryError('Category name cannot be empty');
                        return;
                    }

                    // Check for duplicate category names (case-insensitive)
                    if (categories.some(c => c.name.toLowerCase() === trimmedName.toLowerCase())) {
                        setCategoryError('A category with this name already exists');
                        return;
                    }

                    // Create new category
                    const newCategory = {
                        id: generateId(),
                        name: trimmedName
                    };
                    onAddCategory(newCategory);
                    categoryIdToUse = newCategory.id;
                }

                onSave({
                    title: title.trim(),
                    category: categoryIdToUse,
                    tags: tags.split(',').map(t => t.trim()).filter(Boolean)
                });
                onClose();
            };

            if (!isOpen || !video) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-md p-6">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold">Edit Video</h2>
                            <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div>
                                <label className="block text-sm text-gray-400 mb-1">Title *</label>
                                <input
                                    type="text"
                                    value={title}
                                    onChange={(e) => {
                                        setTitle(e.target.value);
                                        setError('');
                                    }}
                                    placeholder="Video title"
                                    className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                />
                                {error && <p className="text-emerald-400 text-sm mt-1">{error}</p>}
                            </div>
                            <div>
                                <label className="block text-sm text-gray-400 mb-1">Category</label>
                                <div className="flex gap-2 mb-2">
                                    <button
                                        type="button"
                                        onClick={() => {
                                            setIsCreatingNewCategory(false);
                                            setNewCategoryName('');
                                            setCategoryError('');
                                        }}
                                        className={`flex-1 px-3 py-1 rounded-lg text-sm font-medium transition-colors ${
                                            !isCreatingNewCategory
                                                ? 'bg-emerald-500 text-white'
                                                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                        }`}
                                    >
                                        Select
                                    </button>
                                    <button
                                        type="button"
                                        onClick={() => {
                                            setIsCreatingNewCategory(true);
                                            setSelectedCategory('');
                                            setCategoryError('');
                                        }}
                                        className={`flex-1 px-3 py-1 rounded-lg text-sm font-medium transition-colors ${
                                            isCreatingNewCategory
                                                ? 'bg-emerald-500 text-white'
                                                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                        }`}
                                    >
                                        Create New
                                    </button>
                                </div>
                                {isCreatingNewCategory ? (
                                    <div>
                                        <input
                                            type="text"
                                            value={newCategoryName}
                                            onChange={(e) => {
                                                setNewCategoryName(e.target.value);
                                                setCategoryError('');
                                            }}
                                            placeholder="New category name"
                                            className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                        />
                                        {categoryError && <p className="text-emerald-400 text-sm mt-1">{categoryError}</p>}
                                    </div>
                                ) : (
                                    <select
                                        value={selectedCategory}
                                        onChange={(e) => setSelectedCategory(e.target.value)}
                                        className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                    >
                                        <option value="">No category</option>
                                        {categories.map(cat => (
                                            <option key={cat.id} value={cat.id}>{cat.name}</option>
                                        ))}
                                    </select>
                                )}
                            </div>
                            <div>
                                <label className="block text-sm text-gray-400 mb-1">Tags</label>
                                <input
                                    type="text"
                                    value={tags}
                                    onChange={(e) => setTags(e.target.value)}
                                    placeholder="tutorial, react, coding (comma separated)"
                                    className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                />
                            </div>
                            <button
                                type="submit"
                                className="w-full bg-emerald-500 hover:bg-emerald-600 text-white font-medium py-2 rounded-lg transition-colors"
                            >
                                Save Changes
                            </button>
                        </form>
                    </div>
                </div>
            );
        };

        // Category Manager Modal
        const CategoryModal = ({ isOpen, onClose, categories, onAdd, onDelete, onEdit }) => {
            const [newCat, setNewCat] = useState('');
            const [editingId, setEditingId] = useState(null);
            const [editingName, setEditingName] = useState('');

            const handleAdd = (e) => {
                e.preventDefault();
                if (newCat.trim()) {
                    onAdd({ id: generateId(), name: newCat.trim() });
                    setNewCat('');
                }
            };

            const handleEditStart = (catId, catName) => {
                setEditingId(catId);
                setEditingName(catName);
            };

            const handleEditSave = () => {
                if (editingName.trim() && onEdit) {
                    onEdit(editingId, editingName.trim());
                    setEditingId(null);
                    setEditingName('');
                }
            };

            const handleEditCancel = () => {
                setEditingId(null);
                setEditingName('');
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-md p-6">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold">Manage Categories</h2>
                            <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>
                        <form onSubmit={handleAdd} className="flex gap-2 mb-4">
                            <input
                                type="text"
                                value={newCat}
                                onChange={(e) => setNewCat(e.target.value)}
                                placeholder="New category name"
                                className="flex-1 bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                            />
                            <button
                                type="submit"
                                className="px-4 py-2 bg-emerald-500 hover:bg-emerald-600 rounded-lg"
                            >
                                Add
                            </button>
                        </form>
                        <div className="space-y-2 max-h-60 overflow-y-auto">
                            {categories.map(cat => (
                                <div key={cat.id} className="flex items-center justify-between bg-gray-700 rounded-lg px-4 py-2">
                                    {editingId === cat.id ? (
                                        <div className="flex-1 flex gap-2 items-center">
                                            <input
                                                type="text"
                                                value={editingName}
                                                onChange={(e) => setEditingName(e.target.value)}
                                                autoFocus
                                                className="flex-1 bg-gray-600 rounded px-2 py-1 text-gray-100 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                            />
                                            <button
                                                onClick={handleEditSave}
                                                className="px-2 py-1 bg-green-600 hover:bg-green-700 rounded text-xs text-white"
                                            >
                                                Save
                                            </button>
                                            <button
                                                onClick={handleEditCancel}
                                                className="px-2 py-1 bg-gray-600 hover:bg-gray-500 rounded text-xs text-gray-300"
                                            >
                                                Cancel
                                            </button>
                                        </div>
                                    ) : (
                                        <>
                                            <span
                                                onClick={() => handleEditStart(cat.id, cat.name)}
                                                className="flex-1 cursor-pointer hover:text-emerald-400 transition-colors"
                                                title="Click to edit"
                                            >
                                                {cat.name}
                                            </span>
                                            <button
                                                onClick={() => onDelete(cat.id)}
                                                className="p-1 hover:bg-gray-600 rounded text-gray-400 hover:text-emerald-400"
                                            >
                                                <Icons.Trash />
                                            </button>
                                        </>
                                    )}
                                </div>
                            ))}
                            {categories.length === 0 && (
                                <p className="text-gray-400 text-center py-4">No categories yet</p>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // Settings Modal
        const SettingsModal = ({ isOpen, onClose, apiStatus, contextWordCount, onSaveContextWordCount, onOpenProfile }) => {
            const [contextWords, setContextWords] = useState(contextWordCount);

            useEffect(() => {
                setContextWords(contextWordCount);
            }, [contextWordCount, isOpen]);

            const handleSave = () => {
                onSaveContextWordCount(contextWords);
                onClose();
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-md p-6 max-h-[90vh] overflow-y-auto">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold">Settings</h2>
                            <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>
                        <div className="space-y-4">
                            {/* Edit Profile Button */}
                            <button
                                onClick={() => {
                                    onClose();
                                    onOpenProfile();
                                }}
                                className="w-full flex items-center gap-3 bg-gray-700/50 hover:bg-gray-700 rounded-lg px-4 py-3 transition-colors"
                            >
                                <svg className="w-5 h-5 text-emerald-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                                </svg>
                                <div className="text-left">
                                    <p className="text-gray-200 font-medium">Edit Profile</p>
                                    <p className="text-xs text-gray-500">Update your name, email, and interests</p>
                                </div>
                                <svg className="w-5 h-5 text-gray-500 ml-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                                </svg>
                            </button>

                            {/* API Status */}
                            <div>
                                <label className="block text-sm text-gray-400 mb-2">Server API Status</label>
                                <div className="space-y-2">
                                    <div className="flex items-center justify-between bg-gray-700/50 rounded-lg px-4 py-3">
                                        <div className="flex items-center gap-2">
                                            <span className="text-gray-300">Gemini AI</span>
                                            <span className="text-xs text-gray-500">(Note enhancement)</span>
                                        </div>
                                        {apiStatus.geminiConfigured ? (
                                            <span className="flex items-center gap-1 text-green-400 text-sm">
                                                <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                                                </svg>
                                                Configured
                                            </span>
                                        ) : (
                                            <span className="flex items-center gap-1 text-gray-500 text-sm">
                                                <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                                                </svg>
                                                Not configured
                                            </span>
                                        )}
                                    </div>
                                    <div className="flex items-center justify-between bg-gray-700/50 rounded-lg px-4 py-3">
                                        <div className="flex items-center gap-2">
                                            <span className="text-gray-300">YouTube Data</span>
                                            <span className="text-xs text-gray-500">(Publish dates)</span>
                                        </div>
                                        {apiStatus.youtubeConfigured ? (
                                            <span className="flex items-center gap-1 text-green-400 text-sm">
                                                <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                                                </svg>
                                                Configured
                                            </span>
                                        ) : (
                                            <span className="flex items-center gap-1 text-gray-500 text-sm">
                                                <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                                                </svg>
                                                Not configured
                                            </span>
                                        )}
                                    </div>
                                </div>
                            </div>

                            {/* Context Word Count Setting */}
                            <div>
                                <label className="block text-sm text-gray-400 mb-1">
                                    Transcript Context Word Count
                                </label>
                                <p className="text-xs text-gray-500 mb-2">
                                    Number of words before and after the timestamp when loading context
                                </p>
                                <input
                                    type="number"
                                    min="5"
                                    max="100"
                                    value={contextWords}
                                    onChange={(e) => setContextWords(parseInt(e.target.value, 10) || 10)}
                                    className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                />
                                <p className="text-xs text-gray-500 mt-1">
                                    Default: 10 words. Will load ±{contextWords} words around timestamp.
                                </p>
                            </div>

                            <div className="bg-gray-700/50 rounded-lg p-3 text-sm text-gray-400">
                                <p className="font-medium text-gray-300 mb-1">🔒 Privacy & Security</p>
                                <p>API keys are stored securely on the server. Your data is processed through server-side proxies to protect credentials.</p>
                            </div>
                            <button
                                onClick={handleSave}
                                className="w-full bg-emerald-500 hover:bg-emerald-600 text-white font-medium py-2 rounded-lg transition-colors"
                            >
                                Save Settings
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // YouTube interest categories for profile
        const YOUTUBE_CATEGORIES = [
            'Music',
            'Education',
            'Gaming',
            'Entertainment',
            'Science & Technology',
            'Howto & Style',
            'Sports',
            'News & Politics',
            'Comedy',
            'Film & Animation'
        ];

        // Profile Modal Component
        const ProfileModal = ({ isOpen, onClose, serverUrl, authToken, currentUser }) => {
            const [profile, setProfile] = useState({
                firstName: '',
                lastName: '',
                email: '',
                interests: []
            });
            const [customInterest, setCustomInterest] = useState('');
            const [isLoading, setIsLoading] = useState(true);
            const [isSaving, setIsSaving] = useState(false);
            const [error, setError] = useState('');
            const [success, setSuccess] = useState('');

            // Load profile data when modal opens
            useEffect(() => {
                if (isOpen && authToken) {
                    loadProfile();
                }
            }, [isOpen, authToken]);

            const loadProfile = async () => {
                setIsLoading(true);
                setError('');
                try {
                    const response = await fetch(`${serverUrl}/api/profile`, {
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        setProfile({
                            firstName: data.profile?.firstName || '',
                            lastName: data.profile?.lastName || '',
                            email: data.profile?.email || '',
                            interests: data.profile?.interests || []
                        });
                    } else {
                        const errorData = await response.json();
                        setError(errorData.error || 'Failed to load profile');
                    }
                } catch (e) {
                    setError('Could not connect to server');
                } finally {
                    setIsLoading(false);
                }
            };

            const handleSave = async () => {
                setIsSaving(true);
                setError('');
                setSuccess('');

                try {
                    const response = await fetch(`${serverUrl}/api/profile`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify({
                            firstName: profile.firstName || null,
                            lastName: profile.lastName || null,
                            email: profile.email || null,
                            interests: profile.interests
                        })
                    });

                    if (response.ok) {
                        setSuccess('Profile saved successfully!');
                        setTimeout(() => setSuccess(''), 3000);
                    } else {
                        const errorData = await response.json();
                        setError(errorData.error || 'Failed to save profile');
                    }
                } catch (e) {
                    setError('Could not connect to server');
                } finally {
                    setIsSaving(false);
                }
            };

            const toggleInterest = (interest) => {
                setProfile(prev => ({
                    ...prev,
                    interests: prev.interests.includes(interest)
                        ? prev.interests.filter(i => i !== interest)
                        : [...prev.interests, interest]
                }));
            };

            const addCustomInterest = () => {
                if (customInterest.trim() && !profile.interests.includes(customInterest.trim())) {
                    setProfile(prev => ({
                        ...prev,
                        interests: [...prev.interests, customInterest.trim()]
                    }));
                    setCustomInterest('');
                }
            };

            const removeInterest = (interest) => {
                setProfile(prev => ({
                    ...prev,
                    interests: prev.interests.filter(i => i !== interest)
                }));
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-md p-6 max-h-[90vh] overflow-y-auto">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold">Edit Profile</h2>
                            <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>

                        {isLoading ? (
                            <div className="flex items-center justify-center py-8">
                                <svg className="animate-spin h-8 w-8 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                            </div>
                        ) : (
                            <div className="space-y-4">
                                {/* Username (read-only) */}
                                <div>
                                    <label className="block text-sm text-gray-400 mb-1">Username</label>
                                    <div className="bg-gray-700/50 rounded-lg px-4 py-2 text-gray-300">
                                        {currentUser?.username}
                                    </div>
                                </div>

                                {/* First Name */}
                                <div>
                                    <label className="block text-sm text-gray-400 mb-1">First Name</label>
                                    <input
                                        type="text"
                                        value={profile.firstName}
                                        onChange={(e) => setProfile(prev => ({ ...prev, firstName: e.target.value }))}
                                        placeholder="Enter your first name"
                                        className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                    />
                                </div>

                                {/* Last Name */}
                                <div>
                                    <label className="block text-sm text-gray-400 mb-1">Last Name</label>
                                    <input
                                        type="text"
                                        value={profile.lastName}
                                        onChange={(e) => setProfile(prev => ({ ...prev, lastName: e.target.value }))}
                                        placeholder="Enter your last name"
                                        className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                    />
                                </div>

                                {/* Email */}
                                <div>
                                    <label className="block text-sm text-gray-400 mb-1">Email</label>
                                    <input
                                        type="email"
                                        value={profile.email}
                                        onChange={(e) => setProfile(prev => ({ ...prev, email: e.target.value }))}
                                        placeholder="Enter your email"
                                        className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                    />
                                </div>

                                {/* Interests */}
                                <div>
                                    <label className="block text-sm text-gray-400 mb-2">Interests</label>
                                    <div className="flex flex-wrap gap-2 mb-3">
                                        {YOUTUBE_CATEGORIES.map(category => (
                                            <button
                                                key={category}
                                                onClick={() => toggleInterest(category)}
                                                className={`px-3 py-1 rounded-full text-sm transition-colors ${
                                                    profile.interests.includes(category)
                                                        ? 'bg-emerald-500 text-white'
                                                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                                }`}
                                            >
                                                {category}
                                            </button>
                                        ))}
                                    </div>

                                    {/* Custom interests */}
                                    {profile.interests.filter(i => !YOUTUBE_CATEGORIES.includes(i)).length > 0 && (
                                        <div className="flex flex-wrap gap-2 mb-3">
                                            {profile.interests.filter(i => !YOUTUBE_CATEGORIES.includes(i)).map(interest => (
                                                <span
                                                    key={interest}
                                                    className="flex items-center gap-1 px-3 py-1 bg-purple-500/20 text-purple-300 rounded-full text-sm"
                                                >
                                                    {interest}
                                                    <button
                                                        onClick={() => removeInterest(interest)}
                                                        className="ml-1 hover:text-red-400"
                                                    >
                                                        <Icons.X />
                                                    </button>
                                                </span>
                                            ))}
                                        </div>
                                    )}

                                    {/* Add custom interest */}
                                    <div className="flex gap-2">
                                        <input
                                            type="text"
                                            value={customInterest}
                                            onChange={(e) => setCustomInterest(e.target.value)}
                                            onKeyDown={(e) => e.key === 'Enter' && addCustomInterest()}
                                            placeholder="Add custom interest..."
                                            className="flex-1 bg-gray-700 rounded-lg px-3 py-1.5 text-sm text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                        />
                                        <button
                                            onClick={addCustomInterest}
                                            disabled={!customInterest.trim()}
                                            className="px-3 py-1.5 bg-gray-600 hover:bg-gray-500 disabled:bg-gray-700 disabled:opacity-50 rounded-lg text-sm transition-colors"
                                        >
                                            Add
                                        </button>
                                    </div>
                                </div>

                                {/* Error/Success Messages */}
                                {error && (
                                    <div className="bg-red-500/20 text-red-400 px-4 py-2 rounded-lg text-sm">
                                        {error}
                                    </div>
                                )}
                                {success && (
                                    <div className="bg-green-500/20 text-green-400 px-4 py-2 rounded-lg text-sm">
                                        {success}
                                    </div>
                                )}

                                {/* Save Button */}
                                <button
                                    onClick={handleSave}
                                    disabled={isSaving}
                                    className="w-full bg-emerald-500 hover:bg-emerald-600 disabled:bg-emerald-700 disabled:cursor-not-allowed text-white font-medium py-2 rounded-lg transition-colors flex items-center justify-center gap-2"
                                >
                                    {isSaving ? (
                                        <>
                                            <svg className="animate-spin h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                            </svg>
                                            Saving...
                                        </>
                                    ) : (
                                        'Save Profile'
                                    )}
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Share Modal Component
        const ShareModal = ({ isOpen, onClose, video, serverUrl, authToken, onShareCreated }) => {
            const [shareType, setShareType] = useState('user'); // 'user' or 'email'
            const [searchQuery, setSearchQuery] = useState('');
            const [searchResults, setSearchResults] = useState([]);
            const [selectedUser, setSelectedUser] = useState(null);
            const [email, setEmail] = useState('');
            const [includeNotes, setIncludeNotes] = useState(true);
            const [isSearching, setIsSearching] = useState(false);
            const [isSharing, setIsSharing] = useState(false);
            const [error, setError] = useState('');
            const [success, setSuccess] = useState('');
            const searchTimeoutRef = useRef(null);

            // Reset state when modal opens
            useEffect(() => {
                if (isOpen) {
                    setShareType('user');
                    setSearchQuery('');
                    setSearchResults([]);
                    setSelectedUser(null);
                    setEmail('');
                    setIncludeNotes(true);
                    setError('');
                    setSuccess('');
                }
            }, [isOpen]);

            // Search users as they type
            useEffect(() => {
                if (shareType !== 'user' || searchQuery.length < 2) {
                    setSearchResults([]);
                    return;
                }

                // Debounce search
                if (searchTimeoutRef.current) {
                    clearTimeout(searchTimeoutRef.current);
                }

                searchTimeoutRef.current = setTimeout(async () => {
                    setIsSearching(true);
                    try {
                        const response = await fetch(
                            `${serverUrl}/api/users/search?q=${encodeURIComponent(searchQuery)}`,
                            { headers: { 'Authorization': `Bearer ${authToken}` } }
                        );
                        if (response.ok) {
                            const results = await response.json();
                            setSearchResults(results);
                        }
                    } catch (e) {
                        console.error('User search error:', e);
                    } finally {
                        setIsSearching(false);
                    }
                }, 300);

                return () => {
                    if (searchTimeoutRef.current) {
                        clearTimeout(searchTimeoutRef.current);
                    }
                };
            }, [searchQuery, shareType, serverUrl, authToken]);

            const handleShare = async () => {
                setError('');
                setSuccess('');

                if (shareType === 'user' && !selectedUser) {
                    setError('Please select a user to share with');
                    return;
                }

                if (shareType === 'email' && !email) {
                    setError('Please enter an email address');
                    return;
                }

                if (shareType === 'email' && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
                    setError('Please enter a valid email address');
                    return;
                }

                setIsSharing(true);

                try {
                    const response = await fetch(`${serverUrl}/api/shares`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify({
                            type: shareType,
                            targetUserId: shareType === 'user' ? selectedUser.userId : null,
                            targetEmail: shareType === 'email' ? email : null,
                            videoId: video.id,
                            youtubeVideoId: video.videoId,
                            videoTitle: video.title,
                            videoThumbnail: video.thumbnail || `https://img.youtube.com/vi/${video.videoId}/mqdefault.jpg`,
                            includeNotes,
                            notes: includeNotes ? video.notes : null
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        setSuccess(shareType === 'user'
                            ? `Video shared with ${selectedUser.username}!`
                            : `Share invitation sent to ${email}!`
                        );
                        if (onShareCreated) onShareCreated(data.share);
                        setTimeout(() => onClose(), 2000);
                    } else {
                        const errorData = await response.json();
                        setError(errorData.error || 'Failed to share');
                    }
                } catch (e) {
                    setError('Could not connect to server');
                } finally {
                    setIsSharing(false);
                }
            };

            if (!isOpen || !video) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-md p-6 max-h-[90vh] overflow-y-auto">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold">Share Video</h2>
                            <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>

                        {/* Video Preview */}
                        <div className="flex gap-3 bg-gray-700/50 rounded-lg p-3 mb-4">
                            <img
                                src={`https://img.youtube.com/vi/${video.videoId}/default.jpg`}
                                alt=""
                                className="w-20 h-14 rounded object-cover"
                            />
                            <div className="flex-1 min-w-0">
                                <p className="text-sm font-medium truncate">{video.title}</p>
                                <p className="text-xs text-gray-400">{video.notes?.length || 0} notes</p>
                            </div>
                        </div>

                        {/* Share Type Tabs */}
                        <div className="flex gap-2 mb-4">
                            <button
                                onClick={() => setShareType('user')}
                                className={`flex-1 py-2 rounded-lg text-sm font-medium transition-colors ${
                                    shareType === 'user'
                                        ? 'bg-emerald-500 text-white'
                                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                }`}
                            >
                                Share with User
                            </button>
                            <button
                                onClick={() => setShareType('email')}
                                className={`flex-1 py-2 rounded-lg text-sm font-medium transition-colors ${
                                    shareType === 'email'
                                        ? 'bg-emerald-500 text-white'
                                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                }`}
                            >
                                Share via Email
                            </button>
                        </div>

                        {/* User Search or Email Input */}
                        {shareType === 'user' ? (
                            <div className="mb-4">
                                <label className="block text-sm text-gray-400 mb-2">Search Users</label>
                                <input
                                    type="text"
                                    value={searchQuery}
                                    onChange={(e) => {
                                        setSearchQuery(e.target.value);
                                        setSelectedUser(null);
                                    }}
                                    placeholder="Type username to search..."
                                    className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                />

                                {/* Search Results */}
                                {searchQuery.length >= 2 && (
                                    <div className="mt-2 bg-gray-700/50 rounded-lg max-h-40 overflow-y-auto">
                                        {isSearching ? (
                                            <div className="p-3 text-center text-gray-400 text-sm">Searching...</div>
                                        ) : searchResults.length > 0 ? (
                                            searchResults.map(user => (
                                                <button
                                                    key={user.userId}
                                                    onClick={() => {
                                                        setSelectedUser(user);
                                                        setSearchQuery(user.username);
                                                    }}
                                                    className={`w-full text-left px-4 py-2 hover:bg-gray-600 transition-colors ${
                                                        selectedUser?.userId === user.userId ? 'bg-emerald-500/20' : ''
                                                    }`}
                                                >
                                                    <span className="text-sm">{user.username}</span>
                                                </button>
                                            ))
                                        ) : (
                                            <div className="p-3 text-center text-gray-400 text-sm">No users found</div>
                                        )}
                                    </div>
                                )}

                                {/* Selected User */}
                                {selectedUser && (
                                    <div className="mt-2 flex items-center gap-2 bg-emerald-500/20 text-emerald-400 rounded-lg px-3 py-2">
                                        <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                            <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                                        </svg>
                                        <span className="text-sm">Sharing with {selectedUser.username}</span>
                                    </div>
                                )}
                            </div>
                        ) : (
                            <div className="mb-4">
                                <label className="block text-sm text-gray-400 mb-2">Email Address</label>
                                <input
                                    type="email"
                                    value={email}
                                    onChange={(e) => setEmail(e.target.value)}
                                    placeholder="Enter email address..."
                                    className="w-full bg-gray-700 rounded-lg px-4 py-2 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                />
                                <p className="text-xs text-gray-500 mt-1">
                                    They'll receive an invitation to join ClipMark
                                </p>
                            </div>
                        )}

                        {/* Include Notes Option */}
                        <label className="flex items-center gap-3 cursor-pointer mb-4 bg-gray-700/50 rounded-lg px-4 py-3">
                            <input
                                type="checkbox"
                                checked={includeNotes}
                                onChange={(e) => setIncludeNotes(e.target.checked)}
                                className="w-4 h-4 rounded accent-emerald-500"
                            />
                            <div>
                                <p className="text-sm text-gray-200">Include notes</p>
                                <p className="text-xs text-gray-500">Share your notes as a snapshot</p>
                            </div>
                        </label>

                        {/* Error/Success Messages */}
                        {error && (
                            <div className="bg-red-500/20 text-red-400 px-4 py-2 rounded-lg text-sm mb-4">
                                {error}
                            </div>
                        )}
                        {success && (
                            <div className="bg-green-500/20 text-green-400 px-4 py-2 rounded-lg text-sm mb-4">
                                {success}
                            </div>
                        )}

                        {/* Share Button */}
                        <button
                            onClick={handleShare}
                            disabled={isSharing || (shareType === 'user' && !selectedUser) || (shareType === 'email' && !email)}
                            className="w-full bg-emerald-500 hover:bg-emerald-600 disabled:bg-gray-700 disabled:cursor-not-allowed text-white font-medium py-2 rounded-lg transition-colors flex items-center justify-center gap-2"
                        >
                            {isSharing ? (
                                <>
                                    <svg className="animate-spin h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    Sharing...
                                </>
                            ) : (
                                <>
                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
                                    </svg>
                                    Share Video
                                </>
                            )}
                        </button>
                    </div>
                </div>
            );
        };

        // Pending Shares Dropdown Component
        const PendingSharesDropdown = ({ serverUrl, authToken, onAcceptShare }) => {
            const [isOpen, setIsOpen] = useState(false);
            const [pendingShares, setPendingShares] = useState([]);
            const [isLoading, setIsLoading] = useState(false);
            const dropdownRef = useRef(null);

            // Load pending shares
            const loadPendingShares = async () => {
                if (!authToken) return;

                setIsLoading(true);
                try {
                    const response = await fetch(`${serverUrl}/api/shares/incoming`, {
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });
                    if (response.ok) {
                        const shares = await response.json();
                        setPendingShares(shares);
                    }
                } catch (e) {
                    console.error('Error loading pending shares:', e);
                } finally {
                    setIsLoading(false);
                }
            };

            // Load on mount and when dropdown opens
            useEffect(() => {
                if (authToken) {
                    loadPendingShares();
                }
            }, [authToken]);

            useEffect(() => {
                if (isOpen) {
                    loadPendingShares();
                }
            }, [isOpen]);

            // Close dropdown when clicking outside
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
                        setIsOpen(false);
                    }
                };

                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            const handleAccept = async (shareId) => {
                try {
                    const response = await fetch(`${serverUrl}/api/shares/${shareId}/accept`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });

                    if (response.ok) {
                        setPendingShares(prev => prev.filter(s => s.id !== shareId));
                        if (onAcceptShare) onAcceptShare();
                    }
                } catch (e) {
                    console.error('Error accepting share:', e);
                }
            };

            const handleDecline = async (shareId) => {
                try {
                    const response = await fetch(`${serverUrl}/api/shares/${shareId}/decline`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });

                    if (response.ok) {
                        setPendingShares(prev => prev.filter(s => s.id !== shareId));
                    }
                } catch (e) {
                    console.error('Error declining share:', e);
                }
            };

            return (
                <div className="relative" ref={dropdownRef}>
                    <button
                        onClick={() => setIsOpen(!isOpen)}
                        className={`p-2 rounded-lg transition-colors relative ${
                            pendingShares.length > 0
                                ? 'bg-emerald-500/20 text-emerald-400 hover:bg-emerald-500/30'
                                : 'bg-gray-700 hover:bg-gray-600'
                        }`}
                        title="Pending shares"
                    >
                        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
                        </svg>
                        {pendingShares.length > 0 && (
                            <span className="absolute -top-1 -right-1 w-5 h-5 bg-emerald-500 text-white text-xs rounded-full flex items-center justify-center">
                                {pendingShares.length}
                            </span>
                        )}
                    </button>

                    {isOpen && (
                        <div className="absolute right-0 mt-2 w-80 bg-gray-800 rounded-lg shadow-xl border border-gray-700 z-50">
                            <div className="p-3 border-b border-gray-700">
                                <h3 className="font-medium text-sm">Pending Shares</h3>
                            </div>

                            <div className="max-h-80 overflow-y-auto">
                                {isLoading ? (
                                    <div className="p-4 text-center text-gray-400 text-sm">Loading...</div>
                                ) : pendingShares.length > 0 ? (
                                    pendingShares.map(share => (
                                        <div key={share.id} className="p-3 border-b border-gray-700 last:border-b-0">
                                            <div className="flex gap-3">
                                                <img
                                                    src={share.videoThumbnail}
                                                    alt=""
                                                    className="w-16 h-10 rounded object-cover"
                                                />
                                                <div className="flex-1 min-w-0">
                                                    <p className="text-sm font-medium truncate">{share.videoTitle}</p>
                                                    <p className="text-xs text-gray-400">
                                                        From <span className="text-emerald-400">{share.ownerUsername}</span>
                                                    </p>
                                                </div>
                                            </div>
                                            <div className="flex gap-2 mt-2">
                                                <button
                                                    onClick={() => handleAccept(share.id)}
                                                    className="flex-1 px-3 py-1.5 bg-emerald-500 hover:bg-emerald-600 text-white text-xs rounded transition-colors"
                                                >
                                                    Accept
                                                </button>
                                                <button
                                                    onClick={() => handleDecline(share.id)}
                                                    className="flex-1 px-3 py-1.5 bg-gray-600 hover:bg-gray-500 text-gray-200 text-xs rounded transition-colors"
                                                >
                                                    Decline
                                                </button>
                                            </div>
                                        </div>
                                    ))
                                ) : (
                                    <div className="p-4 text-center text-gray-400 text-sm">No pending shares</div>
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Enhancement Review Modal for ambiguous AI suggestions
        const EnhancementReviewModal = ({ isOpen, onClose, pendingEnhancements, onApply }) => {
            const [selections, setSelections] = useState([]);
            const [customTexts, setCustomTexts] = useState({});

            useEffect(() => {
                if (pendingEnhancements && pendingEnhancements.length > 0) {
                    // Initialize selections with default values
                    setSelections(pendingEnhancements.map(item => ({
                        noteId: item.noteId,
                        selectedOption: 0,
                        selectedText: item.suggestedSummary
                    })));
                    setCustomTexts({});
                }
            }, [pendingEnhancements]);

            const handleOptionChange = (noteId, optionIndex, text) => {
                setSelections(prev => prev.map(s => {
                    if (s.noteId === noteId) {
                        return { ...s, selectedOption: optionIndex, selectedText: text };
                    }
                    return s;
                }));
            };

            const handleCustomTextChange = (noteId, text) => {
                setCustomTexts(prev => ({ ...prev, [noteId]: text }));
                setSelections(prev => prev.map(s => {
                    if (s.noteId === noteId && s.selectedOption === -1) {
                        return { ...s, selectedText: text };
                    }
                    return s;
                }));
            };

            const handleSelectCustom = (noteId) => {
                const customText = customTexts[noteId] || '';
                setSelections(prev => prev.map(s => {
                    if (s.noteId === noteId) {
                        return { ...s, selectedOption: -1, selectedText: customText };
                    }
                    return s;
                }));
            };

            const handleApply = () => {
                onApply(selections);
            };

            const handleSkipAll = () => {
                onClose();
            };

            if (!isOpen || !pendingEnhancements || pendingEnhancements.length === 0) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl w-full max-w-2xl p-6 max-h-[90vh] overflow-y-auto">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-semibold">Review AI Suggestions</h2>
                            <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded">
                                <Icons.X />
                            </button>
                        </div>
                        <p className="text-gray-400 text-sm mb-4">
                            The AI found some notes that could have multiple interpretations. Please select the best option for each:
                        </p>
                        <div className="space-y-6">
                            {pendingEnhancements.map((item, idx) => {
                                const currentSelection = selections.find(s => s.noteId === item.noteId);
                                return (
                                    <div key={item.noteId} className="bg-gray-700/50 rounded-lg p-4">
                                        <div className="flex items-center gap-2 mb-2">
                                            <span className="text-emerald-400 font-medium">[{formatTime(item.timestamp)}]</span>
                                            <span className="text-gray-500 text-sm">Note {idx + 1} of {pendingEnhancements.length}</span>
                                        </div>
                                        <div className="mb-3">
                                            <p className="text-xs text-gray-500 mb-1">Original note:</p>
                                            <p className="text-sm text-gray-300 bg-gray-700 p-2 rounded">{item.originalText}</p>
                                        </div>
                                        <div className="mb-3">
                                            <p className="text-xs text-gray-500 mb-1">Transcript context:</p>
                                            <p className="text-xs text-gray-400 bg-gray-700 p-2 rounded italic">{item.context}</p>
                                        </div>
                                        <div className="space-y-2">
                                            <p className="text-xs text-gray-500 mb-1">Select interpretation:</p>
                                            {/* Primary suggestion */}
                                            <label className="flex items-start gap-2 cursor-pointer p-2 rounded hover:bg-gray-700/50">
                                                <input
                                                    type="radio"
                                                    name={`note-${item.noteId}`}
                                                    checked={currentSelection?.selectedOption === 0}
                                                    onChange={() => handleOptionChange(item.noteId, 0, item.suggestedSummary)}
                                                    className="mt-1 accent-emerald-500"
                                                />
                                                <span className="text-sm text-gray-300 whitespace-pre-wrap">{item.suggestedSummary}</span>
                                            </label>
                                            {/* Alternative suggestions */}
                                            {item.alternatives && item.alternatives.map((alt, altIdx) => (
                                                <label key={altIdx} className="flex items-start gap-2 cursor-pointer p-2 rounded hover:bg-gray-700/50">
                                                    <input
                                                        type="radio"
                                                        name={`note-${item.noteId}`}
                                                        checked={currentSelection?.selectedOption === altIdx + 1}
                                                        onChange={() => handleOptionChange(item.noteId, altIdx + 1, alt)}
                                                        className="mt-1 accent-emerald-500"
                                                    />
                                                    <span className="text-sm text-gray-300 whitespace-pre-wrap">{alt}</span>
                                                </label>
                                            ))}
                                            {/* Keep original option */}
                                            <label className="flex items-start gap-2 cursor-pointer p-2 rounded hover:bg-gray-700/50">
                                                <input
                                                    type="radio"
                                                    name={`note-${item.noteId}`}
                                                    checked={currentSelection?.selectedOption === -2}
                                                    onChange={() => handleOptionChange(item.noteId, -2, item.originalText)}
                                                    className="mt-1 accent-emerald-500"
                                                />
                                                <span className="text-sm text-gray-400 italic">Keep original</span>
                                            </label>
                                            {/* Custom option */}
                                            <label className="flex items-start gap-2 cursor-pointer p-2 rounded hover:bg-gray-700/50">
                                                <input
                                                    type="radio"
                                                    name={`note-${item.noteId}`}
                                                    checked={currentSelection?.selectedOption === -1}
                                                    onChange={() => handleSelectCustom(item.noteId)}
                                                    className="mt-1 accent-emerald-500"
                                                />
                                                <span className="text-sm text-gray-400">Custom:</span>
                                            </label>
                                            {currentSelection?.selectedOption === -1 && (
                                                <textarea
                                                    value={customTexts[item.noteId] || ''}
                                                    onChange={(e) => handleCustomTextChange(item.noteId, e.target.value)}
                                                    placeholder="Enter your custom text..."
                                                    className="w-full bg-gray-700 rounded p-2 text-sm text-gray-100 resize-none ml-6"
                                                    rows={3}
                                                />
                                            )}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                        <div className="flex gap-3 mt-6">
                            <button
                                onClick={handleSkipAll}
                                className="flex-1 bg-gray-600 hover:bg-gray-500 text-white font-medium py-2 rounded-lg transition-colors"
                            >
                                Skip All
                            </button>
                            <button
                                onClick={handleApply}
                                className="flex-1 bg-emerald-500 hover:bg-emerald-600 text-white font-medium py-2 rounded-lg transition-colors"
                            >
                                Update Notes
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Authentication Modal Component
        const AuthModal = ({ isOpen, onLogin, serverUrl, embedded = false }) => {
            const [mode, setMode] = useState('login'); // 'login' or 'register'
            const [username, setUsername] = useState('');
            const [password, setPassword] = useState('');
            const [confirmPassword, setConfirmPassword] = useState('');
            const [error, setError] = useState('');
            const [isLoading, setIsLoading] = useState(false);

            if (!isOpen) return null;

            const validateForm = () => {
                setError('');

                if (!username.trim()) {
                    setError('Username is required');
                    return false;
                }

                if (!/^[a-zA-Z0-9_]{3,30}$/.test(username)) {
                    setError('Username must be 3-30 alphanumeric characters or underscores');
                    return false;
                }

                if (!password) {
                    setError('Password is required');
                    return false;
                }

                if (password.length < 6) {
                    setError('Password must be at least 6 characters');
                    return false;
                }

                if (mode === 'register' && password !== confirmPassword) {
                    setError('Passwords do not match');
                    return false;
                }

                return true;
            };

            const handleSubmit = async (e) => {
                e.preventDefault();

                if (!validateForm()) return;

                setIsLoading(true);
                setError('');

                try {
                    const endpoint = mode === 'login' ? '/auth/login' : '/auth/register';
                    const response = await fetch(`${serverUrl}${endpoint}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username: username.trim(), password })
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        setError(data.error || 'Authentication failed');
                        setIsLoading(false);
                        return;
                    }

                    // Success - call onLogin with the auth data
                    onLogin({
                        token: data.token,
                        userId: data.userId,
                        username: data.username,
                        expiresAt: data.expiresAt
                    });
                } catch (err) {
                    console.error('Auth error:', err);
                    setError('Connection failed. Please check if the server is running.');
                    setIsLoading(false);
                }
            };

            const switchMode = () => {
                setMode(mode === 'login' ? 'register' : 'login');
                setError('');
                setPassword('');
                setConfirmPassword('');
            };

            const formContent = (
                <>
                    {!embedded && (
                        <div className="text-center mb-6">
                            <div className="inline-flex items-center justify-center w-16 h-16 bg-emerald-500/20 rounded-full mb-4">
                                <svg className="w-8 h-8 text-emerald-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                                </svg>
                            </div>
                            <h2 className="text-2xl font-bold mb-1">
                                {mode === 'login' ? 'Welcome Back' : 'Create Account'}
                            </h2>
                            <p className="text-gray-400 text-sm">
                                {mode === 'login'
                                    ? 'Sign in to access your bookmarks'
                                    : 'Register to start saving bookmarks'}
                            </p>
                        </div>
                    )}

                    <form onSubmit={handleSubmit}>
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-sm font-medium text-gray-300 mb-1">Username</label>
                                    <input
                                        type="text"
                                        value={username}
                                        onChange={(e) => setUsername(e.target.value)}
                                        placeholder="Enter username"
                                        className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2.5 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-transparent"
                                        autoComplete="username"
                                        autoFocus
                                    />
                                </div>

                                <div>
                                    <label className="block text-sm font-medium text-gray-300 mb-1">Password</label>
                                    <input
                                        type="password"
                                        value={password}
                                        onChange={(e) => setPassword(e.target.value)}
                                        placeholder="Enter password"
                                        className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2.5 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-transparent"
                                        autoComplete={mode === 'login' ? 'current-password' : 'new-password'}
                                    />
                                </div>

                                {mode === 'register' && (
                                    <div>
                                        <label className="block text-sm font-medium text-gray-300 mb-1">Confirm Password</label>
                                        <input
                                            type="password"
                                            value={confirmPassword}
                                            onChange={(e) => setConfirmPassword(e.target.value)}
                                            placeholder="Confirm password"
                                            className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2.5 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-transparent"
                                            autoComplete="new-password"
                                        />
                                    </div>
                                )}
                            </div>

                            {error && (
                                <div className="mt-4 p-3 bg-emerald-500/20 border border-emerald-500/50 rounded-lg">
                                    <p className="text-emerald-400 text-sm">{error}</p>
                                </div>
                            )}

                            <button
                                type="submit"
                                disabled={isLoading}
                                className="w-full mt-6 bg-emerald-500 hover:bg-emerald-600 disabled:bg-emerald-500/50 text-white font-medium py-2.5 rounded-lg transition-colors flex items-center justify-center gap-2"
                            >
                                {isLoading ? (
                                    <>
                                        <svg className="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                        </svg>
                                        {mode === 'login' ? 'Signing in...' : 'Creating account...'}
                                    </>
                                ) : (
                                    mode === 'login' ? 'Sign In' : 'Create Account'
                                )}
                            </button>
                        </form>

                    <div className="mt-4 text-center">
                        <p className="text-gray-400 text-sm">
                            {mode === 'login' ? "Don't have an account?" : 'Already have an account?'}
                            <button
                                type="button"
                                onClick={switchMode}
                                className="ml-2 text-emerald-400 hover:text-emerald-300 font-medium"
                            >
                                {mode === 'login' ? 'Register' : 'Sign In'}
                            </button>
                        </p>
                    </div>
                </>
            );

            // Return embedded version (no modal wrapper)
            if (embedded) {
                return formContent;
            }

            // Return modal version
            return (
                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50">
                    <div className="bg-gray-800 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl">
                        {formContent}
                    </div>
                </div>
            );
        };

        // Admin Dashboard Component
        const AdminDashboard = ({ serverUrl, authToken, onLogout, username }) => {
            const [stats, setStats] = useState(null);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [actionLoading, setActionLoading] = useState(null); // userId being acted on
            const [deleteConfirm, setDeleteConfirm] = useState(null); // userId to confirm delete

            useEffect(() => {
                const fetchStats = async () => {
                    try {
                        if (!authToken) {
                            setError('Not authenticated. Please log in again.');
                            setLoading(false);
                            return;
                        }

                        const response = await fetch(`${serverUrl}/admin/stats`, {
                            headers: { 'Authorization': `Bearer ${authToken}` }
                        });

                        // Try to parse JSON response
                        let data;
                        const contentType = response.headers.get('content-type');
                        if (contentType && contentType.includes('application/json')) {
                            data = await response.json();
                        } else {
                            // Not JSON - likely an error page
                            const text = await response.text();
                            console.error('Non-JSON response:', text.substring(0, 200));
                            throw new Error('Server returned non-JSON response');
                        }

                        if (response.status === 403) {
                            setError(data.error || 'Access denied. Admin privileges required.');
                            setLoading(false);
                            return;
                        }

                        if (response.status === 401) {
                            setError('Session expired. Please log in again.');
                            setLoading(false);
                            return;
                        }

                        if (!response.ok) {
                            throw new Error(data.error || 'Failed to fetch stats');
                        }

                        setStats(data);
                        setLoading(false);
                    } catch (e) {
                        console.error('Admin stats fetch error:', e);
                        setError(e.message);
                        setLoading(false);
                    }
                };

                fetchStats();
            }, [serverUrl, authToken]);

            const formatDuration = (seconds) => {
                if (!seconds || seconds < 60) return `${Math.round(seconds || 0)}s`;
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                if (hours > 0) return `${hours}h ${minutes}m`;
                return `${minutes}m`;
            };

            const formatDate = (timestamp) => {
                if (!timestamp) return 'N/A';
                return new Date(timestamp).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
            };

            const handleSuspendUser = async (userId, currentlySuspended) => {
                setActionLoading(userId);
                try {
                    const response = await fetch(`${serverUrl}/admin/users/${userId}/suspend`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${authToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ suspend: !currentlySuspended })
                    });

                    if (!response.ok) {
                        const data = await response.json();
                        throw new Error(data.error || 'Failed to update user');
                    }

                    // Update local state
                    setStats(prev => ({
                        ...prev,
                        users: prev.users.map(u =>
                            u.userId === userId ? { ...u, suspended: !currentlySuspended } : u
                        )
                    }));
                } catch (e) {
                    console.error('Suspend error:', e);
                    alert('Failed to update user: ' + e.message);
                } finally {
                    setActionLoading(null);
                }
            };

            const handleDeleteUser = async (userId) => {
                setActionLoading(userId);
                setDeleteConfirm(null);
                try {
                    const response = await fetch(`${serverUrl}/admin/users/${userId}`, {
                        method: 'DELETE',
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });

                    if (!response.ok) {
                        const data = await response.json();
                        throw new Error(data.error || 'Failed to delete user');
                    }

                    // Update local state
                    setStats(prev => ({
                        ...prev,
                        totalUsers: prev.totalUsers - 1,
                        users: prev.users.filter(u => u.userId !== userId)
                    }));
                } catch (e) {
                    console.error('Delete error:', e);
                    alert('Failed to delete user: ' + e.message);
                } finally {
                    setActionLoading(null);
                }
            };

            if (loading) {
                return (
                    <div className="h-screen flex items-center justify-center bg-gray-900">
                        <div className="text-center">
                            <svg className="animate-spin h-12 w-12 text-emerald-500 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <p className="text-gray-400">Loading admin stats...</p>
                        </div>
                    </div>
                );
            }

            if (error) {
                return (
                    <div className="h-screen flex items-center justify-center bg-gray-900">
                        <div className="text-center max-w-md mx-auto px-4">
                            <div className="w-16 h-16 bg-emerald-500/20 rounded-full flex items-center justify-center mx-auto mb-4">
                                <svg className="w-8 h-8 text-emerald-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                                </svg>
                            </div>
                            <h2 className="text-xl font-semibold text-gray-100 mb-2">Access Denied</h2>
                            <p className="text-gray-400 mb-6">{error}</p>
                            <div className="flex gap-3 justify-center">
                                <a
                                    href="/"
                                    className="px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg text-gray-100 transition-colors"
                                >
                                    Go Home
                                </a>
                                <button
                                    onClick={onLogout}
                                    className="px-4 py-2 bg-emerald-500 hover:bg-emerald-600 rounded-lg text-white transition-colors"
                                >
                                    Logout
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="min-h-screen bg-gray-900 text-gray-100">
                    {/* Header */}
                    <header className="bg-gray-800 border-b border-gray-700 px-6 py-4">
                        <div className="max-w-7xl mx-auto flex items-center justify-between">
                            <div className="flex items-center gap-4">
                                <h1 className="text-2xl font-bold text-emerald-500">Admin Dashboard</h1>
                                <span className="px-2 py-1 bg-emerald-500/20 text-emerald-400 text-xs font-medium rounded">
                                    {username}
                                </span>
                            </div>
                            <div className="flex items-center gap-3">
                                <a
                                    href="/"
                                    className="px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg text-sm transition-colors"
                                >
                                    Back to App
                                </a>
                                <button
                                    onClick={onLogout}
                                    className="px-3 py-2 bg-emerald-500/20 hover:bg-emerald-500/30 text-emerald-400 rounded-lg text-sm transition-colors"
                                >
                                    Logout
                                </button>
                            </div>
                        </div>
                    </header>

                    <main className="max-w-7xl mx-auto px-6 py-8">
                        {/* Stats Cards */}
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                            <div className="bg-gray-800 rounded-xl p-6 border border-gray-700">
                                <div className="flex items-center gap-3 mb-2">
                                    <div className="w-10 h-10 bg-blue-500/20 rounded-lg flex items-center justify-center">
                                        <svg className="w-5 h-5 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                                        </svg>
                                    </div>
                                    <span className="text-gray-400 text-sm">Total Users</span>
                                </div>
                                <p className="text-3xl font-bold text-gray-100">{stats.totalUsers}</p>
                            </div>

                            <div className="bg-gray-800 rounded-xl p-6 border border-gray-700">
                                <div className="flex items-center gap-3 mb-2">
                                    <div className="w-10 h-10 bg-green-500/20 rounded-lg flex items-center justify-center">
                                        <svg className="w-5 h-5 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                                        </svg>
                                    </div>
                                    <span className="text-gray-400 text-sm">Total Videos</span>
                                </div>
                                <p className="text-3xl font-bold text-gray-100">{stats.totalVideos}</p>
                            </div>

                            <div className="bg-gray-800 rounded-xl p-6 border border-gray-700">
                                <div className="flex items-center gap-3 mb-2">
                                    <div className="w-10 h-10 bg-yellow-500/20 rounded-lg flex items-center justify-center">
                                        <svg className="w-5 h-5 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                                        </svg>
                                    </div>
                                    <span className="text-gray-400 text-sm">Total Notes</span>
                                </div>
                                <p className="text-3xl font-bold text-gray-100">{stats.totalNotes}</p>
                            </div>

                            <div className="bg-gray-800 rounded-xl p-6 border border-gray-700">
                                <div className="flex items-center gap-3 mb-2">
                                    <div className="w-10 h-10 bg-purple-500/20 rounded-lg flex items-center justify-center">
                                        <svg className="w-5 h-5 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                                        </svg>
                                    </div>
                                    <span className="text-gray-400 text-sm">Total Watch Time</span>
                                </div>
                                <p className="text-3xl font-bold text-gray-100">{formatDuration(stats.totalWatchTime)}</p>
                            </div>
                        </div>

                        {/* Users Table */}
                        <div className="bg-gray-800 rounded-xl border border-gray-700 overflow-hidden">
                            <div className="px-6 py-4 border-b border-gray-700">
                                <h2 className="text-lg font-semibold text-gray-100">Users</h2>
                            </div>
                            <div className="overflow-x-auto">
                                <table className="w-full">
                                    <thead className="bg-gray-700/50">
                                        <tr>
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Username</th>
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Status</th>
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Joined</th>
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Videos</th>
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Notes</th>
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Watch Time</th>
                                            <th className="px-6 py-3 text-right text-xs font-medium text-gray-400 uppercase tracking-wider">Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody className="divide-y divide-gray-700">
                                        {stats.users.map((user) => {
                                            const isAdmin = user.username.toLowerCase() === 'absolute0net';
                                            const isCurrentUser = user.username.toLowerCase() === username?.toLowerCase();
                                            return (
                                            <tr key={user.userId} className={`hover:bg-gray-700/30 transition-colors ${user.suspended ? 'opacity-60' : ''}`}>
                                                <td className="px-6 py-4 whitespace-nowrap">
                                                    <div className="flex items-center gap-3">
                                                        <div className={`w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium ${user.suspended ? 'bg-gray-700 text-gray-500' : 'bg-gray-600 text-gray-300'}`}>
                                                            {user.username.charAt(0).toUpperCase()}
                                                        </div>
                                                        <span className={`font-medium ${user.suspended ? 'text-gray-500 line-through' : 'text-gray-100'}`}>{user.username}</span>
                                                        {isAdmin && (
                                                            <span className="px-1.5 py-0.5 bg-emerald-500/20 text-emerald-400 text-xs rounded">Admin</span>
                                                        )}
                                                    </div>
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap">
                                                    {user.suspended ? (
                                                        <span className="px-2 py-1 bg-emerald-500/20 text-emerald-400 text-xs rounded">Suspended</span>
                                                    ) : (
                                                        <span className="px-2 py-1 bg-green-500/20 text-green-400 text-xs rounded">Active</span>
                                                    )}
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap text-gray-400 text-sm">
                                                    {formatDate(user.createdAt)}
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap">
                                                    <span className="px-2 py-1 bg-green-500/20 text-green-400 text-sm rounded">
                                                        {user.videoCount}
                                                    </span>
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap">
                                                    <span className="px-2 py-1 bg-yellow-500/20 text-yellow-400 text-sm rounded">
                                                        {user.noteCount}
                                                    </span>
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap text-gray-400 text-sm">
                                                    {formatDuration(user.watchTime)}
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap text-right">
                                                    {!isAdmin && !isCurrentUser && (
                                                        <div className="flex items-center justify-end gap-2">
                                                            <button
                                                                onClick={() => handleSuspendUser(user.userId, user.suspended)}
                                                                disabled={actionLoading === user.userId}
                                                                className={`px-3 py-1 text-xs rounded transition-colors disabled:opacity-50 ${
                                                                    user.suspended
                                                                        ? 'bg-green-500/20 text-green-400 hover:bg-green-500/30'
                                                                        : 'bg-yellow-500/20 text-yellow-400 hover:bg-yellow-500/30'
                                                                }`}
                                                                title={user.suspended ? 'Unsuspend user' : 'Suspend user'}
                                                            >
                                                                {actionLoading === user.userId ? '...' : (user.suspended ? 'Unsuspend' : 'Suspend')}
                                                            </button>
                                                            {deleteConfirm === user.userId ? (
                                                                <div className="flex items-center gap-1">
                                                                    <button
                                                                        onClick={() => handleDeleteUser(user.userId)}
                                                                        disabled={actionLoading === user.userId}
                                                                        className="px-2 py-1 text-xs bg-emerald-500 text-white rounded hover:bg-emerald-600 transition-colors disabled:opacity-50"
                                                                    >
                                                                        Confirm
                                                                    </button>
                                                                    <button
                                                                        onClick={() => setDeleteConfirm(null)}
                                                                        className="px-2 py-1 text-xs bg-gray-600 text-gray-300 rounded hover:bg-gray-500 transition-colors"
                                                                    >
                                                                        Cancel
                                                                    </button>
                                                                </div>
                                                            ) : (
                                                                <button
                                                                    onClick={() => setDeleteConfirm(user.userId)}
                                                                    disabled={actionLoading === user.userId}
                                                                    className="px-3 py-1 text-xs bg-emerald-500/20 text-emerald-400 rounded hover:bg-emerald-500/30 transition-colors disabled:opacity-50"
                                                                    title="Delete user"
                                                                >
                                                                    Delete
                                                                </button>
                                                            )}
                                                        </div>
                                                    )}
                                                    {(isAdmin || isCurrentUser) && (
                                                        <span className="text-gray-600 text-xs">-</span>
                                                    )}
                                                </td>
                                            </tr>
                                            );
                                        })}
                                        {stats.users.length === 0 && (
                                            <tr>
                                                <td colSpan={7} className="px-6 py-8 text-center text-gray-500">
                                                    No users yet
                                                </td>
                                            </tr>
                                        )}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </main>
                </div>
            );
        };

        // Main App Component
        const App = () => {
            const [videos, setVideos] = useState([]);
            const [categories, setCategories] = useState([]);
            const [activeVideoId, setActiveVideoId] = useState(null);
            const [currentTime, setCurrentTime] = useState(0);
            const [searchQuery, setSearchQuery] = useState('');
            const [selectedCategory, setSelectedCategory] = useState('all');
            const [sortBy, setSortBy] = useState('date-desc');
            const [showAddModal, setShowAddModal] = useState(false);
            const [showCategoryModal, setShowCategoryModal] = useState(false);
            const [showSettingsModal, setShowSettingsModal] = useState(false);
            const [showProfileModal, setShowProfileModal] = useState(false);
            const [showShareModal, setShowShareModal] = useState(false);
            const [shareVideo, setShareVideo] = useState(null);
            const [sharedWithMe, setSharedWithMe] = useState([]);
            const [showSharedWithMe, setShowSharedWithMe] = useState(false);
            const [pendingShareToken, setPendingShareToken] = useState(null);
            const [sharePreview, setSharePreview] = useState(null);
            const [sharePreviewError, setSharePreviewError] = useState(null);
            const [isClaimingShare, setIsClaimingShare] = useState(false);
            const [showLibrary, setShowLibrary] = useState(true);
            const [newNote, setNewNote] = useState('');
            const [noteSearch, setNoteSearch] = useState('');
            const [geminiApiKey, setGeminiApiKey] = useState(''); // Deprecated - kept for backward compatibility
            const [youtubeApiKey, setYoutubeApiKey] = useState(''); // Deprecated - kept for backward compatibility
            const [apiStatus, setApiStatus] = useState({ geminiConfigured: false, youtubeConfigured: false });
            const [contextWordCount, setContextWordCount] = useState(10);
            const [cachedTranscript, setCachedTranscript] = useState(null);
            const [isLoadingContext, setIsLoadingContext] = useState(false);
            const [fetchingDateFor, setFetchingDateFor] = useState(null);
            const [editingVideo, setEditingVideo] = useState(null);
            const [showEditModal, setShowEditModal] = useState(false);
            const [isRefreshing, setIsRefreshing] = useState(false);
            const playerRef = useRef(null);
            const fileInputRef = useRef(null);

            // Save status and storage state
            const [saveStatus, setSaveStatus] = useState('saved'); // 'saving' | 'saved' | 'error'
            const [lastSaveTime, setLastSaveTime] = useState(null);
            const [storageAvailable, setStorageAvailable] = useState(true);

            // Enhancement state for AI note processing
            const [isEnhancing, setIsEnhancing] = useState(false);
            const [enhancementProgress, setEnhancementProgress] = useState({ current: 0, total: 0 });
            const [pendingEnhancements, setPendingEnhancements] = useState([]); // Notes needing user selection
            const [showEnhancementReview, setShowEnhancementReview] = useState(false);

            // Authentication state
            const [isAuthenticated, setIsAuthenticated] = useState(false);
            const [currentUser, setCurrentUser] = useState(null);
            const [authToken, setAuthToken] = useState(null);
            const [showAuthModal, setShowAuthModal] = useState(false);
            const [authLoading, setAuthLoading] = useState(true); // Loading auth check on startup
            const [isAdmin, setIsAdmin] = useState(false);

            // Admin route detection
            const isAdminRoute = window.location.pathname === '/admin' || window.location.hash === '#/admin';

            // Server URL for syncing bookmarks
            const SERVER_HOST = window.location.protocol === 'file:'
                ? 'localhost'
                : window.location.hostname;
            // Use same origin when served via nginx (port 80), otherwise use port 3456
            const SERVER_URL = (window.location.port === '' || window.location.port === '80')
                ? window.location.origin
                : `http://${SERVER_HOST}:3456`;

            // Handle successful login
            const handleLogin = async (authData) => {
                const { token, userId, username, expiresAt } = authData;

                // Save token to localStorage
                try {
                    localStorage.setItem('ytBookmarks_authToken', token);
                    localStorage.setItem('ytBookmarks_authExpires', expiresAt.toString());
                    console.log('✅ Saved auth token to localStorage');
                } catch (e) {
                    console.warn('Could not save auth token to localStorage:', e.message);
                }

                // Check if user is admin
                try {
                    const checkResponse = await fetch(`${SERVER_URL}/auth/check`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (checkResponse.ok) {
                        const checkData = await checkResponse.json();
                        setIsAdmin(checkData.isAdmin || false);
                    }
                } catch (e) {
                    console.log('Could not check admin status:', e.message);
                }

                // Update auth state
                setAuthToken(token);
                setCurrentUser({ userId, username });
                setIsAuthenticated(true);
                setShowAuthModal(false);
                setAuthLoading(false);

                // Load user's data from server
                await loadUserData(token);

                // Check if there's a pending share token to claim
                if (pendingShareToken) {
                    console.log('🎁 Claiming pending share...');
                    setIsClaimingShare(true);
                    try {
                        const claimResponse = await fetch(`${SERVER_URL}/api/shares/claim?token=${encodeURIComponent(pendingShareToken)}`, {
                            method: 'POST',
                            headers: { 'Authorization': `Bearer ${token}` }
                        });

                        if (claimResponse.ok) {
                            console.log('✅ Share claimed successfully!');
                            // Reload shared videos
                            const sharedResponse = await fetch(`${SERVER_URL}/api/shares/library`, {
                                headers: { 'Authorization': `Bearer ${token}` }
                            });
                            if (sharedResponse.ok) {
                                const sharedData = await sharedResponse.json();
                                setSharedWithMe(sharedData);
                            }
                            // Clear the URL param
                            window.history.replaceState({}, document.title, window.location.pathname);
                        } else {
                            const errorData = await claimResponse.json();
                            console.warn('Failed to claim share:', errorData.error);
                        }
                    } catch (e) {
                        console.error('Error claiming share:', e.message);
                    } finally {
                        setPendingShareToken(null);
                        setSharePreview(null);
                        setIsClaimingShare(false);
                    }
                }
            };

            // Handle logout
            const handleLogout = async () => {
                // Call logout endpoint
                try {
                    await fetch(`${SERVER_URL}/auth/logout`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        }
                    });
                } catch (e) {
                    console.log('Logout request failed:', e.message);
                }

                // Clear local auth state
                try {
                    localStorage.removeItem('ytBookmarks_authToken');
                    localStorage.removeItem('ytBookmarks_authExpires');
                } catch (e) {
                    console.warn('Could not clear auth token from localStorage:', e.message);
                }

                setAuthToken(null);
                setCurrentUser(null);
                setIsAuthenticated(false);
                setVideos([]);
                setCategories([]);
                setShowAuthModal(true);

                console.log('🚪 Logged out');
            };

            // Load user data after authentication
            const loadUserData = async (token) => {
                try {
                    // Load categories from server
                    const catResponse = await fetch(`${SERVER_URL}/categories`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (catResponse.ok) {
                        const serverCategories = await catResponse.json();
                        if (Array.isArray(serverCategories)) {
                            setCategories(serverCategories);
                            console.log('✅ Loaded categories from server:', serverCategories.length);
                        }
                    } else if (catResponse.status === 401) {
                        // Token is invalid, show auth modal
                        setShowAuthModal(true);
                        setAuthLoading(false);
                        return;
                    }

                    // Load bookmarks from server
                    const response = await fetch(`${SERVER_URL}/bookmarks`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (response.ok) {
                        const serverData = await response.json();
                        if (Array.isArray(serverData)) {
                            setVideos(serverData);
                            console.log('✅ Loaded bookmarks from server:', serverData.length);
                        }
                    } else if (response.status === 401) {
                        // Token is invalid, show auth modal
                        setShowAuthModal(true);
                        setAuthLoading(false);
                        return;
                    }

                    // Load shared-with-me videos
                    try {
                        const sharedResponse = await fetch(`${SERVER_URL}/api/shares/library`, {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });
                        if (sharedResponse.ok) {
                            const sharedData = await sharedResponse.json();
                            if (Array.isArray(sharedData)) {
                                setSharedWithMe(sharedData);
                                console.log('✅ Loaded shared videos:', sharedData.length);
                            }
                        }
                    } catch (e) {
                        console.log('Could not load shared videos:', e.message);
                    }
                } catch (e) {
                    console.error('Error loading user data:', e.message);
                }
            };

            // Reload shared-with-me videos
            const reloadSharedVideos = async () => {
                if (!authToken) return;
                try {
                    const response = await fetch(`${SERVER_URL}/api/shares/library`, {
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });
                    if (response.ok) {
                        const sharedData = await response.json();
                        if (Array.isArray(sharedData)) {
                            setSharedWithMe(sharedData);
                        }
                    }
                } catch (e) {
                    console.log('Could not reload shared videos:', e.message);
                }
            };

            // Load data from server (with localStorage fallback)
            useEffect(() => {
                const loadData = async () => {
                    // Check for share token in URL
                    const urlParams = new URLSearchParams(window.location.search);
                    const shareToken = urlParams.get('share_token');
                    if (shareToken) {
                        console.log('🔗 Found share token in URL:', shareToken);
                        setPendingShareToken(shareToken);

                        // Fetch share preview
                        try {
                            const previewResponse = await fetch(`${SERVER_URL}/api/shares/preview?token=${encodeURIComponent(shareToken)}`);
                            if (previewResponse.ok) {
                                const preview = await previewResponse.json();
                                setSharePreview(preview);
                                console.log('✅ Loaded share preview:', preview.videoTitle);
                            } else {
                                const errorData = await previewResponse.json();
                                setSharePreviewError(errorData.error || 'Failed to load share');
                            }
                        } catch (e) {
                            setSharePreviewError('Could not connect to server');
                        }
                    }

                    // Check storage availability (for private browsing detection)
                    const storageOk = isStorageAvailable('localStorage');
                    setStorageAvailable(storageOk);
                    if (!storageOk) {
                        console.warn('⚠️ localStorage unavailable - private browsing mode detected');
                    }

                    // Fetch server API status (Gemini/YouTube configured)
                    try {
                        const statusResponse = await fetch(`${SERVER_URL}/api/status`);
                        if (statusResponse.ok) {
                            const status = await statusResponse.json();
                            setApiStatus(status);
                            console.log(`✅ API Status: Gemini=${status.geminiConfigured}, YouTube=${status.youtubeConfigured}`);
                        }
                    } catch (e) {
                        console.warn('Could not fetch API status:', e.message);
                    }

                    try {
                        const savedContextWords = localStorage.getItem('ytBookmarks_contextWordCount');
                        if (savedContextWords) {
                            setContextWordCount(parseInt(savedContextWords, 10));
                            console.log('✅ Loaded context word count from localStorage');
                        }
                    } catch (e) {
                        console.warn('Could not access localStorage:', e.message);
                    }

                    // Check for saved auth token
                    let savedToken = null;
                    try {
                        savedToken = localStorage.getItem('ytBookmarks_authToken');
                        const savedExpires = localStorage.getItem('ytBookmarks_authExpires');

                        // Check if token is expired
                        if (savedToken && savedExpires) {
                            const expiresAt = parseInt(savedExpires, 10);
                            if (Date.now() > expiresAt) {
                                console.log('⚠️ Auth token expired, clearing...');
                                localStorage.removeItem('ytBookmarks_authToken');
                                localStorage.removeItem('ytBookmarks_authExpires');
                                savedToken = null;
                            }
                        }
                    } catch (e) {
                        console.warn('Could not read auth token from localStorage:', e.message);
                    }

                    // If we have a saved token, verify it with the server
                    if (savedToken) {
                        try {
                            const checkResponse = await fetch(`${SERVER_URL}/auth/check`, {
                                headers: { 'Authorization': `Bearer ${savedToken}` }
                            });

                            if (checkResponse.ok) {
                                const checkData = await checkResponse.json();
                                if (checkData.valid) {
                                    // Token is valid, set auth state and load user data
                                    setAuthToken(savedToken);
                                    setCurrentUser({ userId: checkData.userId, username: checkData.username });
                                    setIsAuthenticated(true);
                                    setIsAdmin(checkData.isAdmin || false);
                                    setAuthLoading(false);

                                    console.log(`✅ Authenticated as ${checkData.username}${checkData.isAdmin ? ' (Admin)' : ''}`);

                                    // Load user data
                                    await loadUserData(savedToken);
                                    return;
                                }
                            }

                            // Token is invalid, clear it
                            console.log('⚠️ Auth token invalid, clearing...');
                            localStorage.removeItem('ytBookmarks_authToken');
                            localStorage.removeItem('ytBookmarks_authExpires');
                        } catch (e) {
                            console.log('Could not verify auth token:', e.message);
                        }
                    }

                    // No valid token, show auth modal
                    setAuthLoading(false);
                    setShowAuthModal(true);
                    return; // Don't load any data without authentication

                    // LEGACY CODE BELOW - kept for reference but never reached
                    // Try to load categories from server first
                    let categoriesLoaded = false;
                    try {
                        const catResponse = await fetch(`${SERVER_URL}/categories`);
                        if (catResponse.ok) {
                            const serverCategories = await catResponse.json();
                            if (Array.isArray(serverCategories) && serverCategories.length > 0) {
                                setCategories(serverCategories);
                                console.log('✅ Loaded categories from server:', serverCategories.length);
                                categoriesLoaded = true;
                            }
                        }
                    } catch (e) {
                        console.log('Server categories not available:', e.message);
                    }

                    // Fall back to localStorage for categories
                    if (!categoriesLoaded) {
                        try {
                            const savedCategories = localStorage.getItem('ytBookmarks_categories');
                            console.log('Raw saved categories from localStorage:', savedCategories);
                            if (savedCategories) {
                                const parsedCategories = JSON.parse(savedCategories);

                                // Check if categories are in correct format: array of {id, name} objects
                                let validCategories = [];
                                if (Array.isArray(parsedCategories) && parsedCategories.length > 0) {
                                    // Check if items are objects with id and name, or just strings (corrupted)
                                    const firstItem = parsedCategories[0];
                                    if (typeof firstItem === 'string') {
                                        // Categories are corrupted - just IDs stored as strings
                                        console.warn('⚠️ Categories are corrupted (strings instead of objects). Clearing and will rebuild.');
                                        validCategories = [];
                                    } else if (typeof firstItem === 'object' && firstItem.id && firstItem.name) {
                                        // Valid category objects
                                        validCategories = parsedCategories;
                                        console.log('✅ Loaded categories from localStorage:', validCategories);
                                    } else {
                                        console.warn('⚠️ Categories have invalid structure:', firstItem);
                                        validCategories = [];
                                    }
                                }
                                setCategories(validCategories);
                            } else {
                                console.log('⚠️ No categories found in localStorage (ytBookmarks_categories is null/undefined)');
                                setCategories([]);
                            }
                        } catch (e) {
                            console.error('❌ Could not load categories from localStorage:', e.message, e);
                            setCategories([]);
                        }
                    }

                    // Try to load bookmarks from server
                    try {
                        const response = await fetch(`${SERVER_URL}/bookmarks`);
                        if (response.ok) {
                            const serverData = await response.json();
                            if (Array.isArray(serverData) && serverData.length > 0) {
                                setVideos(serverData);
                                console.log('✅ Loaded bookmarks from server:', serverData.length);
                                return;
                            }
                        }
                    } catch (e) {
                        console.log('Server not available, using localStorage:', e.message);
                    }

                    // Fallback to localStorage for videos
                    try {
                        let savedVideos = localStorage.getItem('ytBookmarks_videos');

                        // If localStorage is empty, try to recover from sessionStorage backup
                        if (!savedVideos && isStorageAvailable('sessionStorage')) {
                            try {
                                const backup = sessionStorage.getItem('ytBookmarks_backup');
                                if (backup) {
                                    const parsed = JSON.parse(backup);
                                    if (parsed.videos && parsed.categories) {
                                        setVideos(parsed.videos);
                                        setCategories(parsed.categories);
                                        console.log('✅ Recovered from sessionStorage backup');
                                        return;
                                    }
                                }
                            } catch (e) {
                                console.warn('Could not recover from sessionStorage backup:', e.message);
                            }
                        }

                        if (savedVideos) {
                            const parsedVideos = JSON.parse(savedVideos);
                            setVideos(parsedVideos);
                            console.log('✅ Loaded videos from localStorage:', parsedVideos.length);
                        } else {
                            console.log('⚠️ No videos found in localStorage');
                        }
                    } catch (e) {
                        console.error('❌ Could not load videos from localStorage:', e.message, e);
                    }

                    // Debug info
                    console.log('📊 Current state after load:', {
                        categoriesCount: categories.length,
                        videosCount: videos.length
                    });
                    console.log('💾 All localStorage keys:', Object.keys(localStorage).filter(k => k.startsWith('ytBookmarks_')));
                };
                loadData();
            }, []);

            // Immediate save to localStorage and sessionStorage (no debounce)
            const saveImmediately = useCallback((videosToSave, categoriesToSave) => {
                // Save to localStorage immediately
                try {
                    saveToStorage('ytBookmarks_videos', videosToSave, localStorage);
                    setSaveStatus('saved');
                    setLastSaveTime(new Date());
                } catch (e) {
                    console.error('Failed to save videos to localStorage:', e.message);
                    setSaveStatus('error');
                }

                // Save categories to localStorage immediately
                try {
                    saveToStorage('ytBookmarks_categories', categoriesToSave, localStorage);
                } catch (e) {
                    console.error('Failed to save categories to localStorage:', e.message);
                }

                // Mirror to sessionStorage as backup
                try {
                    if (isStorageAvailable('sessionStorage')) {
                        sessionStorage.setItem('ytBookmarks_backup', JSON.stringify({
                            videos: videosToSave,
                            categories: categoriesToSave,
                            timestamp: Date.now()
                        }));
                    }
                } catch (e) {
                    console.warn('SessionStorage backup failed:', e.message);
                }
            }, []);

            // Sync to server (async, with debounce) - requires authentication
            const syncToServer = async (videosToSave, categoriesToSave) => {
                // Don't sync if not authenticated
                if (!authToken) {
                    console.log('⚠️ Cannot sync to server: not authenticated');
                    return;
                }

                try {
                    const response = await fetch(`${SERVER_URL}/bookmarks`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify(videosToSave)
                    });
                    if (response.ok) {
                        console.log('✅ Synced bookmarks to server');
                    } else if (response.status === 401) {
                        console.log('⚠️ Auth token expired, showing login...');
                        setShowAuthModal(true);
                        setIsAuthenticated(false);
                    } else {
                        console.log('Server returned status:', response.status);
                        setSaveStatus('error');
                    }
                } catch (e) {
                    console.log('Could not sync bookmarks to server:', e.message);
                    setSaveStatus('error');
                }

                // Also sync categories
                try {
                    const catResponse = await fetch(`${SERVER_URL}/categories`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify(categoriesToSave)
                    });
                    if (catResponse.ok) {
                        console.log('✅ Synced categories to server');
                    }
                } catch (e) {
                    console.log('Could not sync categories to server:', e.message);
                }
            };

            // Track watch time - debounced to avoid excessive requests
            const watchTimeBufferRef = useRef({});
            const watchTimeSyncRef = useRef(null);

            const trackWatchTime = useCallback((videoId, seconds) => {
                if (!authToken || !videoId || seconds < 1) return;

                // Accumulate watch time in buffer
                watchTimeBufferRef.current[videoId] = (watchTimeBufferRef.current[videoId] || 0) + seconds;

                // Debounce the server sync (every 30 seconds or when video changes)
                if (watchTimeSyncRef.current) clearTimeout(watchTimeSyncRef.current);
                watchTimeSyncRef.current = setTimeout(() => {
                    const buffer = { ...watchTimeBufferRef.current };
                    watchTimeBufferRef.current = {};

                    // Send accumulated watch time to server
                    Object.entries(buffer).forEach(([vid, duration]) => {
                        if (duration > 0) {
                            fetch(`${SERVER_URL}/admin/watch-time`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${authToken}`
                                },
                                body: JSON.stringify({ videoId: vid, duration })
                            }).then(res => {
                                if (res.ok) {
                                    console.log(`⏱️ Tracked ${duration}s watch time for ${vid}`);
                                }
                            }).catch(e => {
                                console.log('Could not track watch time:', e.message);
                            });
                        }
                    });
                }, 30000); // Sync every 30 seconds
            }, [authToken, SERVER_URL]);

            // Flush watch time on unmount or visibility change
            useEffect(() => {
                const flushWatchTime = () => {
                    if (Object.keys(watchTimeBufferRef.current).length > 0 && authToken) {
                        const buffer = { ...watchTimeBufferRef.current };
                        watchTimeBufferRef.current = {};

                        Object.entries(buffer).forEach(([vid, duration]) => {
                            if (duration > 0) {
                                // Use fetch with keepalive for reliability on page hide
                                fetch(`${SERVER_URL}/admin/watch-time`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'Authorization': `Bearer ${authToken}`
                                    },
                                    body: JSON.stringify({ videoId: vid, duration }),
                                    keepalive: true
                                }).catch(() => {}); // Ignore errors on page close
                            }
                        });
                    }
                };

                const handleVisibility = () => {
                    if (document.hidden) flushWatchTime();
                };

                window.addEventListener('pagehide', flushWatchTime);
                document.addEventListener('visibilitychange', handleVisibility);

                return () => {
                    flushWatchTime();
                    window.removeEventListener('pagehide', flushWatchTime);
                    document.removeEventListener('visibilitychange', handleVisibility);
                };
            }, [authToken, SERVER_URL]);

            // Debounced server sync effect for videos
            const saveTimeoutRef = useRef(null);
            useEffect(() => {
                // Only sync when authenticated
                if (!isAuthenticated) return;

                // Save immediately to localStorage (backup)
                if (videos.length > 0) {
                    saveImmediately(videos, categories);
                }

                // Debounce server sync to avoid too many requests
                if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);
                saveTimeoutRef.current = setTimeout(() => {
                    if (videos.length > 0 || categories.length > 0) {
                        syncToServer(videos, categories);
                    }
                }, 500);

                return () => clearTimeout(saveTimeoutRef.current);
            }, [videos, categories, saveImmediately, isAuthenticated]);

            // Page lifecycle handlers to save on unload (iOS Safari support)
            useEffect(() => {
                const handleBeforeUnload = (e) => {
                    // Force immediate save before page unload
                    saveImmediately(videos, categories);
                };

                const handlePageHide = (e) => {
                    // iOS Safari - more reliable than beforeunload
                    saveImmediately(videos, categories);
                };

                const handleVisibilityChange = () => {
                    // Tab backgrounded on mobile
                    if (document.hidden) {
                        saveImmediately(videos, categories);
                    }
                };

                window.addEventListener('beforeunload', handleBeforeUnload);
                window.addEventListener('pagehide', handlePageHide);
                document.addEventListener('visibilitychange', handleVisibilityChange);

                return () => {
                    window.removeEventListener('beforeunload', handleBeforeUnload);
                    window.removeEventListener('pagehide', handlePageHide);
                    document.removeEventListener('visibilitychange', handleVisibilityChange);
                };
            }, [videos, categories, saveImmediately]);

            // Save API key handlers
            const handleSaveGeminiApiKey = (key) => {
                setGeminiApiKey(key);
                try {
                    localStorage.setItem('ytBookmarks_geminiApiKey', key);
                    console.log('✅ Saved Gemini API key to localStorage');
                } catch (e) {
                    console.error('Could not save Gemini API key:', e.message);
                }
            };

            const handleSaveYoutubeApiKey = (key) => {
                setYoutubeApiKey(key);
                try {
                    localStorage.setItem('ytBookmarks_youtubeApiKey', key);
                    console.log('✅ Saved YouTube API key to localStorage');
                } catch (e) {
                    console.error('Could not save YouTube API key:', e.message);
                }
            };

            const handleSaveContextWordCount = (count) => {
                setContextWordCount(count);
                try {
                    localStorage.setItem('ytBookmarks_contextWordCount', count.toString());
                    console.log('✅ Saved context word count to localStorage');
                } catch (e) {
                    console.error('Could not save context word count:', e.message);
                }
            };

            // Function to extract context words from transcript at a given timestamp
            const getTranscriptContext = (transcript, timestamp, wordsBefore = 10, wordsAfter = 10) => {
                if (!transcript || transcript.length === 0) return '';

                // Build full text with word positions mapped to timestamps
                const wordData = [];
                transcript.forEach(segment => {
                    const words = segment.text.split(/\s+/).filter(w => w.trim());
                    const segmentDuration = segment.duration || 2;
                    const timePerWord = segmentDuration / Math.max(words.length, 1);

                    words.forEach((word, idx) => {
                        wordData.push({
                            word: word,
                            timestamp: segment.start + (idx * timePerWord)
                        });
                    });
                });

                // Find the word closest to the current timestamp
                let closestIdx = 0;
                let closestDiff = Math.abs(wordData[0]?.timestamp - timestamp) || Infinity;

                for (let i = 1; i < wordData.length; i++) {
                    const diff = Math.abs(wordData[i].timestamp - timestamp);
                    if (diff < closestDiff) {
                        closestDiff = diff;
                        closestIdx = i;
                    }
                }

                // Extract words before and after
                const startIdx = Math.max(0, closestIdx - wordsBefore);
                const endIdx = Math.min(wordData.length, closestIdx + wordsAfter + 1);

                const contextWords = wordData.slice(startIdx, endIdx).map(w => w.word);
                return contextWords.join(' ');
            };

            // Function to extract extended context words from transcript (for AI enhancement)
            const getExtendedTranscriptContext = (transcript, timestamp, wordsBefore = 75, wordsAfter = 75) => {
                if (!transcript || transcript.length === 0) return '';

                // Build full text with word positions mapped to timestamps
                const wordData = [];
                transcript.forEach(segment => {
                    const words = segment.text.split(/\s+/).filter(w => w.trim());
                    const segmentDuration = segment.duration || 2;
                    const timePerWord = segmentDuration / Math.max(words.length, 1);

                    words.forEach((word, idx) => {
                        wordData.push({
                            word: word,
                            timestamp: segment.start + (idx * timePerWord)
                        });
                    });
                });

                if (wordData.length === 0) return '';

                // Find the word closest to the current timestamp
                let closestIdx = 0;
                let closestDiff = Math.abs(wordData[0]?.timestamp - timestamp) || Infinity;

                for (let i = 1; i < wordData.length; i++) {
                    const diff = Math.abs(wordData[i].timestamp - timestamp);
                    if (diff < closestDiff) {
                        closestDiff = diff;
                        closestIdx = i;
                    }
                }

                // Extract more words before and after for complete thought capture
                const startIdx = Math.max(0, closestIdx - wordsBefore);
                const endIdx = Math.min(wordData.length, closestIdx + wordsAfter + 1);

                const contextWords = wordData.slice(startIdx, endIdx).map(w => w.word);
                return contextWords.join(' ');
            };

            // Function to load transcript context into note field
            const handleLoadContext = async () => {
                if (!activeVideo) return;

                setIsLoadingContext(true);

                try {
                    // Use cached transcript or fetch new one
                    let transcript = cachedTranscript;
                    if (!transcript || cachedTranscript?.videoId !== activeVideo.videoId) {
                        transcript = await fetchTranscript(activeVideo.videoId);
                        if (transcript) {
                            setCachedTranscript({ videoId: activeVideo.videoId, data: transcript });
                            transcript = transcript;
                        }
                    } else {
                        transcript = cachedTranscript.data;
                    }

                    if (!transcript || transcript.length === 0) {
                        setNewNote('[No transcript available for this video]');
                        return;
                    }

                    const context = getTranscriptContext(transcript, currentTime, contextWordCount, contextWordCount);
                    if (context) {
                        setNewNote(context);
                    } else {
                        setNewNote('[Could not find transcript at this timestamp]');
                    }
                } catch (error) {
                    console.error('Error loading transcript context:', error);
                    // Provide helpful error message based on error type
                    if (error.message?.includes('rate limit') || error.message?.includes('empty responses')) {
                        setNewNote('[YouTube rate limited. Please try again in a few minutes.]');
                    } else if (error.message?.includes('No captions')) {
                        setNewNote('[This video does not have captions/subtitles available]');
                    } else {
                        setNewNote('[Error loading transcript. Make sure the transcript server is running.]');
                    }
                } finally {
                    setIsLoadingContext(false);
                }
            };

            const activeVideo = videos.find(v => v.id === activeVideoId);

            // Filter videos
            const filteredVideos = videos.filter(video => {
                const matchesSearch = searchQuery === '' ||
                    video.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
                    video.tags?.some(t => t.toLowerCase().includes(searchQuery.toLowerCase())) ||
                    video.notes?.some(n => n.text.toLowerCase().includes(searchQuery.toLowerCase()));
                const matchesCategory = selectedCategory === 'all' || video.category === selectedCategory;
                return matchesSearch && matchesCategory;
            });

            const sortedVideos = [...filteredVideos].sort((a, b) => {
                if (sortBy === 'date-desc') {
                    if (!a.publishDate && !b.publishDate) return 0;
                    if (!a.publishDate) return 1;
                    if (!b.publishDate) return -1;
                    return b.publishDate.localeCompare(a.publishDate);
                }
                if (sortBy === 'date-asc') {
                    if (!a.publishDate && !b.publishDate) return 0;
                    if (!a.publishDate) return 1;
                    if (!b.publishDate) return -1;
                    return a.publishDate.localeCompare(b.publishDate);
                }
                return 0; // default
            });

            // Video handlers
            const handleAddVideo = (video) => {
                setVideos(prev => [...prev, video]);
            };

            const handleDeleteVideo = (id) => {
                setVideos(prev => prev.filter(v => v.id !== id));
                if (activeVideoId === id) setActiveVideoId(null);
            };

            const handleEditVideo = (videoId) => {
                const video = videos.find(v => v.id === videoId);
                if (video) {
                    setEditingVideo(video);
                    setShowEditModal(true);
                }
            };

            const handleSaveEditedVideo = (updates) => {
                setVideos(prev => prev.map(v =>
                    v.id === editingVideo.id
                        ? { ...v, ...updates }
                        : v
                ));
                setShowEditModal(false);
                setEditingVideo(null);
            };

            const handleRefresh = async () => {
                if (!authToken) {
                    console.log('⚠️ Cannot refresh: not authenticated');
                    return;
                }

                setIsRefreshing(true);
                try {
                    // Try to load bookmarks from server
                    const response = await fetch(`${SERVER_URL}/bookmarks`, {
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });
                    if (response.ok) {
                        const serverData = await response.json();
                        if (Array.isArray(serverData)) {
                            setVideos(serverData);
                            console.log('✅ Refreshed bookmarks from server:', serverData.length);
                        }
                    } else if (response.status === 401) {
                        setShowAuthModal(true);
                        setIsAuthenticated(false);
                    }

                    // Also refresh categories
                    const catResponse = await fetch(`${SERVER_URL}/categories`, {
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });
                    if (catResponse.ok) {
                        const serverCategories = await catResponse.json();
                        if (Array.isArray(serverCategories)) {
                            setCategories(serverCategories);
                            console.log('✅ Refreshed categories from server:', serverCategories.length);
                        }
                    }
                } catch (e) {
                    console.log('Could not refresh from server:', e.message);
                }

                setIsRefreshing(false);
            };

            const handleFetchPublishDate = async (videoId, videoYoutubeId) => {
                if (!apiStatus.youtubeConfigured) {
                    alert('YouTube API is not configured on the server. Please contact the administrator.');
                    setFetchingDateFor(null);
                    return;
                }

                setFetchingDateFor(videoId);
                try {
                    const response = await fetch(
                        `${SERVER_URL}/api/youtube/video?id=${videoYoutubeId}`,
                        { headers: { 'Authorization': `Bearer ${authToken}` } }
                    );
                    const data = await response.json();
                    console.log('YouTube API response:', data);

                    if (data.error) {
                        console.error('YouTube API error:', data.error);
                        alert(`Error: ${data.error}`);
                        setFetchingDateFor(null);
                        return;
                    }

                    if (data.publishedAt) {
                        const publishDate = data.publishedAt.split('T')[0]; // Extract YYYY-MM-DD
                        setVideos(prev => prev.map(v =>
                            v.id === videoId ? { ...v, publishDate } : v
                        ));
                        console.log('✅ Publish date fetched:', publishDate);
                    } else {
                        console.error('No publish date found in YouTube API response');
                        alert('Could not fetch publish date for this video');
                    }
                } catch (err) {
                    console.error('Failed to fetch publish date:', err);
                    alert('Failed to fetch publish date: ' + err.message);
                } finally {
                    setFetchingDateFor(null);
                }
            };

            // Note handlers
            const handleAddNote = () => {
                if (!newNote.trim() || !activeVideoId) return;

                setVideos(prev => prev.map(video => {
                    if (video.id === activeVideoId) {
                        return {
                            ...video,
                            notes: [...(video.notes || []), {
                                id: generateId(),
                                text: newNote.trim(),
                                timestamp: currentTime,
                                createdAt: new Date().toISOString()
                            }].sort((a, b) => b.timestamp - a.timestamp)
                        };
                    }
                    return video;
                }));
                setNewNote('');
            };

            const handleDeleteNote = (noteId) => {
                setVideos(prev => prev.map(video => {
                    if (video.id === activeVideoId) {
                        return {
                            ...video,
                            notes: video.notes.filter(n => n.id !== noteId)
                        };
                    }
                    return video;
                }));
            };

            const handleEditNote = (noteId, newText) => {
                setVideos(prev => prev.map(video => {
                    if (video.id === activeVideoId) {
                        return {
                            ...video,
                            notes: video.notes.map(n =>
                                n.id === noteId ? { ...n, text: newText } : n
                            ).sort((a, b) => b.timestamp - a.timestamp)
                        };
                    }
                    return video;
                }));
            };

            const handleExportNotes = (video) => {
                if (!video || !video.notes || video.notes.length === 0) {
                    alert('No notes to export for this video');
                    return;
                }

                // Sort notes by timestamp (oldest to newest for export)
                const sortedNotes = [...video.notes].sort((a, b) => a.timestamp - b.timestamp);

                // Build export text
                let exportText = `${video.title}\n`;
                if (video.publishDate) {
                    exportText += `Published: ${formatPublishDate(video.publishDate)}\n`;
                }
                exportText += `\n---\n\n`;

                sortedNotes.forEach((note, index) => {
                    const timestamp = formatTime(note.timestamp);
                    exportText += `[${timestamp}] ${note.text}\n\n`;
                });

                // Download as text file
                const blob = new Blob([exportText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const filename = video.title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                a.download = `${filename}_notes.txt`;
                a.click();
                URL.revokeObjectURL(url);
            };

            // Export notes as Markdown file
            const handleExportMarkdown = (video) => {
                if (!video || !video.notes || video.notes.length === 0) {
                    alert('No notes to export for this video');
                    return;
                }

                // Sort notes by timestamp (oldest to newest for export)
                const sortedNotes = [...video.notes].sort((a, b) => a.timestamp - b.timestamp);

                // Build markdown content
                let markdown = `# ${video.title}\n\n`;
                if (video.publishDate) {
                    markdown += `**Published:** ${formatPublishDate(video.publishDate)}\n`;
                }
                markdown += `**Video:** https://youtube.com/watch?v=${video.videoId}\n\n`;
                markdown += `---\n\n`;
                markdown += `## Notes\n\n`;

                sortedNotes.forEach((note) => {
                    const timestamp = formatTime(note.timestamp);
                    markdown += `### [${timestamp}]\n`;
                    // Handle bullet points - if note already has bullets, use as-is, otherwise wrap
                    if (note.text.trim().startsWith('-')) {
                        markdown += `${note.text}\n\n`;
                    } else {
                        markdown += `- ${note.text}\n\n`;
                    }
                });

                markdown += `---\n\n`;
                markdown += `*Exported from YouTube Bookmarking App on ${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}*\n`;

                // Download as markdown file
                const blob = new Blob([markdown], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const filename = video.title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                a.download = `${filename}_notes.md`;
                a.click();
                URL.revokeObjectURL(url);
            };

            // Enhance all notes with AI summarization
            const handleEnhanceAllNotes = async () => {
                const activeVideo = videos.find(v => v.id === activeVideoId);
                if (!activeVideo || !activeVideo.notes || activeVideo.notes.length === 0) {
                    alert('No notes to enhance for this video');
                    return;
                }

                if (!apiStatus.geminiConfigured) {
                    alert('Gemini API is not configured on the server. Please contact the administrator.');
                    return;
                }

                setIsEnhancing(true);
                setEnhancementProgress({ current: 0, total: activeVideo.notes.length });

                try {
                    // Fetch transcript
                    let transcript = cachedTranscript?.data;
                    if (!transcript || cachedTranscript?.videoId !== activeVideo.videoId) {
                        transcript = await fetchTranscript(activeVideo.videoId);
                        if (transcript) {
                            setCachedTranscript({ videoId: activeVideo.videoId, data: transcript });
                        }
                    }

                    if (!transcript || transcript.length === 0) {
                        alert('Could not fetch transcript for this video. Enhancement requires transcript data.');
                        setIsEnhancing(false);
                        return;
                    }

                    const enhancedNotes = [];
                    const ambiguousNotes = [];

                    // Process each note
                    for (let i = 0; i < activeVideo.notes.length; i++) {
                        const note = activeVideo.notes[i];
                        setEnhancementProgress({ current: i + 1, total: activeVideo.notes.length });

                        try {
                            // Get extended context around the note timestamp
                            const context = getExtendedTranscriptContext(transcript, note.timestamp, 75, 75);

                            if (!context) {
                                // No context available, keep original
                                enhancedNotes.push({ ...note });
                                continue;
                            }

                            // Call AI to summarize with retry logic
                            let result = null;
                            let retries = 3;
                            while (retries > 0 && !result) {
                                try {
                                    result = await summarizeNoteWithContext(context, note.text, SERVER_URL, authToken);
                                } catch (apiError) {
                                    retries--;
                                    if (retries > 0) {
                                        // Wait with exponential backoff
                                        await new Promise(resolve => setTimeout(resolve, 1000 * (4 - retries)));
                                    } else {
                                        console.error(`Failed to enhance note at ${formatTime(note.timestamp)}:`, apiError);
                                        enhancedNotes.push({ ...note }); // Keep original on failure
                                        continue;
                                    }
                                }
                            }

                            if (result) {
                                if (result.isAmbiguous && result.alternatives) {
                                    // Flag for review
                                    ambiguousNotes.push({
                                        noteId: note.id,
                                        timestamp: note.timestamp,
                                        originalText: note.text,
                                        context: context.substring(0, 200) + '...', // Truncate for display
                                        suggestedSummary: result.summary,
                                        alternatives: result.alternatives,
                                        selectedOption: 0 // Default to first option (the suggestion)
                                    });
                                    enhancedNotes.push({ ...note }); // Keep original for now
                                } else {
                                    // Direct replacement - store original text
                                    enhancedNotes.push({
                                        ...note,
                                        text: result.summary,
                                        enhanced: true,
                                        originalText: note.originalText || note.text // Preserve if already enhanced
                                    });
                                }
                            } else {
                                enhancedNotes.push({ ...note });
                            }

                            // Rate limiting delay between API calls
                            await new Promise(resolve => setTimeout(resolve, 500));

                        } catch (error) {
                            console.error(`Error enhancing note at ${formatTime(note.timestamp)}:`, error);
                            enhancedNotes.push({ ...note }); // Keep original on error
                        }
                    }

                    // Update video with enhanced notes (non-ambiguous ones)
                    const updatedVideos = videos.map(v => {
                        if (v.id === activeVideoId) {
                            return { ...v, notes: enhancedNotes };
                        }
                        return v;
                    });
                    setVideos(updatedVideos);

                    // If there are ambiguous notes, show review modal
                    if (ambiguousNotes.length > 0) {
                        setPendingEnhancements(ambiguousNotes);
                        setShowEnhancementReview(true);
                    }

                    console.log(`✅ Enhanced ${activeVideo.notes.length - ambiguousNotes.length} notes, ${ambiguousNotes.length} need review`);

                } catch (error) {
                    console.error('Enhancement failed:', error);
                    alert(`Enhancement failed: ${error.message}`);
                } finally {
                    setIsEnhancing(false);
                    setEnhancementProgress({ current: 0, total: 0 });
                }
            };

            // Apply selected enhancements from review modal
            const handleApplyEnhancements = (selections) => {
                const activeVideo = videos.find(v => v.id === activeVideoId);
                if (!activeVideo) return;

                const updatedNotes = activeVideo.notes.map(note => {
                    const selection = selections.find(s => s.noteId === note.id);
                    if (selection) {
                        // Only mark as enhanced if text actually changed
                        const isChanged = selection.selectedText !== note.text;
                        return {
                            ...note,
                            text: selection.selectedText,
                            enhanced: isChanged ? true : note.enhanced,
                            originalText: isChanged ? (note.originalText || note.text) : note.originalText
                        };
                    }
                    return note;
                });

                const updatedVideos = videos.map(v => {
                    if (v.id === activeVideoId) {
                        return { ...v, notes: updatedNotes };
                    }
                    return v;
                });

                setVideos(updatedVideos);
                setPendingEnhancements([]);
                setShowEnhancementReview(false);
            };

            // Parse timestamp string like "1:23" or "1:23:45" to seconds
            const parseTimestamp = (timeStr) => {
                const parts = timeStr.split(':').map(Number);
                if (parts.length === 3) {
                    return parts[0] * 3600 + parts[1] * 60 + parts[2];
                } else if (parts.length === 2) {
                    return parts[0] * 60 + parts[1];
                }
                return 0;
            };

            const handleImportNotes = (video) => {
                if (!video) {
                    alert('Please select a video first');
                    return;
                }

                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.txt';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const content = event.target.result;
                        // Handle Windows (\r\n) and Unix (\n) line endings
                        const lines = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
                        const importedNotes = [];

                        // Parse each line looking for [timestamp] text pattern
                        // Supports formats: [0:30], [1:23:45], with optional spaces
                        for (let line of lines) {
                            line = line.trim();
                            // More flexible regex: allows spaces, handles various timestamp formats
                            const match = line.match(/^\[(\d{1,2}:\d{2}(?::\d{2})?)\]\s*(.+)$/);
                            if (match) {
                                const timestamp = parseTimestamp(match[1]);
                                const text = match[2].trim();
                                if (text) {
                                    importedNotes.push({
                                        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                                        text: text,
                                        timestamp: timestamp,
                                        createdAt: new Date().toISOString(),
                                        imported: true
                                    });
                                }
                            }
                        }

                        if (importedNotes.length === 0) {
                            alert('No valid notes found in file. Expected format:\n[0:30] Note text here');
                            return;
                        }

                        // Ask user whether to merge or replace
                        const existingCount = video.notes?.length || 0;
                        let shouldMerge = true;
                        if (existingCount > 0) {
                            shouldMerge = confirm(
                                `Found ${importedNotes.length} notes to import.\n\n` +
                                `This video has ${existingCount} existing notes.\n\n` +
                                `Click OK to MERGE (add to existing notes)\n` +
                                `Click Cancel to REPLACE (delete existing notes)`
                            );
                        }

                        setVideos(prev => prev.map(v => {
                            if (v.id === video.id) {
                                const newNotes = shouldMerge
                                    ? [...(v.notes || []), ...importedNotes]
                                    : importedNotes;
                                // Sort by timestamp
                                newNotes.sort((a, b) => a.timestamp - b.timestamp);
                                return { ...v, notes: newNotes };
                            }
                            return v;
                        }));

                        alert(`Successfully imported ${importedNotes.length} notes${shouldMerge && existingCount > 0 ? ' (merged with existing)' : ''}`);
                    };
                    reader.readAsText(file);
                };
                input.click();
            };

            const handleSeek = (timestamp) => {
                if (playerRef.current && playerRef.current.seekTo) {
                    playerRef.current.seekTo(timestamp, true);
                }
            };

            // Category handlers
            const handleAddCategory = (category) => {
                setCategories(prev => [...prev, category]);
            };

            const handleEditCategory = (id, newName) => {
                setCategories(prev => prev.map(c =>
                    c.id === id ? { ...c, name: newName } : c
                ));
                console.log('✅ Updated category:', id, 'to', newName);
            };

            const handleDeleteCategory = (id) => {
                setCategories(prev => prev.filter(c => c.id !== id));
                setVideos(prev => prev.map(v =>
                    v.category === id ? { ...v, category: '' } : v
                ));
            };

            // Export/Import
            const handleExport = () => {
                const data = { videos, categories, exportedAt: new Date().toISOString() };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `youtube-bookmarks-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            };

            const handleImport = (e) => {
                const file = e.target.files?.[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (data.videos) setVideos(data.videos);
                        if (data.categories) setCategories(data.categories);
                    } catch (err) {
                        alert('Invalid file format');
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            };

            // Show loading screen while checking authentication
            if (authLoading) {
                return (
                    <div className="h-screen flex items-center justify-center bg-gray-900">
                        <div className="text-center">
                            <svg className="animate-spin h-12 w-12 text-emerald-500 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <p className="text-gray-400">Loading...</p>
                        </div>
                    </div>
                );
            }

            // Show auth modal if not authenticated
            if (showAuthModal && !isAuthenticated) {
                // Show share preview landing page if there's a pending share
                if (pendingShareToken && (sharePreview || sharePreviewError)) {
                    return (
                        <div className="min-h-screen bg-gray-900 flex items-center justify-center p-4">
                            <div className="max-w-md w-full">
                                {/* Logo */}
                                <div className="text-center mb-8">
                                    <div className="flex items-center justify-center gap-3 mb-2">
                                        <img src="logos/clipmark-favicon.svg" alt="ClipMark" className="w-12 h-12" />
                                        <h1 className="text-3xl font-bold text-emerald-500">ClipMark</h1>
                                    </div>
                                    <p className="text-gray-400">Mark the moments that matter</p>
                                </div>

                                {sharePreviewError ? (
                                    /* Error State */
                                    <div className="bg-gray-800 rounded-xl p-6 text-center">
                                        <div className="w-16 h-16 bg-red-500/20 rounded-full flex items-center justify-center mx-auto mb-4">
                                            <svg className="w-8 h-8 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                                            </svg>
                                        </div>
                                        <h2 className="text-xl font-semibold text-gray-200 mb-2">Share Link Invalid</h2>
                                        <p className="text-gray-400 mb-6">{sharePreviewError}</p>
                                        <button
                                            onClick={() => {
                                                setPendingShareToken(null);
                                                setSharePreviewError(null);
                                                window.history.replaceState({}, document.title, window.location.pathname);
                                            }}
                                            className="px-6 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors"
                                        >
                                            Go to Login
                                        </button>
                                    </div>
                                ) : sharePreview && (
                                    /* Share Preview */
                                    <div className="bg-gray-800 rounded-xl overflow-hidden">
                                        <div className="p-4 bg-gradient-to-r from-emerald-500/20 to-blue-500/20 border-b border-gray-700">
                                            <p className="text-center text-gray-200">
                                                <span className="text-emerald-400 font-semibold">{sharePreview.ownerUsername}</span>
                                                {' '}wants to share a video with you!
                                            </p>
                                        </div>

                                        {/* Video Preview */}
                                        <div className="p-4">
                                            <div className="relative rounded-lg overflow-hidden mb-4">
                                                <img
                                                    src={sharePreview.videoThumbnail}
                                                    alt={sharePreview.videoTitle}
                                                    className="w-full aspect-video object-cover"
                                                />
                                                <div className="absolute inset-0 bg-black/40 flex items-center justify-center">
                                                    <div className="w-16 h-16 bg-red-600 rounded-full flex items-center justify-center">
                                                        <svg className="w-8 h-8 text-white ml-1" fill="currentColor" viewBox="0 0 24 24">
                                                            <path d="M8 5v14l11-7z" />
                                                        </svg>
                                                    </div>
                                                </div>
                                            </div>

                                            <h3 className="font-semibold text-gray-200 mb-2">{sharePreview.videoTitle}</h3>

                                            {sharePreview.includeNotes && sharePreview.noteCount > 0 && (
                                                <p className="text-sm text-gray-400 flex items-center gap-2">
                                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                                                    </svg>
                                                    Includes {sharePreview.noteCount} notes
                                                </p>
                                            )}
                                        </div>

                                        {/* CTA */}
                                        <div className="p-4 bg-gray-700/50 border-t border-gray-700">
                                            <p className="text-sm text-gray-400 text-center mb-4">
                                                Sign up or log in to accept this shared video
                                            </p>
                                            <AuthModal
                                                isOpen={true}
                                                onLogin={handleLogin}
                                                serverUrl={SERVER_URL}
                                                embedded={true}
                                            />
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    );
                }

                return (
                    <AuthModal
                        isOpen={true}
                        onLogin={handleLogin}
                        serverUrl={SERVER_URL}
                    />
                );
            }

            // Show admin dashboard if on admin route
            if (isAdminRoute && isAuthenticated) {
                return (
                    <AdminDashboard
                        serverUrl={SERVER_URL}
                        authToken={authToken}
                        onLogout={handleLogout}
                        username={currentUser?.username}
                    />
                );
            }

            return (
                <div className="h-screen flex flex-col">
                    {/* Header */}
                    <header className="bg-gray-800 border-b border-gray-700 px-4 py-3 flex items-center justify-between shrink-0">
                        <div className="flex items-center gap-3">
                            <div className="flex items-center gap-3">
                                {/* ClipMark Logo */}
                                <img src="logos/clipmark-favicon.svg" alt="ClipMark" className="w-10 h-10" />
                                <h1 className="text-2xl font-bold text-emerald-500">ClipMark</h1>
                            </div>
                        </div>
                        <div className="flex items-center gap-2">
                            <button
                                onClick={() => setShowLibrary(!showLibrary)}
                                className={`p-2 rounded-lg transition-colors ${showLibrary ? 'bg-emerald-500 text-white' : 'bg-gray-700 hover:bg-gray-600'}`}
                                title="Toggle Library"
                            >
                                <Icons.Grid />
                            </button>
                            <button
                                onClick={handleExport}
                                className="p-2 bg-gray-700 hover:bg-gray-600 rounded-lg"
                                title="Export Bookmarks"
                            >
                                <Icons.Download />
                            </button>
                            <button
                                onClick={() => fileInputRef.current?.click()}
                                className="p-2 bg-gray-700 hover:bg-gray-600 rounded-lg"
                                title="Import Bookmarks"
                            >
                                <Icons.Upload />
                            </button>
                            <input
                                ref={fileInputRef}
                                type="file"
                                accept=".json"
                                onChange={handleImport}
                                className="hidden"
                            />
                            {/* Pending Shares Notification */}
                            <PendingSharesDropdown
                                serverUrl={SERVER_URL}
                                authToken={authToken}
                                onAcceptShare={reloadSharedVideos}
                            />
                            <button
                                onClick={() => setShowSettingsModal(true)}
                                className={`p-2 rounded-lg transition-colors ${apiStatus.geminiConfigured ? 'bg-gray-700 hover:bg-gray-600' : 'bg-yellow-600 hover:bg-yellow-700'}`}
                                title={apiStatus.geminiConfigured ? 'Settings' : 'Gemini AI not configured'}
                            >
                                <Icons.Settings />
                            </button>
                            <button
                                onClick={handleRefresh}
                                disabled={isRefreshing}
                                className="p-2 bg-gray-700 hover:bg-gray-600 disabled:bg-gray-600 disabled:cursor-not-allowed rounded-lg transition-colors"
                                title="Refresh bookmarks from server"
                            >
                                {isRefreshing ? (
                                    <svg className="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                ) : (
                                    <Icons.Refresh />
                                )}
                            </button>
                            <div className="flex items-center gap-2 text-sm px-3 py-2 rounded-lg">
                                {saveStatus === 'saving' && (
                                    <span className="text-yellow-400 animate-pulse">💾 Saving...</span>
                                )}
                                {saveStatus === 'saved' && lastSaveTime && (
                                    <span className="text-green-400">✓ Saved</span>
                                )}
                                {saveStatus === 'error' && (
                                    <span className="text-emerald-400">⚠️ Save failed</span>
                                )}
                            </div>
                            {/* Admin link for admin users */}
                            {isAdmin && (
                                <a
                                    href="/admin"
                                    className="p-2 bg-purple-500/20 hover:bg-purple-500/30 text-purple-400 rounded-lg transition-colors"
                                    title="Admin Dashboard"
                                >
                                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                                    </svg>
                                </a>
                            )}
                            {/* User info and logout */}
                            {currentUser && (
                                <div className="flex items-center gap-2 px-3 py-1 bg-gray-700 rounded-lg">
                                    <svg className="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                                    </svg>
                                    <span className="text-sm text-gray-300">{currentUser.username}</span>
                                    {isAdmin && (
                                        <span className="px-1.5 py-0.5 bg-purple-500/20 text-purple-400 text-xs rounded">Admin</span>
                                    )}
                                    <button
                                        onClick={handleLogout}
                                        className="ml-1 p-1 text-gray-400 hover:text-emerald-400 transition-colors"
                                        title="Logout"
                                    >
                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                                        </svg>
                                    </button>
                                </div>
                            )}
                            <button
                                onClick={() => setShowAddModal(true)}
                                className="flex items-center gap-2 bg-emerald-500 hover:bg-emerald-600 px-4 py-2 rounded-lg font-medium transition-colors"
                            >
                                <Icons.Plus />
                                Add Video
                            </button>
                        </div>
                    </header>

                    {/* Storage Warning Banner */}
                    {!storageAvailable && (
                        <div className="bg-red-900/90 text-white px-4 py-4 border-b border-red-800 flex items-center justify-between gap-4">
                            <div>
                                <p className="font-semibold">⚠️ Storage Unavailable</p>
                                <p className="text-sm text-red-100">Private browsing mode detected. Your bookmarks cannot be saved. Please use normal browsing mode or download your data regularly.</p>
                            </div>
                            <button
                                onClick={handleExport}
                                className="flex-shrink-0 bg-white text-red-900 font-medium px-4 py-2 rounded-lg hover:bg-red-50 transition-colors whitespace-nowrap"
                            >
                                Download Data Now
                            </button>
                        </div>
                    )}

                    <div className="flex flex-1 overflow-hidden">
                        {/* Sidebar */}
                        <aside className="w-64 bg-gray-800 border-r border-gray-700 flex flex-col shrink-0">
                            {/* Search */}
                            <div className="p-4">
                                <div className="relative">
                                    <input
                                        type="text"
                                        value={searchQuery}
                                        onChange={(e) => setSearchQuery(e.target.value)}
                                        placeholder="Search videos & notes..."
                                        className="w-full bg-gray-700 rounded-lg pl-10 pr-4 py-2 text-sm placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                    />
                                    <div className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400">
                                        <Icons.Search />
                                    </div>
                                </div>
                            </div>

                            {/* Categories */}
                            <div className="px-4 pb-2">
                                <div className="flex items-center justify-between mb-2">
                                    <h3 className="text-sm font-medium text-gray-400">Categories</h3>
                                    <button
                                        onClick={() => setShowCategoryModal(true)}
                                        className="p-1 hover:bg-gray-700 rounded text-gray-400 hover:text-gray-200"
                                    >
                                        <Icons.Plus />
                                    </button>
                                </div>
                                <div className="space-y-1">
                                    <button
                                        onClick={() => {
                                            setSelectedCategory('all');
                                            setShowSharedWithMe(false);
                                        }}
                                        className={`w-full flex items-center gap-2 px-3 py-2 rounded-lg text-sm transition-colors ${
                                            selectedCategory === 'all' && !showSharedWithMe ? 'bg-emerald-500/20 text-emerald-400' : 'hover:bg-gray-700'
                                        }`}
                                    >
                                        <Icons.Folder />
                                        All Videos
                                        <span className="ml-auto text-xs text-gray-500">{videos.length}</span>
                                    </button>
                                    {/* Shared with me button */}
                                    <button
                                        onClick={() => {
                                            setShowSharedWithMe(true);
                                            setShowLibrary(true);
                                        }}
                                        className={`w-full flex items-center gap-2 px-3 py-2 rounded-lg text-sm transition-colors ${
                                            showSharedWithMe ? 'bg-blue-500/20 text-blue-400' : 'hover:bg-gray-700'
                                        }`}
                                    >
                                        <Icons.Users />
                                        Shared with me
                                        {sharedWithMe.length > 0 && (
                                            <span className="ml-auto text-xs text-gray-500">{sharedWithMe.length}</span>
                                        )}
                                    </button>
                                    {categories.map(cat => (
                                        <button
                                            key={cat.id}
                                            onClick={() => {
                                                setSelectedCategory(cat.id);
                                                setShowSharedWithMe(false);
                                            }}
                                            className={`w-full flex items-center gap-2 px-3 py-2 rounded-lg text-sm transition-colors ${
                                                selectedCategory === cat.id && !showSharedWithMe ? 'bg-emerald-500/20 text-emerald-400' : 'hover:bg-gray-700'
                                            }`}
                                        >
                                            <Icons.Folder />
                                            {cat.name}
                                            <span className="ml-auto text-xs text-gray-500">
                                                {videos.filter(v => v.category === cat.id).length}
                                            </span>
                                        </button>
                                    ))}
                                </div>
                            </div>

                            {/* Sort By */}
                            <div className="px-3 mb-3">
                                <label className="block text-xs text-gray-400 mb-1">Sort By</label>
                                <select
                                    value={sortBy}
                                    onChange={(e) => setSortBy(e.target.value)}
                                    className="w-full bg-gray-700 rounded-lg px-3 py-2 text-sm text-gray-100"
                                >
                                    <option value="default">Default Order</option>
                                    <option value="date-desc">Newest First</option>
                                    <option value="date-asc">Oldest First</option>
                                </select>
                            </div>

                            {/* Video List */}
                            <div className="flex-1 overflow-y-auto scrollbar-thin px-4 py-2">
                                <h3 className="text-sm font-medium text-gray-400 mb-2">Videos</h3>
                                <div className="space-y-2">
                                    {sortedVideos.map(video => (
                                        <div key={video.id} className="mb-2">
                                            <button
                                                onClick={() => {
                                                    setActiveVideoId(video.id);
                                                    setShowLibrary(false);
                                                    setNoteSearch('');
                                                }}
                                                className={`w-full text-left p-2 rounded-lg transition-colors ${
                                                    activeVideoId === video.id ? 'bg-emerald-500/20 ring-1 ring-emerald-500' : 'bg-gray-700 hover:bg-gray-600'
                                                }`}
                                            >
                                                <div className="flex gap-2">
                                                    <img
                                                        src={`https://img.youtube.com/vi/${video.videoId}/default.jpg`}
                                                        alt=""
                                                        className="w-16 h-12 object-cover rounded"
                                                />
                                                    <div className="flex-1 min-w-0">
                                                        <p className="text-sm font-medium truncate">{video.title}</p>
                                                        <p className="text-xs text-gray-400">{video.notes?.length || 0} notes</p>
                                                    </div>
                                                </div>
                                            </button>
                                            {video.publishDate && (
                                                <p className="text-xs text-gray-500 mt-1 pl-1 border-t border-gray-600 pt-1">
                                                    Published: {formatPublishDate(video.publishDate)}
                                                </p>
                                            )}
                                        </div>
                                    ))}
                                    {sortedVideos.length === 0 && (
                                        <p className="text-center text-gray-500 py-4 text-sm">
                                            {videos.length === 0 ? 'No videos yet. Add one!' : 'No matching videos'}
                                        </p>
                                    )}
                                </div>
                            </div>
                        </aside>

                        {/* Main Content */}
                        <main className="flex-1 flex flex-col overflow-hidden">
                            {showLibrary ? (
                                showSharedWithMe ? (
                                    /* Shared with me Grid View */
                                    <div className="flex-1 overflow-y-auto p-6 scrollbar-thin">
                                        <h2 className="text-2xl font-bold mb-6 flex items-center gap-3">
                                            <Icons.Users />
                                            Shared with me
                                        </h2>
                                        {sharedWithMe.length > 0 ? (
                                            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                                                {sharedWithMe.map(shared => (
                                                    <div
                                                        key={shared.shareId}
                                                        className="cursor-pointer rounded-lg overflow-hidden transition-all hover:ring-2 hover:ring-gray-600"
                                                        onClick={() => {
                                                            // Open YouTube video in new tab since shared videos aren't in the user's library
                                                            window.open(`https://www.youtube.com/watch?v=${shared.youtubeVideoId}`, '_blank');
                                                        }}
                                                    >
                                                        <div className="relative group">
                                                            <img
                                                                src={shared.videoThumbnail || `https://img.youtube.com/vi/${shared.youtubeVideoId}/mqdefault.jpg`}
                                                                alt={shared.videoTitle}
                                                                className="w-full aspect-video object-cover"
                                                            />
                                                            <div className="absolute bottom-2 right-2 bg-black/80 px-2 py-0.5 rounded text-xs">
                                                                {shared.notes?.length || 0} notes
                                                            </div>
                                                            <div className="absolute top-2 left-2 bg-blue-500/90 px-2 py-0.5 rounded text-xs flex items-center gap-1">
                                                                <span>From {shared.fromUsername}</span>
                                                            </div>
                                                        </div>
                                                        <div className="p-3 bg-gray-800">
                                                            <h3 className="font-medium text-sm line-clamp-2">{shared.videoTitle}</h3>
                                                            <p className="text-xs text-gray-400 mt-1">
                                                                Shared {new Date(shared.sharedAt).toLocaleDateString()}
                                                            </p>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        ) : (
                                            <div className="flex flex-col items-center justify-center h-64 text-gray-400">
                                                <Icons.Users />
                                                <p className="mt-4 text-lg">No shared videos yet</p>
                                                <p className="text-sm">When someone shares a video with you, it will appear here</p>
                                            </div>
                                        )}
                                    </div>
                                ) : (
                                    /* Library Grid View */
                                    <div className="flex-1 overflow-y-auto p-6 scrollbar-thin">
                                        <h2 className="text-2xl font-bold mb-6">Your Library</h2>
                                        {sortedVideos.length > 0 ? (
                                            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                                                {sortedVideos.map(video => (
                                                    <VideoCard
                                                        key={video.id}
                                                        video={video}
                                                        isActive={video.id === activeVideoId}
                                                        onClick={() => {
                                                            setActiveVideoId(video.id);
                                                            setShowLibrary(false);
                                                            setShowSharedWithMe(false);
                                                            setNoteSearch('');
                                                        }}
                                                        onDelete={() => handleDeleteVideo(video.id)}
                                                        onEdit={handleEditVideo}
                                                        onShare={(video) => {
                                                            setShareVideo(video);
                                                            setShowShareModal(true);
                                                        }}
                                                        onFetchPublishDate={handleFetchPublishDate}
                                                        isFetchingDate={fetchingDateFor === video.id}
                                                    />
                                                ))}
                                            </div>
                                        ) : (
                                            <div className="flex flex-col items-center justify-center h-64 text-gray-400">
                                                <Icons.Bookmark />
                                                <p className="mt-4 text-lg">No videos yet</p>
                                                <p className="text-sm">Click "Add Video" to get started</p>
                                            </div>
                                        )}
                                    </div>
                                )
                            ) : (
                                /* Video Player View */
                                <div className="flex-1 flex overflow-hidden">
                                    {/* Player Area */}
                                    <div className="flex-1 flex flex-col p-4 overflow-hidden">
                                        {/* Video Player - Smaller size */}
                                        <div className="w-full max-w-3xl mx-auto shrink-0 mb-4">
                                            <div className="aspect-video bg-black rounded-lg overflow-hidden">
                                                <YouTubePlayer
                                                    videoId={activeVideo?.videoId}
                                                    onTimeUpdate={setCurrentTime}
                                                    playerRef={playerRef}
                                                    onWatchTime={trackWatchTime}
                                                />
                                            </div>
                                        </div>

                                        {/* Enhancement Toolbar */}
                                        {activeVideo && (
                                            <div className="w-full max-w-3xl mx-auto mb-4">
                                                <div className="bg-gray-800 rounded-lg px-4 py-3 flex items-center justify-between">
                                                    <div className="flex items-center gap-3">
                                                        <button
                                                            onClick={handleEnhanceAllNotes}
                                                            disabled={isEnhancing || !activeVideo.notes || activeVideo.notes.length === 0 || !apiStatus.geminiConfigured}
                                                            className="flex items-center gap-2 px-3 py-2 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-700 disabled:cursor-not-allowed disabled:opacity-50 rounded-lg text-sm font-medium transition-colors"
                                                            title={!apiStatus.geminiConfigured ? "Gemini AI not configured on server" : "Enhance all notes with AI"}
                                                        >
                                                            {isEnhancing ? (
                                                                <>
                                                                    <svg className="animate-spin h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                                    </svg>
                                                                    Processing {enhancementProgress.current}/{enhancementProgress.total}...
                                                                </>
                                                            ) : (
                                                                <>
                                                                    <Icons.Sparkles />
                                                                    Enhance Notes
                                                                </>
                                                            )}
                                                        </button>
                                                        <button
                                                            onClick={() => handleExportMarkdown(activeVideo)}
                                                            disabled={!activeVideo.notes || activeVideo.notes.length === 0}
                                                            className="flex items-center gap-2 px-3 py-2 bg-gray-600 hover:bg-gray-500 disabled:bg-gray-700 disabled:cursor-not-allowed disabled:opacity-50 rounded-lg text-sm font-medium transition-colors"
                                                            title="Download notes as Markdown file"
                                                        >
                                                            <Icons.Download />
                                                            Download .md
                                                        </button>
                                                    </div>
                                                    {!apiStatus.geminiConfigured && (
                                                        <p className="text-xs text-gray-500">
                                                            Gemini AI not configured on server - AI enhancement unavailable
                                                        </p>
                                                    )}
                                                </div>
                                            </div>
                                        )}

                                        {/* Video Info & Note Input */}
                                        {activeVideo && (
                                            <div className="w-full max-w-3xl mx-auto flex-1 overflow-y-auto min-h-0">
                                                <div className="flex items-start justify-between mb-4">
                                                    <div>
                                                        <h2 className="text-xl font-semibold">{activeVideo.title}</h2>
                                                        <div className="flex items-center gap-2 mt-1">
                                                            {activeVideo.tags?.map(tag => (
                                                                <span key={tag} className="flex items-center gap-1 text-xs bg-gray-700 px-2 py-1 rounded-full">
                                                                    <Icons.Tag />
                                                                    {tag}
                                                                </span>
                                                            ))}
                                                        </div>
                                                    </div>
                                                    <div className="flex items-center gap-2">
                                                        <button
                                                            onClick={() => {
                                                                setShareVideo(activeVideo);
                                                                setShowShareModal(true);
                                                            }}
                                                            className="p-2 hover:bg-gray-700 rounded-lg text-gray-400 hover:text-blue-400"
                                                            title="Share video"
                                                        >
                                                            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
                                                            </svg>
                                                        </button>
                                                        <button
                                                            onClick={() => handleDeleteVideo(activeVideo.id)}
                                                            className="p-2 hover:bg-gray-700 rounded-lg text-gray-400 hover:text-emerald-400"
                                                            title="Delete video"
                                                        >
                                                            <Icons.Trash />
                                                        </button>
                                                    </div>
                                                </div>

                                                {/* Note Input */}
                                                <div className="bg-gray-800 rounded-lg p-4">
                                                    {/* Header row */}
                                                    <div className="flex items-center justify-between mb-3">
                                                        <span className="text-emerald-500 font-semibold italic">ClipMark</span>
                                                        <span className="text-gray-400 text-sm">Adding note at {formatTime(currentTime)}</span>
                                                    </div>
                                                    {/* Main input row */}
                                                    <div className="flex gap-3">
                                                        <textarea
                                                            value={newNote}
                                                            onChange={(e) => setNewNote(e.target.value)}
                                                            placeholder="Add a note at this timestamp... (Click 'Get Context' to auto-fill with transcript)"
                                                            className="flex-1 bg-gray-700 rounded-lg px-4 py-3 text-gray-100 placeholder-gray-500 resize-none focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                                            rows={3}
                                                            onKeyDown={(e) => {
                                                                if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
                                                                    handleAddNote();
                                                                }
                                                            }}
                                                        />
                                                        <div className="flex flex-col gap-2 w-32">
                                                            <button
                                                                onClick={handleLoadContext}
                                                                disabled={isLoadingContext}
                                                                className="flex-1 bg-gray-600 hover:bg-gray-500 disabled:bg-gray-700 disabled:cursor-not-allowed rounded-lg text-sm font-medium transition-colors flex items-center justify-center gap-2"
                                                                title={`Load transcript context (±${contextWordCount} words around current timestamp)`}
                                                            >
                                                                {isLoadingContext ? (
                                                                    <>
                                                                        <svg className="animate-spin h-3 w-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                                        </svg>
                                                                        Loading...
                                                                    </>
                                                                ) : 'Get Context'}
                                                            </button>
                                                            <button
                                                                onClick={handleAddNote}
                                                                disabled={!newNote.trim()}
                                                                className={`flex-1 ${newNote.trim() ? 'bg-emerald-500 hover:bg-emerald-600' : 'bg-gray-700'} disabled:cursor-not-allowed text-white font-medium rounded-lg transition-colors`}
                                                            >
                                                                Add Note
                                                            </button>
                                                        </div>
                                                    </div>
                                                    {/* Help text */}
                                                    <p className="text-xs text-gray-500 mt-3 text-center">Press Ctrl+Enter to save • Click "Get Context" to load ±{contextWordCount} words from transcript</p>
                                                </div>
                                                {/* Footer - outside note container */}
                                                <p className="text-xs text-gray-600 mt-2 text-center">© 2026 Absolute 0 Internet Studios</p>
                                            </div>
                                        )}
                                    </div>

                                    {/* Notes Panel */}
                                    {activeVideo && (
                                        <aside className="w-80 bg-gray-800 border-l border-gray-700 flex flex-col shrink-0">
                                            <div className="p-4 border-b border-gray-700 flex items-center justify-between">
                                                <h3 className="font-semibold">Notes ({activeVideo.notes?.length || 0})</h3>
                                                <div className="flex gap-1">
                                                    <button
                                                        onClick={() => handleImportNotes(activeVideo)}
                                                        className="px-3 py-1 bg-gray-600 hover:bg-gray-500 rounded text-xs font-medium transition-colors flex items-center gap-1"
                                                        title="Import notes from text file"
                                                    >
                                                        <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                                                        </svg>
                                                        Import
                                                    </button>
                                                    <button
                                                        onClick={() => handleExportNotes(activeVideo)}
                                                        disabled={!activeVideo.notes || activeVideo.notes.length === 0}
                                                        className="px-3 py-1 bg-gray-600 hover:bg-gray-500 disabled:bg-gray-700 disabled:cursor-not-allowed disabled:opacity-50 rounded text-xs font-medium transition-colors flex items-center gap-1"
                                                        title="Export notes as text file"
                                                    >
                                                        <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                                        </svg>
                                                        Export
                                                    </button>
                                                </div>
                                            </div>
                                            {/* Notes Search */}
                                            {activeVideo.notes?.length > 0 && (
                                                <div className="px-4 pt-3 pb-2 border-b border-gray-700">
                                                    <div className="relative">
                                                        <svg className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                                        </svg>
                                                        <input
                                                            type="text"
                                                            value={noteSearch}
                                                            onChange={(e) => setNoteSearch(e.target.value)}
                                                            placeholder="Search notes..."
                                                            className="w-full bg-gray-700 rounded-lg pl-10 pr-8 py-2 text-sm text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                                        />
                                                        {noteSearch && (
                                                            <button
                                                                onClick={() => setNoteSearch('')}
                                                                className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-500 hover:text-gray-300"
                                                            >
                                                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                                                </svg>
                                                            </button>
                                                        )}
                                                    </div>
                                                    {noteSearch && (
                                                        <p className="text-xs text-gray-500 mt-1">
                                                            {activeVideo.notes.filter(n => n.text.toLowerCase().includes(noteSearch.toLowerCase())).length} of {activeVideo.notes.length} notes
                                                        </p>
                                                    )}
                                                </div>
                                            )}
                                            <div className="flex-1 overflow-y-auto p-4 scrollbar-thin">
                                                {activeVideo.notes?.length > 0 ? (
                                                    (() => {
                                                        const filteredNotes = noteSearch
                                                            ? activeVideo.notes.filter(n => n.text.toLowerCase().includes(noteSearch.toLowerCase()))
                                                            : activeVideo.notes;
                                                        return filteredNotes.length > 0 ? (
                                                            filteredNotes.map(note => (
                                                                <NoteItem
                                                                    key={note.id}
                                                                    note={note}
                                                                    onSeek={handleSeek}
                                                                    onDelete={handleDeleteNote}
                                                                    onEdit={handleEditNote}
                                                                    searchTerm={noteSearch}
                                                                />
                                                            ))
                                                        ) : (
                                                            <p className="text-center text-gray-500 py-8">
                                                                No notes match "{noteSearch}"
                                                            </p>
                                                        );
                                                    })()
                                                ) : (
                                                    <p className="text-center text-gray-500 py-8">
                                                        No notes yet. Add one below!
                                                    </p>
                                                )}
                                            </div>
                                        </aside>
                                    )}
                                </div>
                            )}
                        </main>
                    </div>

                    {/* Modals */}
                    <AddVideoModal
                        isOpen={showAddModal}
                        onClose={() => setShowAddModal(false)}
                        onAdd={handleAddVideo}
                        categories={categories}
                        onAddCategory={handleAddCategory}
                    />
                    <EditVideoModal
                        isOpen={showEditModal}
                        onClose={() => setShowEditModal(false)}
                        video={editingVideo}
                        onSave={handleSaveEditedVideo}
                        categories={categories}
                        onAddCategory={handleAddCategory}
                    />
                    <CategoryModal
                        isOpen={showCategoryModal}
                        onClose={() => setShowCategoryModal(false)}
                        categories={categories}
                        onAdd={handleAddCategory}
                        onEdit={handleEditCategory}
                        onDelete={handleDeleteCategory}
                    />
                    <SettingsModal
                        isOpen={showSettingsModal}
                        onClose={() => setShowSettingsModal(false)}
                        apiStatus={apiStatus}
                        contextWordCount={contextWordCount}
                        onSaveContextWordCount={handleSaveContextWordCount}
                        onOpenProfile={() => setShowProfileModal(true)}
                    />
                    <ProfileModal
                        isOpen={showProfileModal}
                        onClose={() => setShowProfileModal(false)}
                        serverUrl={SERVER_URL}
                        authToken={authToken}
                        currentUser={currentUser}
                    />
                    <ShareModal
                        isOpen={showShareModal}
                        onClose={() => {
                            setShowShareModal(false);
                            setShareVideo(null);
                        }}
                        video={shareVideo}
                        serverUrl={SERVER_URL}
                        authToken={authToken}
                    />
                    <EnhancementReviewModal
                        isOpen={showEnhancementReview}
                        onClose={() => {
                            setShowEnhancementReview(false);
                            setPendingEnhancements([]);
                        }}
                        pendingEnhancements={pendingEnhancements}
                        onApply={handleApplyEnhancements}
                    />
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
